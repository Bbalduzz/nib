{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Build native macOS menu bar apps in Python. Nib is a Python framework that lets you create macOS menu bar applications with a declarative, SwiftUI-inspired API. Write your app logic in Python \u2014 Nib handles the native rendering through a Swift runtime. import nib def main ( app : nib . App ): app . title = \"My App\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . width = 300 app . height = 200 counter = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) app . build ( nib . VStack ( controls = [ counter , nib . Button ( \"Add\" , action = increment ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Why Nib? \u00b6 Native SwiftUI rendering \u2014 Your app looks and feels like a real macOS app because it is one. No web views, no Electron. Python simplicity \u2014 Write your entire app in Python. No Swift knowledge required. 30+ UI components \u2014 Text, buttons, toggles, sliders, pickers, charts, maps, tables, canvas drawing, and more. System integration \u2014 Access battery, connectivity, screen, keychain, camera, notifications, and file dialogs. Reactive updates \u2014 Mutate a property and the UI updates automatically. No state management boilerplate. Build to .app \u2014 Bundle your app into a standalone .app with nib build . Includes Python runtime, dependencies, and code signing. Hot reload \u2014 nib run watches your files and reloads on every save. Quick Start \u00b6 pip install pynib nib create myapp cd myapp nib run src/main.py Requirements \u00b6 macOS 14+ Python 3.10+ Next Steps \u00b6 Getting Started \u2014 Install Nib and build your first app in minutes. Concepts \u2014 Understand the architecture, reactivity model, and view system. Guides \u2014 Task-oriented guides for layouts, styling, animations, notifications, and more. API Reference \u2014 Complete reference for every class, method, and parameter.","title":"Home"},{"location":"#why-nib","text":"Native SwiftUI rendering \u2014 Your app looks and feels like a real macOS app because it is one. No web views, no Electron. Python simplicity \u2014 Write your entire app in Python. No Swift knowledge required. 30+ UI components \u2014 Text, buttons, toggles, sliders, pickers, charts, maps, tables, canvas drawing, and more. System integration \u2014 Access battery, connectivity, screen, keychain, camera, notifications, and file dialogs. Reactive updates \u2014 Mutate a property and the UI updates automatically. No state management boilerplate. Build to .app \u2014 Bundle your app into a standalone .app with nib build . Includes Python runtime, dependencies, and code signing. Hot reload \u2014 nib run watches your files and reloads on every save.","title":"Why Nib?"},{"location":"#quick-start","text":"pip install pynib nib create myapp cd myapp nib run src/main.py","title":"Quick Start"},{"location":"#requirements","text":"macOS 14+ Python 3.10+","title":"Requirements"},{"location":"#next-steps","text":"Getting Started \u2014 Install Nib and build your first app in minutes. Concepts \u2014 Understand the architecture, reactivity model, and view system. Guides \u2014 Task-oriented guides for layouts, styling, animations, notifications, and more. API Reference \u2014 Complete reference for every class, method, and parameter.","title":"Next Steps"},{"location":"cli/","text":"Nib provides a command-line interface with three commands for the full development lifecycle of a macOS menu bar application. Command Description nib create Scaffold a new project with standard structure nib run Run your app in development mode with hot reload nib build Build a standalone .app bundle for distribution All commands support -v / --verbose for detailed output. Configuration \u00b6 Commands read defaults from pyproject.toml when present. See the pyproject.toml configuration reference for all available options. Quick start \u00b6 nib create my-app # Scaffold a new project cd my_app nib run # Run with hot reload (reads entry from pyproject.toml) nib build # Build standalone .app bundle","title":"Index"},{"location":"cli/#configuration","text":"Commands read defaults from pyproject.toml when present. See the pyproject.toml configuration reference for all available options.","title":"Configuration"},{"location":"cli/#quick-start","text":"nib create my-app # Scaffold a new project cd my_app nib run # Run with hot reload (reads entry from pyproject.toml) nib build # Build standalone .app bundle","title":"Quick start"},{"location":"cli/build/","text":"Build a standalone macOS .app bundle from a Nib application. The output is a self-contained application that runs without requiring Python or any dependencies on the target system. Usage \u00b6 nib build [ script.py ] [ options ] If no script is specified, nib build reads the entry point from pyproject.toml : nib build # Uses [tool.nib] entry (defaults to src/main.py) nib build src/main.py # Explicit script path The resulting bundle is written to dist/AppName.app by default. Options \u00b6 General \u00b6 Flag Description -o , --output <dir> Output directory (default: dist/ ) -n , --name <name> App display name (default: from pyproject.toml or script name) -i , --icon <path> Icon file -- .icns or .png (PNG is auto-converted to ICNS) --identifier <id> Bundle identifier (default: com.nib.<name> ) --version <ver> App version string (default: 1.0.0 ) --extra-deps <pkgs> Additional pip packages to include, comma-separated --exclude <pkgs> Packages to exclude from bundling, comma-separated --min-macos <ver> Minimum macOS version (default: current system version) --arch <arch> Target architecture: arm64 or x86_64 (default: current machine) -v , --verbose Verbose build output Code protection \u00b6 Flag Description --native Compile .py files to native .so modules via Cython --obfuscate Strip debug info from .pyc bytecode (function names, line numbers, variable names) --no-compile Keep .py source files as-is (skip bytecode compilation) By default, Python files are compiled to .pyc bytecode with optimization level 2 (docstrings and asserts removed). Mutually exclusive flags --native and --no-compile cannot be used together --obfuscate and --no-compile cannot be used together --native and --obfuscate cannot be used together (native code is already opaque) Optimization \u00b6 Flag Description --optimize Optimize bundle size: strips debug symbols from binaries, prunes unused stdlib modules, removes .dist-info metadata Build pipeline \u00b6 The build process runs through six phases: Setup -- Locates the nib-runtime Swift executable and detects third-party dependencies via AST analysis of your script. Dependencies listed in [project].dependencies in pyproject.toml take precedence over auto-detection. Python environment -- Downloads a portable python-build-standalone distribution (cached in ~/.cache/nib/ ), extracts it, and vendors all dependencies with pip install --target . Copy code -- Copies your script, sibling .py files, local packages, and the assets/ directory into the bundle. Fonts in assets/ are automatically registered. Compile -- Compiles Python to bytecode ( .pyc ), native modules ( .so ), or leaves source as-is depending on flags. Finalize -- Installs the Swift runtime as the main executable, converts the icon to .icns format, and generates Info.plist from your configuration. Cleanup and sign -- Prunes the Python distribution (removes test suites, idle, tkinter, etc.), optionally strips binaries, and applies an ad-hoc code signature. Bundle structure \u00b6 My App . app / \u2514\u2500\u2500 Contents / \u251c\u2500\u2500 Info . plist \u251c\u2500\u2500 MacOS / \u2502 \u2514\u2500\u2500 My App # Swift runtime (main executable) \u2514\u2500\u2500 Resources / \u251c\u2500\u2500 app / \u2502 \u251c\u2500\u2500 main . pyc # Your compiled application code \u2502 \u2514\u2500\u2500 vendor / # Vendored dependencies + nib SDK \u251c\u2500\u2500 assets / # Your assets (icons, images, fonts) \u2514\u2500\u2500 python / # Embedded Python distribution Examples \u00b6 Build with defaults from pyproject.toml : nib build Build with a custom name and icon: nib build src/main.py --name \"Weather Widget\" --icon src/assets/icon.png Build with native compilation for maximum code protection: nib build --native Cython required The --native flag requires Cython to be installed: pip install cython Build an optimized, obfuscated release: nib build --obfuscate --optimize Build for a specific architecture: nib build --arch x86_64 Build with additional dependencies that auto-detection missed: nib build --extra-deps \"pillow,scipy\" Configuration precedence \u00b6 When both CLI arguments and pyproject.toml settings are present, CLI arguments take precedence: Command-line arguments (highest priority) [tool.nib.build] section in pyproject.toml Default values See the pyproject.toml configuration reference for all available settings.","title":"nib build"},{"location":"cli/build/#usage","text":"nib build [ script.py ] [ options ] If no script is specified, nib build reads the entry point from pyproject.toml : nib build # Uses [tool.nib] entry (defaults to src/main.py) nib build src/main.py # Explicit script path The resulting bundle is written to dist/AppName.app by default.","title":"Usage"},{"location":"cli/build/#options","text":"","title":"Options"},{"location":"cli/build/#general","text":"Flag Description -o , --output <dir> Output directory (default: dist/ ) -n , --name <name> App display name (default: from pyproject.toml or script name) -i , --icon <path> Icon file -- .icns or .png (PNG is auto-converted to ICNS) --identifier <id> Bundle identifier (default: com.nib.<name> ) --version <ver> App version string (default: 1.0.0 ) --extra-deps <pkgs> Additional pip packages to include, comma-separated --exclude <pkgs> Packages to exclude from bundling, comma-separated --min-macos <ver> Minimum macOS version (default: current system version) --arch <arch> Target architecture: arm64 or x86_64 (default: current machine) -v , --verbose Verbose build output","title":"General"},{"location":"cli/build/#code-protection","text":"Flag Description --native Compile .py files to native .so modules via Cython --obfuscate Strip debug info from .pyc bytecode (function names, line numbers, variable names) --no-compile Keep .py source files as-is (skip bytecode compilation) By default, Python files are compiled to .pyc bytecode with optimization level 2 (docstrings and asserts removed). Mutually exclusive flags --native and --no-compile cannot be used together --obfuscate and --no-compile cannot be used together --native and --obfuscate cannot be used together (native code is already opaque)","title":"Code protection"},{"location":"cli/build/#optimization","text":"Flag Description --optimize Optimize bundle size: strips debug symbols from binaries, prunes unused stdlib modules, removes .dist-info metadata","title":"Optimization"},{"location":"cli/build/#build-pipeline","text":"The build process runs through six phases: Setup -- Locates the nib-runtime Swift executable and detects third-party dependencies via AST analysis of your script. Dependencies listed in [project].dependencies in pyproject.toml take precedence over auto-detection. Python environment -- Downloads a portable python-build-standalone distribution (cached in ~/.cache/nib/ ), extracts it, and vendors all dependencies with pip install --target . Copy code -- Copies your script, sibling .py files, local packages, and the assets/ directory into the bundle. Fonts in assets/ are automatically registered. Compile -- Compiles Python to bytecode ( .pyc ), native modules ( .so ), or leaves source as-is depending on flags. Finalize -- Installs the Swift runtime as the main executable, converts the icon to .icns format, and generates Info.plist from your configuration. Cleanup and sign -- Prunes the Python distribution (removes test suites, idle, tkinter, etc.), optionally strips binaries, and applies an ad-hoc code signature.","title":"Build pipeline"},{"location":"cli/build/#bundle-structure","text":"My App . app / \u2514\u2500\u2500 Contents / \u251c\u2500\u2500 Info . plist \u251c\u2500\u2500 MacOS / \u2502 \u2514\u2500\u2500 My App # Swift runtime (main executable) \u2514\u2500\u2500 Resources / \u251c\u2500\u2500 app / \u2502 \u251c\u2500\u2500 main . pyc # Your compiled application code \u2502 \u2514\u2500\u2500 vendor / # Vendored dependencies + nib SDK \u251c\u2500\u2500 assets / # Your assets (icons, images, fonts) \u2514\u2500\u2500 python / # Embedded Python distribution","title":"Bundle structure"},{"location":"cli/build/#examples","text":"Build with defaults from pyproject.toml : nib build Build with a custom name and icon: nib build src/main.py --name \"Weather Widget\" --icon src/assets/icon.png Build with native compilation for maximum code protection: nib build --native Cython required The --native flag requires Cython to be installed: pip install cython Build an optimized, obfuscated release: nib build --obfuscate --optimize Build for a specific architecture: nib build --arch x86_64 Build with additional dependencies that auto-detection missed: nib build --extra-deps \"pillow,scipy\"","title":"Examples"},{"location":"cli/build/#configuration-precedence","text":"When both CLI arguments and pyproject.toml settings are present, CLI arguments take precedence: Command-line arguments (highest priority) [tool.nib.build] section in pyproject.toml Default values See the pyproject.toml configuration reference for all available settings.","title":"Configuration precedence"},{"location":"cli/create/","text":"Scaffold a new Nib project with a standard directory structure, ready to run and build. Usage \u00b6 nib create <name> The name argument accepts spaces, hyphens, or underscores. Nib normalizes it into two forms: Input Display name Directory name my-app My App my_app my_awesome_app My Awesome App my_awesome_app \"Weather Widget\" Weather Widget weather_widget Generated files \u00b6 my_app/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main.py # Application entry point (counter example) \u2502 \u2514\u2500\u2500 assets/ \u2502 \u2514\u2500\u2500 .gitkeep # Placeholder for icons and images \u251c\u2500\u2500 pyproject.toml # Project config with commented build options \u2514\u2500\u2500 README.md # Basic development and build instructions src/main.py \u00b6 A minimal counter application that demonstrates the function-based API: import nib def main ( app : nib . App ): app . title = \"My App\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . menu = [ nib . MenuItem ( \"Quit\" , action = app . quit ), ] counter = nib . Text ( \"0\" ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Hello, My App!\" , font = nib . Font . title ), counter , nib . Button ( \"Click me\" , action = increment ), ], spacing = 16 , padding = 24 , ) ) nib . run ( main ) pyproject.toml \u00b6 Contains project metadata and a [tool.nib] section with all build options commented out. See the pyproject.toml configuration reference for details. src/assets/ \u00b6 Place your app icon ( icon.png or icon.icns ) and other assets here. The build command automatically detects src/assets/icon.png as the default icon. Example output \u00b6 $ nib create my-awesome-app Creating nib project: My Awesome App Created: src/main.py Created: pyproject.toml Created: README.md Created: src/assets/ Project created at: /Users/you/projects/my_awesome_app Next steps: cd my_awesome_app python src/main.py # Run in development nib build # Build standalone app Warning If the target directory already exists, the command exits with an error to avoid overwriting existing files. Next steps \u00b6 After creating your project: cd into the project directory Run nib run to start the app with hot reload Edit src/main.py to build your UI Place an icon at src/assets/icon.png for your app bundle Run nib build when ready to distribute","title":"nib create"},{"location":"cli/create/#usage","text":"nib create <name> The name argument accepts spaces, hyphens, or underscores. Nib normalizes it into two forms: Input Display name Directory name my-app My App my_app my_awesome_app My Awesome App my_awesome_app \"Weather Widget\" Weather Widget weather_widget","title":"Usage"},{"location":"cli/create/#generated-files","text":"my_app/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main.py # Application entry point (counter example) \u2502 \u2514\u2500\u2500 assets/ \u2502 \u2514\u2500\u2500 .gitkeep # Placeholder for icons and images \u251c\u2500\u2500 pyproject.toml # Project config with commented build options \u2514\u2500\u2500 README.md # Basic development and build instructions","title":"Generated files"},{"location":"cli/create/#srcmainpy","text":"A minimal counter application that demonstrates the function-based API: import nib def main ( app : nib . App ): app . title = \"My App\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . menu = [ nib . MenuItem ( \"Quit\" , action = app . quit ), ] counter = nib . Text ( \"0\" ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Hello, My App!\" , font = nib . Font . title ), counter , nib . Button ( \"Click me\" , action = increment ), ], spacing = 16 , padding = 24 , ) ) nib . run ( main )","title":"src/main.py"},{"location":"cli/create/#pyprojecttoml","text":"Contains project metadata and a [tool.nib] section with all build options commented out. See the pyproject.toml configuration reference for details.","title":"pyproject.toml"},{"location":"cli/create/#srcassets","text":"Place your app icon ( icon.png or icon.icns ) and other assets here. The build command automatically detects src/assets/icon.png as the default icon.","title":"src/assets/"},{"location":"cli/create/#example-output","text":"$ nib create my-awesome-app Creating nib project: My Awesome App Created: src/main.py Created: pyproject.toml Created: README.md Created: src/assets/ Project created at: /Users/you/projects/my_awesome_app Next steps: cd my_awesome_app python src/main.py # Run in development nib build # Build standalone app Warning If the target directory already exists, the command exits with an error to avoid overwriting existing files.","title":"Example output"},{"location":"cli/create/#next-steps","text":"After creating your project: cd into the project directory Run nib run to start the app with hot reload Edit src/main.py to build your UI Place an icon at src/assets/icon.png for your app bundle Run nib build when ready to distribute","title":"Next steps"},{"location":"cli/pyproject-config/","text":"Nib reads project settings from the [tool.nib] section of pyproject.toml . This lets you define build defaults so that nib run and nib build work without any flags. Sections overview \u00b6 Section Purpose [tool.nib] Entry point and top-level settings [tool.nib.build] Build configuration (name, icon, version, etc.) [tool.nib.build.plist] Info.plist options (category, dock icon, URL schemes, etc.) [tool.nib.build.plist.usage] Privacy permission descriptions [tool.nib.build.plist.custom] Arbitrary Info.plist keys [[tool.nib.build.plist.document_types]] File type associations [tool.nib] \u00b6 Top-level project settings. Key Type Description entry string Path to the entry point script. Used by nib run and nib build when no script argument is given. Default: src/main.py [tool.nib] entry = \"src/main.py\" [tool.nib.build] \u00b6 Build configuration. All keys are optional -- sensible defaults are used when omitted. Key Type Default Description name string Project name App display name shown in the menu bar and Finder identifier string com.nib.<name> macOS bundle identifier version string 1.0.0 App version string ( CFBundleShortVersionString ) icon string src/assets/icon.png Path to icon file ( .icns or .png -- PNG is auto-converted) min_macos string Current system version Minimum macOS version required to run the app exclude list[string] [] Packages to exclude from the bundle extra_deps list[string] [] Additional pip packages to include if auto-detection misses them launch_at_login bool false Register the app to start automatically at login (requires signed app) arch string Current machine Target architecture: arm64 or x86_64 native bool false Compile Python to native .so via Cython obfuscate bool false Strip debug info from .pyc bytecode optimize bool false Optimize bundle size (strip binaries, prune stdlib) [tool.nib.build] name = \"Weather Widget\" identifier = \"com.example.weatherwidget\" version = \"2.1.0\" icon = \"src/assets/icon.png\" min_macos = \"14.0\" extra_deps = [ \"requests\" , \"pillow\" ] launch_at_login = true Dependency detection If your pyproject.toml has a [project].dependencies list, Nib uses those packages directly instead of auto-detecting imports via AST analysis. The nib package itself is automatically excluded. [tool.nib.build.plist] \u00b6 Controls values written to the app's Info.plist . These affect how macOS treats your application. Key Type Default Description copyright string -- Human-readable copyright string category string -- App Store category (e.g., public.app-category.utilities ) notification_style string -- Notification display style: banner , alert , or none dock_icon bool false Show the app in the Dock (default: menu bar only) background_only bool false Run as a background daemon with no UI build_number string Same as version Internal build number ( CFBundleVersion ), separate from the display version allow_http bool or list[string] false Allow insecure HTTP connections. true allows all domains; a list allows specific domains only url_schemes list[string] -- Register custom URL schemes (e.g., [\"myapp\"] for myapp:// ) [tool.nib.build.plist] copyright = \"Copyright 2025 Your Name\" category = \"public.app-category.utilities\" notification_style = \"banner\" dock_icon = false build_number = \"42\" url_schemes = [ \"myapp\" ] allow_http \u00b6 By default, macOS enforces App Transport Security (HTTPS only). You can relax this globally or per-domain: # Allow HTTP to all domains allow_http = true # Allow HTTP to specific domains only allow_http = [ \"api.example.com\" , \"cdn.example.com\" ] Document type associations \u00b6 Register your app as a handler for specific file types using TOML array-of-tables syntax. Key Type Description name string Display name for the document type extensions list[string] File extensions to associate (without the dot) role string Viewer or Editor [[tool.nib.build.plist.document_types]] name = \"Text Document\" extensions = [ \"txt\" , \"md\" ] role = \"Viewer\" [[tool.nib.build.plist.document_types]] name = \"JSON File\" extensions = [ \"json\" ] role = \"Editor\" [tool.nib.build.plist.usage] \u00b6 Privacy permission descriptions. macOS requires a usage string for each protected resource your app accesses. If the user's code references Permission.CAMERA or Permission.MICROPHONE , Nib auto-detects them with generic descriptions -- but you should provide your own. Key Plist key Description camera NSCameraUsageDescription Camera access microphone NSMicrophoneUsageDescription Microphone access location NSLocationUsageDescription Location services apple_events NSAppleEventsUsageDescription Controlling other apps via Apple Events contacts NSContactsUsageDescription Contacts database photos NSPhotoLibraryUsageDescription Photo library calendars NSCalendarsUsageDescription Calendar data reminders NSRemindersUsageDescription Reminders bluetooth NSBluetoothAlwaysUsageDescription Bluetooth speech_recognition NSSpeechRecognitionUsageDescription Speech recognition desktop_folder NSDesktopFolderUsageDescription Desktop folder downloads_folder NSDownloadsFolderUsageDescription Downloads folder network_volumes NSNetworkVolumesUsageDescription Network volumes removable_volumes NSRemovableVolumesUsageDescription Removable volumes accessibility NSAccessibilityUsageDescription Accessibility features [tool.nib.build.plist.usage] camera = \"This app uses the camera for video preview.\" microphone = \"This app uses the microphone for voice commands.\" location = \"This app uses your location to show local weather.\" [tool.nib.build.plist.custom] \u00b6 An escape hatch for arbitrary Info.plist keys. Values in this section are merged last and can override anything set by other options. [tool.nib.build.plist.custom] NSSupportsAutomaticTermination = true NSSupportsSuddenTermination = true MyCustomKey = \"custom value\" Complete example \u00b6 A fully annotated pyproject.toml with all available options: [project] name = \"weather-widget\" version = \"2.1.0\" description = \"A macOS menu bar weather app\" requires-python = \">=3.10\" dependencies = [ \"requests\" , \"pillow\" , ] [tool.nib] # Entry point script -- used by `nib run` and `nib build` entry = \"src/main.py\" [tool.nib.build] # App display name name = \"Weather Widget\" # Bundle identifier identifier = \"com.example.weatherwidget\" # App version (overrides [project].version for the bundle) version = \"2.1.0\" # Icon file (.icns or .png -- PNG is auto-converted) icon = \"src/assets/icon.png\" # Minimum macOS version min_macos = \"14.0\" # Packages to exclude from bundling exclude = [] # Additional dependencies if auto-detection misses them extra_deps = [] # Start at login (requires signed app) launch_at_login = false [tool.nib.build.plist] copyright = \"Copyright 2025 Jane Developer\" category = \"public.app-category.weather\" notification_style = \"banner\" dock_icon = false background_only = false build_number = \"42\" allow_http = [ \"api.weather.com\" ] url_schemes = [ \"weather-widget\" ] # File type associations [[tool.nib.build.plist.document_types]] name = \"Weather Data\" extensions = [ \"weather\" , \"json\" ] role = \"Viewer\" # Privacy descriptions [tool.nib.build.plist.usage] location = \"Weather Widget uses your location to show local forecasts.\" camera = \"Weather Widget uses the camera for sky condition detection.\" # Custom plist keys (escape hatch) [tool.nib.build.plist.custom] NSSupportsAutomaticTermination = true","title":"pyproject.toml Config"},{"location":"cli/pyproject-config/#sections-overview","text":"Section Purpose [tool.nib] Entry point and top-level settings [tool.nib.build] Build configuration (name, icon, version, etc.) [tool.nib.build.plist] Info.plist options (category, dock icon, URL schemes, etc.) [tool.nib.build.plist.usage] Privacy permission descriptions [tool.nib.build.plist.custom] Arbitrary Info.plist keys [[tool.nib.build.plist.document_types]] File type associations","title":"Sections overview"},{"location":"cli/pyproject-config/#toolnib","text":"Top-level project settings. Key Type Description entry string Path to the entry point script. Used by nib run and nib build when no script argument is given. Default: src/main.py [tool.nib] entry = \"src/main.py\"","title":"[tool.nib]"},{"location":"cli/pyproject-config/#toolnibbuild","text":"Build configuration. All keys are optional -- sensible defaults are used when omitted. Key Type Default Description name string Project name App display name shown in the menu bar and Finder identifier string com.nib.<name> macOS bundle identifier version string 1.0.0 App version string ( CFBundleShortVersionString ) icon string src/assets/icon.png Path to icon file ( .icns or .png -- PNG is auto-converted) min_macos string Current system version Minimum macOS version required to run the app exclude list[string] [] Packages to exclude from the bundle extra_deps list[string] [] Additional pip packages to include if auto-detection misses them launch_at_login bool false Register the app to start automatically at login (requires signed app) arch string Current machine Target architecture: arm64 or x86_64 native bool false Compile Python to native .so via Cython obfuscate bool false Strip debug info from .pyc bytecode optimize bool false Optimize bundle size (strip binaries, prune stdlib) [tool.nib.build] name = \"Weather Widget\" identifier = \"com.example.weatherwidget\" version = \"2.1.0\" icon = \"src/assets/icon.png\" min_macos = \"14.0\" extra_deps = [ \"requests\" , \"pillow\" ] launch_at_login = true Dependency detection If your pyproject.toml has a [project].dependencies list, Nib uses those packages directly instead of auto-detecting imports via AST analysis. The nib package itself is automatically excluded.","title":"[tool.nib.build]"},{"location":"cli/pyproject-config/#toolnibbuildplist","text":"Controls values written to the app's Info.plist . These affect how macOS treats your application. Key Type Default Description copyright string -- Human-readable copyright string category string -- App Store category (e.g., public.app-category.utilities ) notification_style string -- Notification display style: banner , alert , or none dock_icon bool false Show the app in the Dock (default: menu bar only) background_only bool false Run as a background daemon with no UI build_number string Same as version Internal build number ( CFBundleVersion ), separate from the display version allow_http bool or list[string] false Allow insecure HTTP connections. true allows all domains; a list allows specific domains only url_schemes list[string] -- Register custom URL schemes (e.g., [\"myapp\"] for myapp:// ) [tool.nib.build.plist] copyright = \"Copyright 2025 Your Name\" category = \"public.app-category.utilities\" notification_style = \"banner\" dock_icon = false build_number = \"42\" url_schemes = [ \"myapp\" ]","title":"[tool.nib.build.plist]"},{"location":"cli/pyproject-config/#allow_http","text":"By default, macOS enforces App Transport Security (HTTPS only). You can relax this globally or per-domain: # Allow HTTP to all domains allow_http = true # Allow HTTP to specific domains only allow_http = [ \"api.example.com\" , \"cdn.example.com\" ]","title":"allow_http"},{"location":"cli/pyproject-config/#document-type-associations","text":"Register your app as a handler for specific file types using TOML array-of-tables syntax. Key Type Description name string Display name for the document type extensions list[string] File extensions to associate (without the dot) role string Viewer or Editor [[tool.nib.build.plist.document_types]] name = \"Text Document\" extensions = [ \"txt\" , \"md\" ] role = \"Viewer\" [[tool.nib.build.plist.document_types]] name = \"JSON File\" extensions = [ \"json\" ] role = \"Editor\"","title":"Document type associations"},{"location":"cli/pyproject-config/#toolnibbuildplistusage","text":"Privacy permission descriptions. macOS requires a usage string for each protected resource your app accesses. If the user's code references Permission.CAMERA or Permission.MICROPHONE , Nib auto-detects them with generic descriptions -- but you should provide your own. Key Plist key Description camera NSCameraUsageDescription Camera access microphone NSMicrophoneUsageDescription Microphone access location NSLocationUsageDescription Location services apple_events NSAppleEventsUsageDescription Controlling other apps via Apple Events contacts NSContactsUsageDescription Contacts database photos NSPhotoLibraryUsageDescription Photo library calendars NSCalendarsUsageDescription Calendar data reminders NSRemindersUsageDescription Reminders bluetooth NSBluetoothAlwaysUsageDescription Bluetooth speech_recognition NSSpeechRecognitionUsageDescription Speech recognition desktop_folder NSDesktopFolderUsageDescription Desktop folder downloads_folder NSDownloadsFolderUsageDescription Downloads folder network_volumes NSNetworkVolumesUsageDescription Network volumes removable_volumes NSRemovableVolumesUsageDescription Removable volumes accessibility NSAccessibilityUsageDescription Accessibility features [tool.nib.build.plist.usage] camera = \"This app uses the camera for video preview.\" microphone = \"This app uses the microphone for voice commands.\" location = \"This app uses your location to show local weather.\"","title":"[tool.nib.build.plist.usage]"},{"location":"cli/pyproject-config/#toolnibbuildplistcustom","text":"An escape hatch for arbitrary Info.plist keys. Values in this section are merged last and can override anything set by other options. [tool.nib.build.plist.custom] NSSupportsAutomaticTermination = true NSSupportsSuddenTermination = true MyCustomKey = \"custom value\"","title":"[tool.nib.build.plist.custom]"},{"location":"cli/pyproject-config/#complete-example","text":"A fully annotated pyproject.toml with all available options: [project] name = \"weather-widget\" version = \"2.1.0\" description = \"A macOS menu bar weather app\" requires-python = \">=3.10\" dependencies = [ \"requests\" , \"pillow\" , ] [tool.nib] # Entry point script -- used by `nib run` and `nib build` entry = \"src/main.py\" [tool.nib.build] # App display name name = \"Weather Widget\" # Bundle identifier identifier = \"com.example.weatherwidget\" # App version (overrides [project].version for the bundle) version = \"2.1.0\" # Icon file (.icns or .png -- PNG is auto-converted) icon = \"src/assets/icon.png\" # Minimum macOS version min_macos = \"14.0\" # Packages to exclude from bundling exclude = [] # Additional dependencies if auto-detection misses them extra_deps = [] # Start at login (requires signed app) launch_at_login = false [tool.nib.build.plist] copyright = \"Copyright 2025 Jane Developer\" category = \"public.app-category.weather\" notification_style = \"banner\" dock_icon = false background_only = false build_number = \"42\" allow_http = [ \"api.weather.com\" ] url_schemes = [ \"weather-widget\" ] # File type associations [[tool.nib.build.plist.document_types]] name = \"Weather Data\" extensions = [ \"weather\" , \"json\" ] role = \"Viewer\" # Privacy descriptions [tool.nib.build.plist.usage] location = \"Weather Widget uses your location to show local forecasts.\" camera = \"Weather Widget uses the camera for sky condition detection.\" # Custom plist keys (escape hatch) [tool.nib.build.plist.custom] NSSupportsAutomaticTermination = true","title":"Complete example"},{"location":"cli/run/","text":"Run a Nib application in development mode with automatic hot reload on file changes. Usage \u00b6 nib run [ script.py ] [ -r ] [ -v ] If no script is specified, nib run reads the entry point from pyproject.toml : nib run # Uses [tool.nib] entry (defaults to src/main.py) nib run src/main.py # Explicit script path nib run my_project/ # Runs my_project/src/main.py (enables recursive watching) Options \u00b6 Flag Description -r , --recursive Watch subdirectories for changes -v , --verbose Enable verbose output (show info-level logs) How it works \u00b6 When you run nib run , the following happens: The Swift runtime ( nib-runtime ) is launched as a separate process A Unix socket connection is established between Python and Swift Your Python script is executed and the UI is rendered A file watcher monitors .py files for changes On every file save, only the Python side restarts -- the Swift runtime stays alive. This means the menu bar icon persists and UI updates are near-instant. Save file --> Python reloads --> new UI sent to Swift runtime ( still running ) Hot reload \u00b6 The watcher triggers a reload whenever a .py file is modified. The reload process: Clears cached user modules from sys.modules Re-executes your script from scratch Sends the updated view tree to the Swift runtime Debouncing Rapid saves are coalesced with a 100ms debounce window. If you save multiple times in quick succession, only one reload is triggered. Excluded directories \u00b6 The watcher ignores changes in these directories: __pycache__ .git .venv , venv node_modules .mypy_cache , .pytest_cache , .ruff_cache dist , build .eggs Recursive watching \u00b6 By default, only the script's parent directory is watched (non-recursively). Use -r to watch all subdirectories: nib run src/main.py -r # Watches src/ and all its subdirectories When you pass a directory instead of a script, recursive watching is enabled automatically: nib run my_project/ # Equivalent to: nib run my_project/src/main.py -r Error handling \u00b6 Syntax errors and runtime exceptions are displayed in the terminal. The Swift runtime keeps running, so you can fix the error and save to trigger another reload. $ nib run File changed : main . py Reloading ... Syntax error in / path / to / main . py : 12 if True ^ expected ':' Fix the error and save to reload ... No need to restart -- just fix the problem and save. Stopping \u00b6 Press Ctrl+C to stop both the Python process and the Swift runtime. The Unix socket is cleaned up automatically.","title":"nib run"},{"location":"cli/run/#usage","text":"nib run [ script.py ] [ -r ] [ -v ] If no script is specified, nib run reads the entry point from pyproject.toml : nib run # Uses [tool.nib] entry (defaults to src/main.py) nib run src/main.py # Explicit script path nib run my_project/ # Runs my_project/src/main.py (enables recursive watching)","title":"Usage"},{"location":"cli/run/#options","text":"Flag Description -r , --recursive Watch subdirectories for changes -v , --verbose Enable verbose output (show info-level logs)","title":"Options"},{"location":"cli/run/#how-it-works","text":"When you run nib run , the following happens: The Swift runtime ( nib-runtime ) is launched as a separate process A Unix socket connection is established between Python and Swift Your Python script is executed and the UI is rendered A file watcher monitors .py files for changes On every file save, only the Python side restarts -- the Swift runtime stays alive. This means the menu bar icon persists and UI updates are near-instant. Save file --> Python reloads --> new UI sent to Swift runtime ( still running )","title":"How it works"},{"location":"cli/run/#hot-reload","text":"The watcher triggers a reload whenever a .py file is modified. The reload process: Clears cached user modules from sys.modules Re-executes your script from scratch Sends the updated view tree to the Swift runtime Debouncing Rapid saves are coalesced with a 100ms debounce window. If you save multiple times in quick succession, only one reload is triggered.","title":"Hot reload"},{"location":"cli/run/#excluded-directories","text":"The watcher ignores changes in these directories: __pycache__ .git .venv , venv node_modules .mypy_cache , .pytest_cache , .ruff_cache dist , build .eggs","title":"Excluded directories"},{"location":"cli/run/#recursive-watching","text":"By default, only the script's parent directory is watched (non-recursively). Use -r to watch all subdirectories: nib run src/main.py -r # Watches src/ and all its subdirectories When you pass a directory instead of a script, recursive watching is enabled automatically: nib run my_project/ # Equivalent to: nib run my_project/src/main.py -r","title":"Recursive watching"},{"location":"cli/run/#error-handling","text":"Syntax errors and runtime exceptions are displayed in the terminal. The Swift runtime keeps running, so you can fix the error and save to trigger another reload. $ nib run File changed : main . py Reloading ... Syntax error in / path / to / main . py : 12 if True ^ expected ':' Fix the error and save to reload ... No need to restart -- just fix the problem and save.","title":"Error handling"},{"location":"cli/run/#stopping","text":"Press Ctrl+C to stop both the Python process and the Swift runtime. The Unix socket is cleaned up automatically.","title":"Stopping"},{"location":"concepts/","text":"This section covers the core ideas behind Nib: how it works, how your code turns into a native macOS interface, and how you interact with it. Nib runs two processes connected by a Unix socket. Python owns the logic. Swift owns the screen. Understanding this boundary -- and how data flows across it -- is the key to building effective Nib apps. Architecture -- The two-process model, message types, and data flow. Reactivity -- How property mutations trigger UI updates. View Tree -- How views are structured, serialized, and identified. Modifiers -- Styling views through constructor parameters. Event Handling -- How user interactions flow from Swift to Python.","title":"Index"},{"location":"concepts/architecture/","text":"Nib is a two-process system. Python owns the logic. Swift owns the screen. They talk over a Unix socket using MessagePack. The Two-Process Model \u00b6 Every Nib application runs as two cooperating processes: Python process -- your code. It owns the app logic, the view tree, state management, and event handling. When something changes, Python computes the new UI and sends it across the socket. Swift process -- the runtime. It owns native macOS rendering via SwiftUI, system APIs (notifications, clipboard, file dialogs, keychain), and the menu bar icon. It receives view descriptions from Python, renders them natively, and sends user interactions back. Neither process directly accesses the other's memory. All communication happens through serialized messages over a Unix domain socket. Communication Protocol \u00b6 Messages are sent as length-prefixed MessagePack payloads. Each message has a 4-byte big-endian length header followed by the packed data. [ 4 bytes : length ][ MessagePack payload ] Python and Swift exchange three categories of messages: render -- Full View Tree \u00b6 Sent from Python to Swift. Contains the complete view tree as a flat node list, along with app configuration (icon, title, window size, menu items, hotkeys, fonts). This is sent on every update. Python re-serializes the entire view tree and sends it to Swift, which replaces the current UI. # Internal structure (you don't build this manually) { \"type\" : \"flatRender\" , \"payload\" : { \"nodes\" : [ ... ], # Flat list of view nodes \"rootId\" : \"0\" , # ID of the root node \"statusBar\" : { \"icon\" : \"star.fill\" , \"title\" : \"My App\" }, \"window\" : { \"width\" : 300.0 , \"height\" : 400.0 }, \"menu\" : [ ... ], # Right-click menu items \"hotkeys\" : [ \"cmd+k\" ], # Global keyboard shortcuts \"fonts\" : { ... } # Custom font paths } } patch -- Incremental Updates \u00b6 Defined in the protocol but currently unused. Nib sends full renders on every update instead of computing incremental patches. The diff engine exists ( diff.py ) but full renders proved more reliable for the Swift-side view reconciliation. event -- User Interactions \u00b6 Sent from Swift to Python. Carries a node ID and an event string describing what happened. # Internal structure { \"type\" : \"event\" , \"nodeId\" : \"0.1.0\" , # Which view triggered the event \"event\" : \"tap\" # What happened } Event string formats: Event Format Example Button tap tap tap Value change change:<value> change:hello Submit submit:<value> submit:search query Drop files drop:<paths> drop:/path/to/file.txt Hover hover:<bool> hover:true Click click click Canvas pan pan:<type>:<x>,<y> pan:update:150.0,200.0 Hotkey hotkey:<shortcut> hotkey:cmd+shift+n Lifecycle appear / disappear appear Execution Modes \u00b6 Development Mode ( nib run ) \u00b6 Python is the parent process. It launches the Swift runtime as a subprocess, passing the socket path via environment variable. Python ( parent ) | +-- Spawns Swift runtime subprocess | +-- Creates Unix socket at / tmp / nib -< pid > . sock | +-- Connects and starts message loop In this mode, nib run also watches your Python files for changes and restarts the app automatically (hot reload). Bundled Mode (standalone .app ) \u00b6 Swift is the parent process. The .app bundle contains both the Swift runtime and your Python code. When launched, Swift starts and spawns Python as a child process. Swift Runtime ( parent , inside . app bundle ) | +-- Creates Unix socket | +-- Spawns Python with NIB_SOCKET env var | +-- Python connects to the provided socket The NIB_SOCKET environment variable tells Python it is running in bundled mode and where to find the socket. Same protocol, different launcher The message protocol is identical in both modes. The only difference is which process starts first and who creates the socket. Your Python code does not need to change between development and production. Data Flow: From Property Change to Pixel \u00b6 Here is the complete path when you mutate a view property: 1. Python : text . cont ent = \"new value\" | 2. View . __setattr__ detects change , calls app . _trigger_rerender () | 3. App sets _render_requested event ( threading . Event ) | 4. Render loop thread wakes up , calls _render () | 5. App calls body () to get the root view | 6. App calls _collect_actions () to assign IDs and register callbacks | 7. Root view serialized to flat node list via to _flat_list () | 8. Connection . send_flat_render () packs with MessagePack , sends over socket | 9. Swift SocketServer read s len gth - prefixed message , unpacks | 10. Swift AppDelegate routes to ViewStore | 11. SwiftUI observes ViewStore change , re - renders affected views | 12. Native macOS pixels update on screen Coalesced rendering Multiple rapid property changes are coalesced into a single render. The render loop uses a threading Event that is set on any change and cleared when a render begins. This means if you change three properties in quick succession, only one render happens. The render loop is throttled to approximately 500 frames per second maximum. Other Message Types \u00b6 Beyond the core three, Python sends additional message types for system integration: Message Type Direction Purpose quit Python to Swift Terminate the runtime notify Python to Swift Show a macOS notification clipboard Python to Swift Read/write the system clipboard fileDialog Python to Swift Open/save file picker dialogs userDefaults Python to Swift Persist settings via UserDefaults service Python to Swift Query system services (battery, screen, etc.) action Python to Swift Trigger view-specific actions (WebView reload, etc.) settingsRender Python to Swift Send settings window UI notification Python to Swift Push/schedule/cancel notifications serviceResponse Swift to Python System service query results notificationResponse Swift to Python Notification action responses fileDialogResponse Swift to Python File dialog selections","title":"Architecture"},{"location":"concepts/architecture/#the-two-process-model","text":"Every Nib application runs as two cooperating processes: Python process -- your code. It owns the app logic, the view tree, state management, and event handling. When something changes, Python computes the new UI and sends it across the socket. Swift process -- the runtime. It owns native macOS rendering via SwiftUI, system APIs (notifications, clipboard, file dialogs, keychain), and the menu bar icon. It receives view descriptions from Python, renders them natively, and sends user interactions back. Neither process directly accesses the other's memory. All communication happens through serialized messages over a Unix domain socket.","title":"The Two-Process Model"},{"location":"concepts/architecture/#communication-protocol","text":"Messages are sent as length-prefixed MessagePack payloads. Each message has a 4-byte big-endian length header followed by the packed data. [ 4 bytes : length ][ MessagePack payload ] Python and Swift exchange three categories of messages:","title":"Communication Protocol"},{"location":"concepts/architecture/#render-full-view-tree","text":"Sent from Python to Swift. Contains the complete view tree as a flat node list, along with app configuration (icon, title, window size, menu items, hotkeys, fonts). This is sent on every update. Python re-serializes the entire view tree and sends it to Swift, which replaces the current UI. # Internal structure (you don't build this manually) { \"type\" : \"flatRender\" , \"payload\" : { \"nodes\" : [ ... ], # Flat list of view nodes \"rootId\" : \"0\" , # ID of the root node \"statusBar\" : { \"icon\" : \"star.fill\" , \"title\" : \"My App\" }, \"window\" : { \"width\" : 300.0 , \"height\" : 400.0 }, \"menu\" : [ ... ], # Right-click menu items \"hotkeys\" : [ \"cmd+k\" ], # Global keyboard shortcuts \"fonts\" : { ... } # Custom font paths } }","title":"render -- Full View Tree"},{"location":"concepts/architecture/#patch-incremental-updates","text":"Defined in the protocol but currently unused. Nib sends full renders on every update instead of computing incremental patches. The diff engine exists ( diff.py ) but full renders proved more reliable for the Swift-side view reconciliation.","title":"patch -- Incremental Updates"},{"location":"concepts/architecture/#event-user-interactions","text":"Sent from Swift to Python. Carries a node ID and an event string describing what happened. # Internal structure { \"type\" : \"event\" , \"nodeId\" : \"0.1.0\" , # Which view triggered the event \"event\" : \"tap\" # What happened } Event string formats: Event Format Example Button tap tap tap Value change change:<value> change:hello Submit submit:<value> submit:search query Drop files drop:<paths> drop:/path/to/file.txt Hover hover:<bool> hover:true Click click click Canvas pan pan:<type>:<x>,<y> pan:update:150.0,200.0 Hotkey hotkey:<shortcut> hotkey:cmd+shift+n Lifecycle appear / disappear appear","title":"event -- User Interactions"},{"location":"concepts/architecture/#execution-modes","text":"","title":"Execution Modes"},{"location":"concepts/architecture/#development-mode-nib-run","text":"Python is the parent process. It launches the Swift runtime as a subprocess, passing the socket path via environment variable. Python ( parent ) | +-- Spawns Swift runtime subprocess | +-- Creates Unix socket at / tmp / nib -< pid > . sock | +-- Connects and starts message loop In this mode, nib run also watches your Python files for changes and restarts the app automatically (hot reload).","title":"Development Mode (nib run)"},{"location":"concepts/architecture/#bundled-mode-standalone-app","text":"Swift is the parent process. The .app bundle contains both the Swift runtime and your Python code. When launched, Swift starts and spawns Python as a child process. Swift Runtime ( parent , inside . app bundle ) | +-- Creates Unix socket | +-- Spawns Python with NIB_SOCKET env var | +-- Python connects to the provided socket The NIB_SOCKET environment variable tells Python it is running in bundled mode and where to find the socket. Same protocol, different launcher The message protocol is identical in both modes. The only difference is which process starts first and who creates the socket. Your Python code does not need to change between development and production.","title":"Bundled Mode (standalone .app)"},{"location":"concepts/architecture/#data-flow-from-property-change-to-pixel","text":"Here is the complete path when you mutate a view property: 1. Python : text . cont ent = \"new value\" | 2. View . __setattr__ detects change , calls app . _trigger_rerender () | 3. App sets _render_requested event ( threading . Event ) | 4. Render loop thread wakes up , calls _render () | 5. App calls body () to get the root view | 6. App calls _collect_actions () to assign IDs and register callbacks | 7. Root view serialized to flat node list via to _flat_list () | 8. Connection . send_flat_render () packs with MessagePack , sends over socket | 9. Swift SocketServer read s len gth - prefixed message , unpacks | 10. Swift AppDelegate routes to ViewStore | 11. SwiftUI observes ViewStore change , re - renders affected views | 12. Native macOS pixels update on screen Coalesced rendering Multiple rapid property changes are coalesced into a single render. The render loop uses a threading Event that is set on any change and cleared when a render begins. This means if you change three properties in quick succession, only one render happens. The render loop is throttled to approximately 500 frames per second maximum.","title":"Data Flow: From Property Change to Pixel"},{"location":"concepts/architecture/#other-message-types","text":"Beyond the core three, Python sends additional message types for system integration: Message Type Direction Purpose quit Python to Swift Terminate the runtime notify Python to Swift Show a macOS notification clipboard Python to Swift Read/write the system clipboard fileDialog Python to Swift Open/save file picker dialogs userDefaults Python to Swift Persist settings via UserDefaults service Python to Swift Query system services (battery, screen, etc.) action Python to Swift Trigger view-specific actions (WebView reload, etc.) settingsRender Python to Swift Send settings window UI notification Python to Swift Push/schedule/cancel notifications serviceResponse Swift to Python System service query results notificationResponse Swift to Python Notification action responses fileDialogResponse Swift to Python File dialog selections","title":"Other Message Types"},{"location":"concepts/event-handling/","text":"Events flow from Swift to Python over the Unix socket. When a user taps a button, types in a text field, or drops a file, Swift sends an event message containing the view's node ID and the event data. Python looks up the registered callback and calls it. How Events Work \u00b6 You register a callback when creating a view (e.g., action= on a Button, on_change= on a TextField). During each render, App._collect_actions() walks the view tree and builds maps from node IDs to callback functions. When the user interacts with the view, Swift sends an event message with the node ID and event string. Python's event handler looks up the callback in the appropriate map and calls it. Events are dispatched sequentially on a dedicated event thread. This prevents concurrent callback execution, so you do not need locks when modifying view properties inside event handlers. Button Actions \u00b6 Buttons use the action= parameter. The callback receives no arguments. import nib def main ( app : nib . App ): count = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): count . content = str ( int ( count . content ) + 1 ) def reset (): count . content = \"0\" app . build ( nib . VStack ( controls = [ count , nib . HStack ( controls = [ nib . Button ( \"Add\" , action = increment ), nib . Button ( \"Reset\" , action = reset ), ], spacing = 8 , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Callback signature Button action callbacks take no arguments: def handler(): . The button does not pass any value -- it simply signals that it was tapped. Text Field Changes \u00b6 TextField and SecureField use on_change= for value changes and on_submit= for the Return/Enter key. Both receive the current text value as a string. search_field = nib . TextField ( placeholder = \"Search...\" , value = \"\" , on_change = handle_search , on_submit = submit_search , style = nib . TextFieldStyle . roundedBorder , ) def handle_search ( value : str ): # Called on every keystroke print ( f \"Searching: { value } \" ) def submit_search ( value : str ): # Called when user presses Return/Enter print ( f \"Submitted: { value } \" ) Secure fields work the same way: password_field = nib . SecureField ( placeholder = \"Password\" , value = \"\" , on_change = lambda pw : validate_password ( pw ), on_submit = lambda pw : login ( pw ), ) TextEditor Changes \u00b6 TextEditor provides multi-line text input with on_change= : notes = nib . TextEditor ( text = \"\" , placeholder = \"Enter your notes...\" , on_change = handle_notes_change , ) def handle_notes_change ( text : str ): # Called when the text content changes word_count . content = f \" { len ( text . split ()) } words\" Toggle Changes \u00b6 Toggle uses on_change= and passes a boolean indicating the new state. dark_mode = nib . Toggle ( \"Dark Mode\" , is_on = False , on_change = handle_dark_mode , ) def handle_dark_mode ( is_on : bool ): if is_on : container . background = \"#1a1a1a\" label . foreground_color = \"#ffffff\" else : container . background = \"#ffffff\" label . foreground_color = \"#000000\" Slider Changes \u00b6 Slider uses on_change= and passes the new float value. The callback is called continuously while dragging. volume_label = nib . Text ( \"Volume: 50%\" ) volume_slider = nib . Slider ( value = 50 , min_value = 0 , max_value = 100 , step = 1 , on_change = handle_volume , ) def handle_volume ( value : float ): volume_label . content = f \"Volume: { int ( value ) } %\" Picker Changes \u00b6 Picker uses on_change= and passes the selected value as a string. nib . Picker ( \"Theme\" , selection = \"system\" , options = [ ( \"light\" , \"Light\" ), ( \"dark\" , \"Dark\" ), ( \"system\" , \"System\" ), ], on_change = handle_theme , style = nib . PickerStyle . segmented , ) def handle_theme ( value : str ): print ( f \"Selected theme: { value } \" ) # \"light\", \"dark\", or \"system\" Lifecycle Events \u00b6 The app provides lifecycle callbacks for the popover window and app termination. def main ( app : nib . App ): app . on_appear = on_open app . on_disappear = on_close app . on_quit = on_quit # ... def on_open (): # Called every time the popover opens (user clicks menu bar icon) print ( \"Popover opened\" ) refresh_data () def on_close (): # Called every time the popover closes print ( \"Popover closed\" ) pause_updates () def on_quit (): # Called once when the app is shutting down print ( \"App quitting\" ) save_state () close_connections () Event When it fires Frequency on_appear Popover opens Every open on_disappear Popover closes Every close on_quit App is shutting down Once Drag and Drop \u00b6 Any container view can accept dropped files via on_drop= . The callback receives a list of file path strings. drop_zone = nib . VStack ( controls = [ nib . SFSymbol ( \"arrow.down.doc\" , font = nib . Font . TITLE ), nib . Text ( \"Drop files here\" ), ], spacing = 8 , padding = 24 , border_color = \"#666666\" , border_width = 1 , corner_radius = 8 , on_drop = handle_drop , ) def handle_drop ( paths : list [ str ]): for path in paths : print ( f \"Received: { path } \" ) status . content = f \"Dropped { len ( paths ) } file(s)\" Hover Events \u00b6 Any view can detect mouse hover via on_hover= . The callback receives a boolean -- True when the mouse enters, False when it exits. card = nib . VStack ( controls = [ nib . Text ( \"Hover me\" )], padding = 16 , background = \"#333333\" , corner_radius = 8 , on_hover = handle_hover , animation = nib . Animation . EASE_IN_OUT , ) def handle_hover ( is_hovering : bool ): if is_hovering : card . background = \"#444444\" card . scale = 1.02 else : card . background = \"#333333\" card . scale = 1.0 Click Events \u00b6 Any view can respond to clicks via on_click= . The callback receives no arguments. nib . VStack ( controls = [ nib . SFSymbol ( \"checkmark.circle\" ), nib . Text ( \"Click to select\" ), ], spacing = 4 , padding = 12 , on_click = lambda : print ( \"Selected!\" ), ) Canvas Gestures \u00b6 The Canvas view supports gesture tracking for drawing and interactive graphics. Enable gestures with enable_gestures=True or by setting any gesture callback. Gesture callbacks receive a PanEvent with x and y coordinates in the canvas coordinate space. import nib def main ( app : nib . App ): canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#1a1a1a\" ) last_pos = None def on_pan_start ( e : nib . PanEvent ): nonlocal last_pos last_pos = ( e . x , e . y ) def on_pan_update ( e : nib . PanEvent ): nonlocal last_pos if last_pos : canvas . append ( nib . draw . Line ( x1 = last_pos [ 0 ], y1 = last_pos [ 1 ], x2 = e . x , y2 = e . y , stroke = \"#ffffff\" , stroke_width = 3 , )) last_pos = ( e . x , e . y ) def on_pan_end ( e : nib . PanEvent ): nonlocal last_pos last_pos = None def on_hover ( e : nib . PanEvent ): # Mouse is moving over canvas (not dragging) coords . content = f \"( { e . x : .0f } , { e . y : .0f } )\" canvas . on_pan_start = on_pan_start canvas . on_pan_update = on_pan_update canvas . on_pan_end = on_pan_end canvas . on_hover = on_hover coords = nib . Text ( \"(0, 0)\" , font = nib . Font . CAPTION ) app . build ( nib . VStack ( controls = [ canvas , coords ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Callback When it fires Argument on_pan_start Mouse/pen pressed down PanEvent(x, y) on_pan_update Mouse/pen dragged PanEvent(x, y) on_pan_end Mouse/pen released PanEvent(x, y) on_hover Mouse moves (not dragging) PanEvent(x, y) Canvas hover vs view hover Canvas on_hover receives a PanEvent with x/y coordinates. View on_hover (on any other view) receives a bool indicating whether the mouse entered or exited. They share the same parameter name but have different callback signatures depending on the view type. Hotkeys \u00b6 Register global keyboard shortcuts that work even when the app window is not focused. def main ( app : nib . App ): app . on_hotkey ( \"cmd+shift+n\" , show_new_dialog ) app . on_hotkey ( \"cmd+k\" , toggle_search ) # Decorator syntax @app . hotkey ( \"cmd+shift+p\" ) def open_command_palette (): print ( \"Command palette opened\" ) Hotkey strings use modifier names joined with + : cmd , shift , opt (or alt ), ctrl , plus a key name. Context Menu Events \u00b6 Right-click menu items use the action= parameter, same as buttons. app . menu = [ nib . MenuItem ( \"Settings\" , action = open_settings , icon = \"gear\" , shortcut = \"cmd+,\" ), nib . MenuItem ( \"Check for Updates\" , action = check_updates , icon = \"arrow.clockwise\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] def open_settings (): print ( \"Opening settings\" ) def check_updates (): print ( \"Checking for updates\" ) Callback Signatures Summary \u00b6 View / Feature Parameter Callback Signature Button action= def handler(): TextField on_change= def handler(value: str): TextField on_submit= def handler(value: str): SecureField on_change= def handler(value: str): SecureField on_submit= def handler(value: str): TextEditor on_change= def handler(text: str): Toggle on_change= def handler(is_on: bool): Slider on_change= def handler(value: float): Picker on_change= def handler(value: str): App on_appear= def handler(): App on_disappear= def handler(): App on_quit= def handler(): Any view on_drop= def handler(paths: list[str]): Any view on_hover= def handler(is_hovering: bool): Any view on_click= def handler(): Canvas on_pan_start= def handler(e: PanEvent): Canvas on_pan_update= def handler(e: PanEvent): Canvas on_pan_end= def handler(e: PanEvent): Canvas on_hover= def handler(e: PanEvent): MenuItem action= def handler(): App.on_hotkey callback def handler(): Event Threading \u00b6 All event callbacks run on a single dedicated event thread. This means: Callbacks never run concurrently with each other. You can safely mutate view properties in callbacks without locks. Long-running callbacks block subsequent events from being processed. Avoid blocking the event thread If a callback needs to do heavy work (network requests, file I/O, computation), run it in a separate thread and update the UI from there. View property mutations are thread-safe and will trigger re-renders from any thread. import threading def fetch_data (): status . content = \"Loading...\" def do_fetch (): import time time . sleep ( 2 ) # Simulate network request status . content = \"Done!\" threading . Thread ( target = do_fetch , daemon = True ) . start ()","title":"Event Handling"},{"location":"concepts/event-handling/#how-events-work","text":"You register a callback when creating a view (e.g., action= on a Button, on_change= on a TextField). During each render, App._collect_actions() walks the view tree and builds maps from node IDs to callback functions. When the user interacts with the view, Swift sends an event message with the node ID and event string. Python's event handler looks up the callback in the appropriate map and calls it. Events are dispatched sequentially on a dedicated event thread. This prevents concurrent callback execution, so you do not need locks when modifying view properties inside event handlers.","title":"How Events Work"},{"location":"concepts/event-handling/#button-actions","text":"Buttons use the action= parameter. The callback receives no arguments. import nib def main ( app : nib . App ): count = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): count . content = str ( int ( count . content ) + 1 ) def reset (): count . content = \"0\" app . build ( nib . VStack ( controls = [ count , nib . HStack ( controls = [ nib . Button ( \"Add\" , action = increment ), nib . Button ( \"Reset\" , action = reset ), ], spacing = 8 , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Callback signature Button action callbacks take no arguments: def handler(): . The button does not pass any value -- it simply signals that it was tapped.","title":"Button Actions"},{"location":"concepts/event-handling/#text-field-changes","text":"TextField and SecureField use on_change= for value changes and on_submit= for the Return/Enter key. Both receive the current text value as a string. search_field = nib . TextField ( placeholder = \"Search...\" , value = \"\" , on_change = handle_search , on_submit = submit_search , style = nib . TextFieldStyle . roundedBorder , ) def handle_search ( value : str ): # Called on every keystroke print ( f \"Searching: { value } \" ) def submit_search ( value : str ): # Called when user presses Return/Enter print ( f \"Submitted: { value } \" ) Secure fields work the same way: password_field = nib . SecureField ( placeholder = \"Password\" , value = \"\" , on_change = lambda pw : validate_password ( pw ), on_submit = lambda pw : login ( pw ), )","title":"Text Field Changes"},{"location":"concepts/event-handling/#texteditor-changes","text":"TextEditor provides multi-line text input with on_change= : notes = nib . TextEditor ( text = \"\" , placeholder = \"Enter your notes...\" , on_change = handle_notes_change , ) def handle_notes_change ( text : str ): # Called when the text content changes word_count . content = f \" { len ( text . split ()) } words\"","title":"TextEditor Changes"},{"location":"concepts/event-handling/#toggle-changes","text":"Toggle uses on_change= and passes a boolean indicating the new state. dark_mode = nib . Toggle ( \"Dark Mode\" , is_on = False , on_change = handle_dark_mode , ) def handle_dark_mode ( is_on : bool ): if is_on : container . background = \"#1a1a1a\" label . foreground_color = \"#ffffff\" else : container . background = \"#ffffff\" label . foreground_color = \"#000000\"","title":"Toggle Changes"},{"location":"concepts/event-handling/#slider-changes","text":"Slider uses on_change= and passes the new float value. The callback is called continuously while dragging. volume_label = nib . Text ( \"Volume: 50%\" ) volume_slider = nib . Slider ( value = 50 , min_value = 0 , max_value = 100 , step = 1 , on_change = handle_volume , ) def handle_volume ( value : float ): volume_label . content = f \"Volume: { int ( value ) } %\"","title":"Slider Changes"},{"location":"concepts/event-handling/#picker-changes","text":"Picker uses on_change= and passes the selected value as a string. nib . Picker ( \"Theme\" , selection = \"system\" , options = [ ( \"light\" , \"Light\" ), ( \"dark\" , \"Dark\" ), ( \"system\" , \"System\" ), ], on_change = handle_theme , style = nib . PickerStyle . segmented , ) def handle_theme ( value : str ): print ( f \"Selected theme: { value } \" ) # \"light\", \"dark\", or \"system\"","title":"Picker Changes"},{"location":"concepts/event-handling/#lifecycle-events","text":"The app provides lifecycle callbacks for the popover window and app termination. def main ( app : nib . App ): app . on_appear = on_open app . on_disappear = on_close app . on_quit = on_quit # ... def on_open (): # Called every time the popover opens (user clicks menu bar icon) print ( \"Popover opened\" ) refresh_data () def on_close (): # Called every time the popover closes print ( \"Popover closed\" ) pause_updates () def on_quit (): # Called once when the app is shutting down print ( \"App quitting\" ) save_state () close_connections () Event When it fires Frequency on_appear Popover opens Every open on_disappear Popover closes Every close on_quit App is shutting down Once","title":"Lifecycle Events"},{"location":"concepts/event-handling/#drag-and-drop","text":"Any container view can accept dropped files via on_drop= . The callback receives a list of file path strings. drop_zone = nib . VStack ( controls = [ nib . SFSymbol ( \"arrow.down.doc\" , font = nib . Font . TITLE ), nib . Text ( \"Drop files here\" ), ], spacing = 8 , padding = 24 , border_color = \"#666666\" , border_width = 1 , corner_radius = 8 , on_drop = handle_drop , ) def handle_drop ( paths : list [ str ]): for path in paths : print ( f \"Received: { path } \" ) status . content = f \"Dropped { len ( paths ) } file(s)\"","title":"Drag and Drop"},{"location":"concepts/event-handling/#hover-events","text":"Any view can detect mouse hover via on_hover= . The callback receives a boolean -- True when the mouse enters, False when it exits. card = nib . VStack ( controls = [ nib . Text ( \"Hover me\" )], padding = 16 , background = \"#333333\" , corner_radius = 8 , on_hover = handle_hover , animation = nib . Animation . EASE_IN_OUT , ) def handle_hover ( is_hovering : bool ): if is_hovering : card . background = \"#444444\" card . scale = 1.02 else : card . background = \"#333333\" card . scale = 1.0","title":"Hover Events"},{"location":"concepts/event-handling/#click-events","text":"Any view can respond to clicks via on_click= . The callback receives no arguments. nib . VStack ( controls = [ nib . SFSymbol ( \"checkmark.circle\" ), nib . Text ( \"Click to select\" ), ], spacing = 4 , padding = 12 , on_click = lambda : print ( \"Selected!\" ), )","title":"Click Events"},{"location":"concepts/event-handling/#canvas-gestures","text":"The Canvas view supports gesture tracking for drawing and interactive graphics. Enable gestures with enable_gestures=True or by setting any gesture callback. Gesture callbacks receive a PanEvent with x and y coordinates in the canvas coordinate space. import nib def main ( app : nib . App ): canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#1a1a1a\" ) last_pos = None def on_pan_start ( e : nib . PanEvent ): nonlocal last_pos last_pos = ( e . x , e . y ) def on_pan_update ( e : nib . PanEvent ): nonlocal last_pos if last_pos : canvas . append ( nib . draw . Line ( x1 = last_pos [ 0 ], y1 = last_pos [ 1 ], x2 = e . x , y2 = e . y , stroke = \"#ffffff\" , stroke_width = 3 , )) last_pos = ( e . x , e . y ) def on_pan_end ( e : nib . PanEvent ): nonlocal last_pos last_pos = None def on_hover ( e : nib . PanEvent ): # Mouse is moving over canvas (not dragging) coords . content = f \"( { e . x : .0f } , { e . y : .0f } )\" canvas . on_pan_start = on_pan_start canvas . on_pan_update = on_pan_update canvas . on_pan_end = on_pan_end canvas . on_hover = on_hover coords = nib . Text ( \"(0, 0)\" , font = nib . Font . CAPTION ) app . build ( nib . VStack ( controls = [ canvas , coords ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Callback When it fires Argument on_pan_start Mouse/pen pressed down PanEvent(x, y) on_pan_update Mouse/pen dragged PanEvent(x, y) on_pan_end Mouse/pen released PanEvent(x, y) on_hover Mouse moves (not dragging) PanEvent(x, y) Canvas hover vs view hover Canvas on_hover receives a PanEvent with x/y coordinates. View on_hover (on any other view) receives a bool indicating whether the mouse entered or exited. They share the same parameter name but have different callback signatures depending on the view type.","title":"Canvas Gestures"},{"location":"concepts/event-handling/#hotkeys","text":"Register global keyboard shortcuts that work even when the app window is not focused. def main ( app : nib . App ): app . on_hotkey ( \"cmd+shift+n\" , show_new_dialog ) app . on_hotkey ( \"cmd+k\" , toggle_search ) # Decorator syntax @app . hotkey ( \"cmd+shift+p\" ) def open_command_palette (): print ( \"Command palette opened\" ) Hotkey strings use modifier names joined with + : cmd , shift , opt (or alt ), ctrl , plus a key name.","title":"Hotkeys"},{"location":"concepts/event-handling/#context-menu-events","text":"Right-click menu items use the action= parameter, same as buttons. app . menu = [ nib . MenuItem ( \"Settings\" , action = open_settings , icon = \"gear\" , shortcut = \"cmd+,\" ), nib . MenuItem ( \"Check for Updates\" , action = check_updates , icon = \"arrow.clockwise\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] def open_settings (): print ( \"Opening settings\" ) def check_updates (): print ( \"Checking for updates\" )","title":"Context Menu Events"},{"location":"concepts/event-handling/#callback-signatures-summary","text":"View / Feature Parameter Callback Signature Button action= def handler(): TextField on_change= def handler(value: str): TextField on_submit= def handler(value: str): SecureField on_change= def handler(value: str): SecureField on_submit= def handler(value: str): TextEditor on_change= def handler(text: str): Toggle on_change= def handler(is_on: bool): Slider on_change= def handler(value: float): Picker on_change= def handler(value: str): App on_appear= def handler(): App on_disappear= def handler(): App on_quit= def handler(): Any view on_drop= def handler(paths: list[str]): Any view on_hover= def handler(is_hovering: bool): Any view on_click= def handler(): Canvas on_pan_start= def handler(e: PanEvent): Canvas on_pan_update= def handler(e: PanEvent): Canvas on_pan_end= def handler(e: PanEvent): Canvas on_hover= def handler(e: PanEvent): MenuItem action= def handler(): App.on_hotkey callback def handler():","title":"Callback Signatures Summary"},{"location":"concepts/event-handling/#event-threading","text":"All event callbacks run on a single dedicated event thread. This means: Callbacks never run concurrently with each other. You can safely mutate view properties in callbacks without locks. Long-running callbacks block subsequent events from being processed. Avoid blocking the event thread If a callback needs to do heavy work (network requests, file I/O, computation), run it in a separate thread and update the UI from there. View property mutations are thread-safe and will trigger re-renders from any thread. import threading def fetch_data (): status . content = \"Loading...\" def do_fetch (): import time time . sleep ( 2 ) # Simulate network request status . content = \"Done!\" threading . Thread ( target = do_fetch , daemon = True ) . start ()","title":"Event Threading"},{"location":"concepts/modifiers/","text":"All view styling in Nib is done through constructor parameters. There is no method chaining. This is a deliberate departure from SwiftUI's .modifier() pattern -- Nib keeps everything in one place, making your code easier to read and modify. # SwiftUI style (NOT how Nib works): # Text(\"Hello\").font(.title).foregroundColor(.blue).padding(16) # Nib style: nib . Text ( \"Hello\" , font = nib . Font . TITLE , foreground_color = nib . Color . BLUE , padding = 16 , ) Layout \u00b6 Control the size and spacing of views. # Fixed dimensions nib . Text ( \"Fixed size\" , width = 200 , height = 50 ) # Minimum and maximum dimensions nib . Text ( \"Flexible\" , min_width = 100 , max_width = 300 ) # Fill available width nib . Text ( \"Full width\" , max_width = \"infinity\" ) # Padding (inside background) nib . Text ( \"Padded\" , padding = 16 , background = \"#333333\" ) # Padding with per-side control nib . Text ( \"Custom padding\" , padding = { \"top\" : 8 , \"bottom\" : 8 , \"leading\" : 16 , \"trailing\" : 16 }) # Shorthand: horizontal and vertical nib . Text ( \"Shorthand\" , padding = { \"horizontal\" : 16 , \"vertical\" : 8 }) # Margin (outside background) nib . VStack ( controls = [ nib . Text ( \"Content\" )], background = \"#333333\" , padding = 12 , margin = 8 , # Space outside the background ) Parameter Type Description width float Fixed width in points height float Fixed height in points min_width float Minimum width min_height float Minimum height max_width float or \"infinity\" Maximum width max_height float or \"infinity\" Maximum height padding float or dict Inner spacing (inside background) margin float or dict Outer spacing (outside background) padding vs margin padding is applied inside the background. If you set background=\"#333\" and padding=16 , the background extends behind the padding. margin is applied outside the background, creating space between the background edge and neighboring views. Appearance \u00b6 Control colors, opacity, and corner rounding. # Background color (string, Color enum, or View) nib . Text ( \"Colored\" , background = \"#ff5733\" ) nib . Text ( \"Themed\" , background = nib . Color . BLUE ) # Background as a view nib . VStack ( controls = [ nib . Text ( \"Fancy\" )], background = nib . Rectangle ( corner_radius = 12 , fill = \"#1a1a2e\" , stroke = \"#2a2a4e\" , stroke_width = 1 , ), padding = 16 , ) # Foreground color (text and content color) nib . Text ( \"Blue text\" , foreground_color = nib . Color . BLUE ) nib . Text ( \"Hex color\" , foreground_color = \"#e74c3c\" ) # Shape fill and stroke nib . Circle ( fill = nib . Color . RED , stroke = \"#000000\" , stroke_width = 2 , width = 50 , height = 50 ) # Opacity nib . Text ( \"Faded\" , opacity = 0.5 ) # Corner radius nib . VStack ( controls = [ nib . Text ( \"Rounded\" )], corner_radius = 8 , background = \"#333333\" , padding = 12 , ) Parameter Type Description background Color, string, or View Background fill foreground_color Color or string Text/content color fill Color or string Shape fill color stroke Color or string Shape stroke color stroke_width float Stroke width in points opacity float Opacity from 0.0 to 1.0 corner_radius float Corner rounding in points Typography \u00b6 Control font and weight. # System fonts nib . Text ( \"Title\" , font = nib . Font . TITLE ) nib . Text ( \"Headline\" , font = nib . Font . HEADLINE ) nib . Text ( \"Body\" , font = nib . Font . BODY ) nib . Text ( \"Caption\" , font = nib . Font . CAPTION ) # Custom font with size nib . Text ( \"Custom\" , font = nib . Font . custom ( \"Menlo\" , size = 14 )) # Font weight nib . Text ( \"Bold\" , font_weight = nib . FontWeight . BOLD ) nib . Text ( \"Light\" , font_weight = \"light\" ) # Combined nib . Text ( \"Styled\" , font = nib . Font . TITLE , font_weight = nib . FontWeight . HEAVY , foreground_color = nib . Color . BLUE , ) Parameter Type Description font Font or string Font style or custom font font_weight FontWeight or string Text weight Effects \u00b6 Shadows, borders, clipping, blending, and transforms. Shadows \u00b6 nib . VStack ( controls = [ nib . Text ( \"Shadow\" )], background = \"#ffffff\" , padding = 16 , corner_radius = 8 , shadow_radius = 10 , shadow_color = \"#00000033\" , shadow_x = 0 , shadow_y = 4 , ) Borders \u00b6 nib . VStack ( controls = [ nib . Text ( \"Bordered\" )], padding = 12 , border_color = \"#3498db\" , border_width = 2 , ) Clip Shape \u00b6 # Clip to circle nib . Image ( \"photo.jpg\" , width = 80 , height = 80 , clip_shape = \"circle\" ) # Clip to capsule nib . Text ( \"Tag\" , padding = { \"horizontal\" : 12 , \"vertical\" : 4 }, clip_shape = \"capsule\" , background = \"#3498db\" ) # Clip to rounded rectangle nib . Image ( \"banner.jpg\" , clip_shape = nib . Rectangle ( corner_radius = 12 )) Scale and Offset \u00b6 # Scale nib . SFSymbol ( \"star.fill\" , scale = 1.5 ) # Offset (useful in ZStack for positioning) nib . ZStack ( controls = [ nib . Circle ( fill = nib . Color . BLUE , width = 100 , height = 100 ), nib . Text ( \"Centered\" , offset = nib . Offset ( x = 0 , y =- 10 )), ], ) Blend Mode \u00b6 nib . Image ( \"photo.jpg\" , blend_mode = nib . BlendMode . MULTIPLY ) Parameter Type Description shadow_color string Shadow color shadow_radius float Shadow blur radius shadow_x float Shadow horizontal offset shadow_y float Shadow vertical offset border_color Color or string Border color border_width float Border width in points clip_shape string or View Clip to shape ( \"circle\" , \"capsule\" , or shape view) scale float Scale transform factor offset Offset Position offset (x, y) blend_mode BlendMode or string Layer blending mode Animation \u00b6 Animate property changes with built-in animation support. # Animate all changes on this view box = nib . VStack ( controls = [ nib . Text ( \"Animated\" )], background = \"#333333\" , padding = 16 , opacity = 1.0 , animation = nib . Animation . EASE_IN_OUT , ) def fade (): box . opacity = 0.3 # Animates smoothly # Animation with custom duration nib . VStack ( controls = [ nib . Text ( \"Slow\" )], animation = nib . Animation ( type = \"easeInOut\" , duration = 0.5 ), ) # Spring animation nib . VStack ( controls = [ nib . Text ( \"Bouncy\" )], animation = nib . Animation ( type = \"spring\" ), ) # Content transition (how content changes animate) counter = nib . Text ( \"0\" , content_transition = \"numericText\" ) # View transition (how views appear/disappear) nib . Text ( \"Slides in\" , transition = \"slide\" ) Sticky animations When you set animation= on a view, it becomes \"sticky\" -- all future property changes on that view will animate with the same configuration. You do not need to re-specify the animation on each change. Parameter Type Description animation Animation Animation for property changes content_transition ContentTransition or string Animation for content changes transition Transition or string Animation for appear/disappear Interaction \u00b6 Handle user interactions directly on any view. # Drag and drop nib . VStack ( controls = [ nib . Text ( \"Drop files here\" )], on_drop = lambda paths : print ( f \"Dropped: { paths } \" ), padding = 20 , border_color = \"#666\" , border_width = 1 , ) # Hover detection nib . Text ( \"Hover me\" , on_hover = lambda hovering : print ( f \"Hovering: { hovering } \" ), ) # Click handler nib . VStack ( controls = [ nib . Text ( \"Click me\" )], on_click = lambda : print ( \"Clicked!\" ), ) # Tooltip nib . Button ( \"Save\" , action = save , tooltip = \"Save the current document\" ) Parameter Type Description on_drop callback Receives list[str] of file paths on_hover callback Receives bool (True on enter, False on exit) on_click callback Called on click (no arguments) tooltip string or View Tooltip shown on hover visible bool Whether view is included in tree Reactive Modifiers \u00b6 All modifier parameters can be changed after construction, and changes trigger automatic re-renders: card = nib . VStack ( controls = [ nib . Text ( \"Card\" )], background = \"#333333\" , opacity = 1.0 , padding = 16 , corner_radius = 8 , ) # All of these trigger re-renders card . opacity = 0.5 card . background = \"#ff0000\" card . padding = 24 card . corner_radius = 16 card . border_color = \"#ffffff\" card . border_width = 2 See Reactivity for more on how property changes trigger UI updates. Modifier Application Order \u00b6 Modifiers are applied in a specific order that matches SwiftUI conventions: Font -- applied first so text sizing is correct Foreground color -- text/content color Fill and stroke -- shape colors Padding -- inner spacing Frame -- width, height, min/max constraints Background -- behind padded content Corner radius -- rounds the background Margin -- outer spacing after background Border -- around the outer edge Shadow -- drop shadow behind everything Clip shape -- clips the final result Opacity -- applied to the entire composed view Scale, offset, blend mode -- transforms Animation and transitions -- animation configuration This order means padding is inside background (padding pushes content away from background edges), and margin is outside background (margin creates space between this view and its neighbors).","title":"Modifiers"},{"location":"concepts/modifiers/#layout","text":"Control the size and spacing of views. # Fixed dimensions nib . Text ( \"Fixed size\" , width = 200 , height = 50 ) # Minimum and maximum dimensions nib . Text ( \"Flexible\" , min_width = 100 , max_width = 300 ) # Fill available width nib . Text ( \"Full width\" , max_width = \"infinity\" ) # Padding (inside background) nib . Text ( \"Padded\" , padding = 16 , background = \"#333333\" ) # Padding with per-side control nib . Text ( \"Custom padding\" , padding = { \"top\" : 8 , \"bottom\" : 8 , \"leading\" : 16 , \"trailing\" : 16 }) # Shorthand: horizontal and vertical nib . Text ( \"Shorthand\" , padding = { \"horizontal\" : 16 , \"vertical\" : 8 }) # Margin (outside background) nib . VStack ( controls = [ nib . Text ( \"Content\" )], background = \"#333333\" , padding = 12 , margin = 8 , # Space outside the background ) Parameter Type Description width float Fixed width in points height float Fixed height in points min_width float Minimum width min_height float Minimum height max_width float or \"infinity\" Maximum width max_height float or \"infinity\" Maximum height padding float or dict Inner spacing (inside background) margin float or dict Outer spacing (outside background) padding vs margin padding is applied inside the background. If you set background=\"#333\" and padding=16 , the background extends behind the padding. margin is applied outside the background, creating space between the background edge and neighboring views.","title":"Layout"},{"location":"concepts/modifiers/#appearance","text":"Control colors, opacity, and corner rounding. # Background color (string, Color enum, or View) nib . Text ( \"Colored\" , background = \"#ff5733\" ) nib . Text ( \"Themed\" , background = nib . Color . BLUE ) # Background as a view nib . VStack ( controls = [ nib . Text ( \"Fancy\" )], background = nib . Rectangle ( corner_radius = 12 , fill = \"#1a1a2e\" , stroke = \"#2a2a4e\" , stroke_width = 1 , ), padding = 16 , ) # Foreground color (text and content color) nib . Text ( \"Blue text\" , foreground_color = nib . Color . BLUE ) nib . Text ( \"Hex color\" , foreground_color = \"#e74c3c\" ) # Shape fill and stroke nib . Circle ( fill = nib . Color . RED , stroke = \"#000000\" , stroke_width = 2 , width = 50 , height = 50 ) # Opacity nib . Text ( \"Faded\" , opacity = 0.5 ) # Corner radius nib . VStack ( controls = [ nib . Text ( \"Rounded\" )], corner_radius = 8 , background = \"#333333\" , padding = 12 , ) Parameter Type Description background Color, string, or View Background fill foreground_color Color or string Text/content color fill Color or string Shape fill color stroke Color or string Shape stroke color stroke_width float Stroke width in points opacity float Opacity from 0.0 to 1.0 corner_radius float Corner rounding in points","title":"Appearance"},{"location":"concepts/modifiers/#typography","text":"Control font and weight. # System fonts nib . Text ( \"Title\" , font = nib . Font . TITLE ) nib . Text ( \"Headline\" , font = nib . Font . HEADLINE ) nib . Text ( \"Body\" , font = nib . Font . BODY ) nib . Text ( \"Caption\" , font = nib . Font . CAPTION ) # Custom font with size nib . Text ( \"Custom\" , font = nib . Font . custom ( \"Menlo\" , size = 14 )) # Font weight nib . Text ( \"Bold\" , font_weight = nib . FontWeight . BOLD ) nib . Text ( \"Light\" , font_weight = \"light\" ) # Combined nib . Text ( \"Styled\" , font = nib . Font . TITLE , font_weight = nib . FontWeight . HEAVY , foreground_color = nib . Color . BLUE , ) Parameter Type Description font Font or string Font style or custom font font_weight FontWeight or string Text weight","title":"Typography"},{"location":"concepts/modifiers/#effects","text":"Shadows, borders, clipping, blending, and transforms.","title":"Effects"},{"location":"concepts/modifiers/#shadows","text":"nib . VStack ( controls = [ nib . Text ( \"Shadow\" )], background = \"#ffffff\" , padding = 16 , corner_radius = 8 , shadow_radius = 10 , shadow_color = \"#00000033\" , shadow_x = 0 , shadow_y = 4 , )","title":"Shadows"},{"location":"concepts/modifiers/#borders","text":"nib . VStack ( controls = [ nib . Text ( \"Bordered\" )], padding = 12 , border_color = \"#3498db\" , border_width = 2 , )","title":"Borders"},{"location":"concepts/modifiers/#clip-shape","text":"# Clip to circle nib . Image ( \"photo.jpg\" , width = 80 , height = 80 , clip_shape = \"circle\" ) # Clip to capsule nib . Text ( \"Tag\" , padding = { \"horizontal\" : 12 , \"vertical\" : 4 }, clip_shape = \"capsule\" , background = \"#3498db\" ) # Clip to rounded rectangle nib . Image ( \"banner.jpg\" , clip_shape = nib . Rectangle ( corner_radius = 12 ))","title":"Clip Shape"},{"location":"concepts/modifiers/#scale-and-offset","text":"# Scale nib . SFSymbol ( \"star.fill\" , scale = 1.5 ) # Offset (useful in ZStack for positioning) nib . ZStack ( controls = [ nib . Circle ( fill = nib . Color . BLUE , width = 100 , height = 100 ), nib . Text ( \"Centered\" , offset = nib . Offset ( x = 0 , y =- 10 )), ], )","title":"Scale and Offset"},{"location":"concepts/modifiers/#blend-mode","text":"nib . Image ( \"photo.jpg\" , blend_mode = nib . BlendMode . MULTIPLY ) Parameter Type Description shadow_color string Shadow color shadow_radius float Shadow blur radius shadow_x float Shadow horizontal offset shadow_y float Shadow vertical offset border_color Color or string Border color border_width float Border width in points clip_shape string or View Clip to shape ( \"circle\" , \"capsule\" , or shape view) scale float Scale transform factor offset Offset Position offset (x, y) blend_mode BlendMode or string Layer blending mode","title":"Blend Mode"},{"location":"concepts/modifiers/#animation","text":"Animate property changes with built-in animation support. # Animate all changes on this view box = nib . VStack ( controls = [ nib . Text ( \"Animated\" )], background = \"#333333\" , padding = 16 , opacity = 1.0 , animation = nib . Animation . EASE_IN_OUT , ) def fade (): box . opacity = 0.3 # Animates smoothly # Animation with custom duration nib . VStack ( controls = [ nib . Text ( \"Slow\" )], animation = nib . Animation ( type = \"easeInOut\" , duration = 0.5 ), ) # Spring animation nib . VStack ( controls = [ nib . Text ( \"Bouncy\" )], animation = nib . Animation ( type = \"spring\" ), ) # Content transition (how content changes animate) counter = nib . Text ( \"0\" , content_transition = \"numericText\" ) # View transition (how views appear/disappear) nib . Text ( \"Slides in\" , transition = \"slide\" ) Sticky animations When you set animation= on a view, it becomes \"sticky\" -- all future property changes on that view will animate with the same configuration. You do not need to re-specify the animation on each change. Parameter Type Description animation Animation Animation for property changes content_transition ContentTransition or string Animation for content changes transition Transition or string Animation for appear/disappear","title":"Animation"},{"location":"concepts/modifiers/#interaction","text":"Handle user interactions directly on any view. # Drag and drop nib . VStack ( controls = [ nib . Text ( \"Drop files here\" )], on_drop = lambda paths : print ( f \"Dropped: { paths } \" ), padding = 20 , border_color = \"#666\" , border_width = 1 , ) # Hover detection nib . Text ( \"Hover me\" , on_hover = lambda hovering : print ( f \"Hovering: { hovering } \" ), ) # Click handler nib . VStack ( controls = [ nib . Text ( \"Click me\" )], on_click = lambda : print ( \"Clicked!\" ), ) # Tooltip nib . Button ( \"Save\" , action = save , tooltip = \"Save the current document\" ) Parameter Type Description on_drop callback Receives list[str] of file paths on_hover callback Receives bool (True on enter, False on exit) on_click callback Called on click (no arguments) tooltip string or View Tooltip shown on hover visible bool Whether view is included in tree","title":"Interaction"},{"location":"concepts/modifiers/#reactive-modifiers","text":"All modifier parameters can be changed after construction, and changes trigger automatic re-renders: card = nib . VStack ( controls = [ nib . Text ( \"Card\" )], background = \"#333333\" , opacity = 1.0 , padding = 16 , corner_radius = 8 , ) # All of these trigger re-renders card . opacity = 0.5 card . background = \"#ff0000\" card . padding = 24 card . corner_radius = 16 card . border_color = \"#ffffff\" card . border_width = 2 See Reactivity for more on how property changes trigger UI updates.","title":"Reactive Modifiers"},{"location":"concepts/modifiers/#modifier-application-order","text":"Modifiers are applied in a specific order that matches SwiftUI conventions: Font -- applied first so text sizing is correct Foreground color -- text/content color Fill and stroke -- shape colors Padding -- inner spacing Frame -- width, height, min/max constraints Background -- behind padded content Corner radius -- rounds the background Margin -- outer spacing after background Border -- around the outer edge Shadow -- drop shadow behind everything Clip shape -- clips the final result Opacity -- applied to the entire composed view Scale, offset, blend mode -- transforms Animation and transitions -- animation configuration This order means padding is inside background (padding pushes content away from background edges), and margin is outside background (margin creates space between this view and its neighbors).","title":"Modifier Application Order"},{"location":"concepts/reactivity/","text":"Nib uses a simple reactivity model: mutate a view property, and the UI updates automatically. There is no virtual DOM, no signals, no subscription system. You change a value; Nib detects it and sends the new view tree to Swift. How It Works \u00b6 Every view holds a reference to the parent App . When you set a property on a view (e.g., text.content = \"new value\" ), the View.__setattr__ override detects the change and calls app._trigger_rerender() . This sets a threading Event that wakes the render loop, which re-serializes the entire view tree and sends it to Swift. import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number\" ) app . width = 300 app . height = 200 counter = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) # Triggers re-render app . build ( nib . VStack ( controls = [ counter , nib . Button ( \"Add\" , action = increment ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) When the button is tapped, increment() runs, setting counter.content . This triggers a full re-render: the view tree is re-serialized and sent to Swift, which updates the native UI. The Render Loop \u00b6 The render loop runs on a dedicated background thread. It is event-based and coalesced: A property change calls app._trigger_rerender() , which sets a threading.Event . The render thread is waiting on this event. When set, it wakes up. The event is cleared, and a render happens. The thread sleeps for 2ms (minimum interval), then waits again. This design means rapid consecutive changes are coalesced into a single render: # These three changes result in ONE render, not three label1 . content = \"Updated\" label2 . content = \"Also updated\" label3 . opacity = 0.5 The maximum render rate is approximately 500 fps. In practice, renders happen much less frequently since they are driven by user events. Manual Updates \u00b6 Sometimes you modify data that the reactivity system cannot detect -- for example, mutating a list in place or changing a nested object. In those cases, call app.update() to force a re-render: items = [ \"Apple\" , \"Banana\" ] item_list = nib . VStack ( controls = [ nib . Text ( item ) for item in items ], spacing = 4 , ) def add_item (): items . append ( \"Cherry\" ) # Rebuild the controls list item_list . _children = [ nib . Text ( item ) for item in items ] for child in item_list . _children : child . _set_app ( app ) app . update () # Force re-render When to use app.update() You rarely need app.update() . Direct property mutations on views (like text.content = \"new\" or view.opacity = 0.5 ) automatically trigger re-renders. Use app.update() only when you are modifying data structures that views reference indirectly. Function-Based Reactivity \u00b6 The recommended approach. You create view instances, keep references to them, and mutate their properties directly: import nib def main ( app : nib . App ): status = nib . Text ( \"Idle\" , foreground_color = nib . Color . SECONDARY_LABEL ) progress = nib . ProgressView ( value = 0.0 ) start_button = nib . Button ( \"Start\" , action = None ) def start_task (): status . content = \"Running...\" status . foreground_color = nib . Color . BLUE start_button . visible = False # Simulate progress updates for i in range ( 10 ): import time time . sleep ( 0.1 ) progress . value = ( i + 1 ) / 10 status . content = \"Done\" status . foreground_color = nib . Color . GREEN start_button . visible = True start_button . _action = start_task app . build ( nib . VStack ( controls = [ status , progress , start_button ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Every property assignment ( status.content = ... , progress.value = ... , start_button.visible = ... ) triggers a re-render automatically. Class-Based Reactivity \u00b6 For class-based apps, Nib provides the State[T] descriptor. When you assign to a State attribute, it calls _trigger_rerender() on the app instance: import nib class CounterApp ( nib . App ): count = nib . State ( 0 ) def body ( self ) -> nib . View : return nib . VStack ( controls = [ nib . Text ( f \"Count: { self . count } \" , font = nib . Font . TITLE ), nib . Button ( \"Increment\" , action = self . increment ), ], spacing = 8 , padding = 16 , ) def increment ( self ): self . count += 1 # State descriptor triggers re-render CounterApp ( icon = \"number\" ) . run () Class-based rebuilds the tree In the class-based approach, body() is called on every render, creating new view instances each time. In the function-based approach, you mutate existing instances. Both work; the function-based approach is recommended because it avoids object allocation overhead. Reactive Modifiers \u00b6 View modifiers (styling properties) are also reactive. Changing a modifier triggers a re-render just like changing content: box = nib . VStack ( controls = [ nib . Text ( \"Hello\" )], background = \"#333333\" , opacity = 1.0 , padding = 16 , ) def fade_out (): box . opacity = 0.3 # Triggers re-render box . background = \"#ff0000\" # Triggers re-render The following modifier properties can be mutated reactively on any view: width , height , min_width , min_height , max_width , max_height padding , margin background , foreground_color , fill , stroke , stroke_width opacity , corner_radius font , font_weight shadow_color , shadow_radius , shadow_x , shadow_y border_color , border_width clip_shape , blend_mode , scale , offset animation , content_transition , transition visible No Virtual DOM \u00b6 Nib does not use a virtual DOM or a reconciliation algorithm on the Python side. The diff engine ( diff.py ) exists but is currently unused. Instead, on every render, the full view tree is serialized to a flat node list and sent to Swift. Swift's SwiftUI framework handles the actual view diffing and only repaints what changed on screen. This approach is simple and fast enough because: Menu bar apps typically have small view trees (tens to low hundreds of nodes). MessagePack serialization is fast. SwiftUI is efficient at diffing and partial re-renders. The render loop coalesces rapid changes. Batching Changes \u00b6 If you are making several changes and want a single render, you can rely on the natural coalescing behavior -- consecutive property mutations in the same function call will be coalesced by the render loop: def update_everything (): title . content = \"New Title\" subtitle . content = \"New Subtitle\" icon . foreground_color = nib . Color . RED container . opacity = 0.8 # All four changes coalesce into one render If you need explicit control, you can batch changes and call app.update() once at the end: def update_everything (): title . content = \"New Title\" subtitle . content = \"New Subtitle\" icon . foreground_color = nib . Color . RED container . opacity = 0.8 app . update () # Explicit single render","title":"Reactivity"},{"location":"concepts/reactivity/#how-it-works","text":"Every view holds a reference to the parent App . When you set a property on a view (e.g., text.content = \"new value\" ), the View.__setattr__ override detects the change and calls app._trigger_rerender() . This sets a threading Event that wakes the render loop, which re-serializes the entire view tree and sends it to Swift. import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number\" ) app . width = 300 app . height = 200 counter = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) # Triggers re-render app . build ( nib . VStack ( controls = [ counter , nib . Button ( \"Add\" , action = increment ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) When the button is tapped, increment() runs, setting counter.content . This triggers a full re-render: the view tree is re-serialized and sent to Swift, which updates the native UI.","title":"How It Works"},{"location":"concepts/reactivity/#the-render-loop","text":"The render loop runs on a dedicated background thread. It is event-based and coalesced: A property change calls app._trigger_rerender() , which sets a threading.Event . The render thread is waiting on this event. When set, it wakes up. The event is cleared, and a render happens. The thread sleeps for 2ms (minimum interval), then waits again. This design means rapid consecutive changes are coalesced into a single render: # These three changes result in ONE render, not three label1 . content = \"Updated\" label2 . content = \"Also updated\" label3 . opacity = 0.5 The maximum render rate is approximately 500 fps. In practice, renders happen much less frequently since they are driven by user events.","title":"The Render Loop"},{"location":"concepts/reactivity/#manual-updates","text":"Sometimes you modify data that the reactivity system cannot detect -- for example, mutating a list in place or changing a nested object. In those cases, call app.update() to force a re-render: items = [ \"Apple\" , \"Banana\" ] item_list = nib . VStack ( controls = [ nib . Text ( item ) for item in items ], spacing = 4 , ) def add_item (): items . append ( \"Cherry\" ) # Rebuild the controls list item_list . _children = [ nib . Text ( item ) for item in items ] for child in item_list . _children : child . _set_app ( app ) app . update () # Force re-render When to use app.update() You rarely need app.update() . Direct property mutations on views (like text.content = \"new\" or view.opacity = 0.5 ) automatically trigger re-renders. Use app.update() only when you are modifying data structures that views reference indirectly.","title":"Manual Updates"},{"location":"concepts/reactivity/#function-based-reactivity","text":"The recommended approach. You create view instances, keep references to them, and mutate their properties directly: import nib def main ( app : nib . App ): status = nib . Text ( \"Idle\" , foreground_color = nib . Color . SECONDARY_LABEL ) progress = nib . ProgressView ( value = 0.0 ) start_button = nib . Button ( \"Start\" , action = None ) def start_task (): status . content = \"Running...\" status . foreground_color = nib . Color . BLUE start_button . visible = False # Simulate progress updates for i in range ( 10 ): import time time . sleep ( 0.1 ) progress . value = ( i + 1 ) / 10 status . content = \"Done\" status . foreground_color = nib . Color . GREEN start_button . visible = True start_button . _action = start_task app . build ( nib . VStack ( controls = [ status , progress , start_button ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Every property assignment ( status.content = ... , progress.value = ... , start_button.visible = ... ) triggers a re-render automatically.","title":"Function-Based Reactivity"},{"location":"concepts/reactivity/#class-based-reactivity","text":"For class-based apps, Nib provides the State[T] descriptor. When you assign to a State attribute, it calls _trigger_rerender() on the app instance: import nib class CounterApp ( nib . App ): count = nib . State ( 0 ) def body ( self ) -> nib . View : return nib . VStack ( controls = [ nib . Text ( f \"Count: { self . count } \" , font = nib . Font . TITLE ), nib . Button ( \"Increment\" , action = self . increment ), ], spacing = 8 , padding = 16 , ) def increment ( self ): self . count += 1 # State descriptor triggers re-render CounterApp ( icon = \"number\" ) . run () Class-based rebuilds the tree In the class-based approach, body() is called on every render, creating new view instances each time. In the function-based approach, you mutate existing instances. Both work; the function-based approach is recommended because it avoids object allocation overhead.","title":"Class-Based Reactivity"},{"location":"concepts/reactivity/#reactive-modifiers","text":"View modifiers (styling properties) are also reactive. Changing a modifier triggers a re-render just like changing content: box = nib . VStack ( controls = [ nib . Text ( \"Hello\" )], background = \"#333333\" , opacity = 1.0 , padding = 16 , ) def fade_out (): box . opacity = 0.3 # Triggers re-render box . background = \"#ff0000\" # Triggers re-render The following modifier properties can be mutated reactively on any view: width , height , min_width , min_height , max_width , max_height padding , margin background , foreground_color , fill , stroke , stroke_width opacity , corner_radius font , font_weight shadow_color , shadow_radius , shadow_x , shadow_y border_color , border_width clip_shape , blend_mode , scale , offset animation , content_transition , transition visible","title":"Reactive Modifiers"},{"location":"concepts/reactivity/#no-virtual-dom","text":"Nib does not use a virtual DOM or a reconciliation algorithm on the Python side. The diff engine ( diff.py ) exists but is currently unused. Instead, on every render, the full view tree is serialized to a flat node list and sent to Swift. Swift's SwiftUI framework handles the actual view diffing and only repaints what changed on screen. This approach is simple and fast enough because: Menu bar apps typically have small view trees (tens to low hundreds of nodes). MessagePack serialization is fast. SwiftUI is efficient at diffing and partial re-renders. The render loop coalesces rapid changes.","title":"No Virtual DOM"},{"location":"concepts/reactivity/#batching-changes","text":"If you are making several changes and want a single render, you can rely on the natural coalescing behavior -- consecutive property mutations in the same function call will be coalesced by the render loop: def update_everything (): title . content = \"New Title\" subtitle . content = \"New Subtitle\" icon . foreground_color = nib . Color . RED container . opacity = 0.8 # All four changes coalesce into one render If you need explicit control, you can batch changes and call app.update() once at the end: def update_everything (): title . content = \"New Title\" subtitle . content = \"New Subtitle\" icon . foreground_color = nib . Color . RED container . opacity = 0.8 app . update () # Explicit single render","title":"Batching Changes"},{"location":"concepts/view-tree/","text":"Every Nib UI is a tree of views. A root view contains children, which contain more children, forming a hierarchy that describes your entire interface. This tree is serialized and sent to Swift for rendering. The View Base Class \u00b6 All UI elements in Nib inherit from the View base class. Each view has: A type ( _type ) -- the SwiftUI view it maps to (e.g., \"Text\" , \"VStack\" , \"Button\" ). Properties ( _get_props() ) -- view-specific data like text content, slider value, or toggle state. Modifiers ( _modifiers ) -- a list of styling instructions (padding, color, font, etc.). Children -- other views nested inside containers. An ID ( _id ) -- a position-based identifier assigned during tree traversal. import nib # A simple view tree root = nib . VStack ( controls = [ nib . Text ( \"Hello\" , font = nib . Font . TITLE ), nib . HStack ( controls = [ nib . Button ( \"OK\" , action = confirm ), nib . Button ( \"Cancel\" , action = cancel ), ], spacing = 8 , ), ], spacing = 12 , padding = 16 , ) app . build ( root ) View Categories \u00b6 Nib provides views across several categories: Controls -- Interactive and display elements: Text , Button , TextField , SecureField , Toggle , Slider , Picker , DatePicker , ColorPicker , ProgressView , Gauge , Label , Link , Image , Video , Markdown , Map , WebView , Table , TextEditor , ShareLink , CameraPreview . Layout containers -- Views that arrange children: VStack , HStack , ZStack , ScrollView , List , Section , Form , Group , Spacer , Divider , NavigationStack , NavigationLink , DisclosureGroup , Grid , LazyVGrid , LazyHGrid . Shapes -- Geometric primitives: Rectangle , Circle , Ellipse , Capsule , Path . Also gradient fills: LinearGradient , RadialGradient , AngularGradient , EllipticalGradient . Charts -- Data visualization: Chart , LineMark , BarMark , AreaMark , PointMark , RuleMark , RectMark , SectorMark . Effects -- Visual effects: VisualEffectBlur . Canvas -- Core Graphics drawing surface: Canvas with drawing commands from nib.draw . Children: controls= and content= \u00b6 Container views use the controls= parameter for their list of children: nib . VStack ( controls = [ nib . Text ( \"Item 1\" ), nib . Text ( \"Item 2\" ), nib . Text ( \"Item 3\" ), ], spacing = 4 , ) Single-child wrapper views (like Button , Link , Toggle ) use the content= parameter: # Button with custom content nib . Button ( content = nib . HStack ( controls = [ nib . SFSymbol ( \"star.fill\" ), nib . Text ( \"Favorite\" ), ], spacing = 4 , ), action = toggle_favorite , ) controls vs content controls= is for containers that hold multiple children (stacks, lists, grids). content= is for views that wrap a single child view. Some views like Button accept both a label string for simple cases and content for custom layouts. Position-Based IDs \u00b6 Every view gets a position-based ID during tree traversal. The root view is \"0\" . Its first child is \"0.0\" , the second child is \"0.1\" , and so on. Nested children continue the pattern: \"0.1.2\" is the third child of the second child of the root. VStack \"0\" +-- Text \"0.0\" (\"Hello\") +-- HStack \"0.1\" +-- Button \"0.1.0\" (\"OK\") +-- Button \"0.1.1\" (\"Cancel\") These IDs serve two purposes: Stable identity -- Swift uses IDs to match old and new views during re-renders, enabling smooth transitions and state preservation. Event routing -- When Swift sends an event (e.g., a button tap), it includes the node ID so Python can look up and call the correct callback. IDs are assigned automatically by App._collect_actions() during each render. You never need to set them manually. Flat Node Serialization \u00b6 When the view tree is sent to Swift, it is serialized as a flat list of nodes rather than a nested tree structure. Each node carries a parentId and childIds instead of nested children. This design was chosen to prevent stack overflow in the Swift runtime when decoding deeply nested trees. # Conceptual flat node structure (internal, not user-facing) [ { \"id\" : \"0\" , \"type\" : \"VStack\" , \"parentId\" : None , \"childIds\" : [ \"0.0\" , \"0.1\" ]}, { \"id\" : \"0.0\" , \"type\" : \"Text\" , \"parentId\" : \"0\" , \"childIds\" : None }, { \"id\" : \"0.1\" , \"type\" : \"HStack\" , \"parentId\" : \"0\" , \"childIds\" : [ \"0.1.0\" , \"0.1.1\" ]}, { \"id\" : \"0.1.0\" , \"type\" : \"Button\" , \"parentId\" : \"0.1\" , \"childIds\" : None }, { \"id\" : \"0.1.1\" , \"type\" : \"Button\" , \"parentId\" : \"0.1\" , \"childIds\" : None }, ] The to_flat_list() method on View performs this serialization iteratively using an explicit stack, avoiding Python recursion limits as well. Depth Limit \u00b6 View trees are limited to a maximum depth of 100 levels . If your tree exceeds this, Nib raises a NibDepthError : NibDepthError : View tree exceeds maximum depth of 100 ( current : 101 ). Simplify your view hierarchy or check for unintended nesting . This limit exists to protect against: Accidental infinite nesting (e.g., a view including itself). Stack overflow in the Swift runtime during rendering. Performance degradation from excessively deep layouts. In practice, menu bar app UIs rarely exceed 10-20 levels of nesting. Flattening deep hierarchies If you are dynamically generating views and hitting the depth limit, restructure your layout. Use ScrollView with a flat VStack instead of deeply nested groups. Use List for large collections instead of nesting stacks. Visibility \u00b6 Any view can be hidden by setting visible=False : error_message = nib . Text ( \"Something went wrong\" , foreground_color = nib . Color . RED , visible = False , ) def show_error (): error_message . visible = True def hide_error (): error_message . visible = False When visible=False , the view is completely removed from the serialized tree. It does not take up layout space. This is different from opacity=0 , which hides the view visually but still reserves its space in the layout. Background and Overlay Views \u00b6 Any view can have a background or overlay that is itself a view. These are serialized as separate nodes in the flat list, linked by backgroundId and overlayId : nib . VStack ( controls = [ nib . Text ( \"Content\" )], background = nib . Rectangle ( corner_radius = 12 , fill = \"#1a1a2e\" , stroke = \"#2a2a4e\" , stroke_width = 1 , ), padding = 16 , ) The background view is rendered behind the main view. The overlay view is rendered on top. Serialization Format \u00b6 Each node in the flat list contains: Field Type Description id string Position-based identifier type string SwiftUI view type name props dict View-specific properties modifiers list or null Styling modifiers parentId string or null ID of parent node childIds list or null IDs of child nodes backgroundId string or null ID of background view node overlayId string or null ID of overlay view node animationContext dict or null Per-view animation configuration","title":"The View Tree"},{"location":"concepts/view-tree/#the-view-base-class","text":"All UI elements in Nib inherit from the View base class. Each view has: A type ( _type ) -- the SwiftUI view it maps to (e.g., \"Text\" , \"VStack\" , \"Button\" ). Properties ( _get_props() ) -- view-specific data like text content, slider value, or toggle state. Modifiers ( _modifiers ) -- a list of styling instructions (padding, color, font, etc.). Children -- other views nested inside containers. An ID ( _id ) -- a position-based identifier assigned during tree traversal. import nib # A simple view tree root = nib . VStack ( controls = [ nib . Text ( \"Hello\" , font = nib . Font . TITLE ), nib . HStack ( controls = [ nib . Button ( \"OK\" , action = confirm ), nib . Button ( \"Cancel\" , action = cancel ), ], spacing = 8 , ), ], spacing = 12 , padding = 16 , ) app . build ( root )","title":"The View Base Class"},{"location":"concepts/view-tree/#view-categories","text":"Nib provides views across several categories: Controls -- Interactive and display elements: Text , Button , TextField , SecureField , Toggle , Slider , Picker , DatePicker , ColorPicker , ProgressView , Gauge , Label , Link , Image , Video , Markdown , Map , WebView , Table , TextEditor , ShareLink , CameraPreview . Layout containers -- Views that arrange children: VStack , HStack , ZStack , ScrollView , List , Section , Form , Group , Spacer , Divider , NavigationStack , NavigationLink , DisclosureGroup , Grid , LazyVGrid , LazyHGrid . Shapes -- Geometric primitives: Rectangle , Circle , Ellipse , Capsule , Path . Also gradient fills: LinearGradient , RadialGradient , AngularGradient , EllipticalGradient . Charts -- Data visualization: Chart , LineMark , BarMark , AreaMark , PointMark , RuleMark , RectMark , SectorMark . Effects -- Visual effects: VisualEffectBlur . Canvas -- Core Graphics drawing surface: Canvas with drawing commands from nib.draw .","title":"View Categories"},{"location":"concepts/view-tree/#children-controls-and-content","text":"Container views use the controls= parameter for their list of children: nib . VStack ( controls = [ nib . Text ( \"Item 1\" ), nib . Text ( \"Item 2\" ), nib . Text ( \"Item 3\" ), ], spacing = 4 , ) Single-child wrapper views (like Button , Link , Toggle ) use the content= parameter: # Button with custom content nib . Button ( content = nib . HStack ( controls = [ nib . SFSymbol ( \"star.fill\" ), nib . Text ( \"Favorite\" ), ], spacing = 4 , ), action = toggle_favorite , ) controls vs content controls= is for containers that hold multiple children (stacks, lists, grids). content= is for views that wrap a single child view. Some views like Button accept both a label string for simple cases and content for custom layouts.","title":"Children: controls= and content="},{"location":"concepts/view-tree/#position-based-ids","text":"Every view gets a position-based ID during tree traversal. The root view is \"0\" . Its first child is \"0.0\" , the second child is \"0.1\" , and so on. Nested children continue the pattern: \"0.1.2\" is the third child of the second child of the root. VStack \"0\" +-- Text \"0.0\" (\"Hello\") +-- HStack \"0.1\" +-- Button \"0.1.0\" (\"OK\") +-- Button \"0.1.1\" (\"Cancel\") These IDs serve two purposes: Stable identity -- Swift uses IDs to match old and new views during re-renders, enabling smooth transitions and state preservation. Event routing -- When Swift sends an event (e.g., a button tap), it includes the node ID so Python can look up and call the correct callback. IDs are assigned automatically by App._collect_actions() during each render. You never need to set them manually.","title":"Position-Based IDs"},{"location":"concepts/view-tree/#flat-node-serialization","text":"When the view tree is sent to Swift, it is serialized as a flat list of nodes rather than a nested tree structure. Each node carries a parentId and childIds instead of nested children. This design was chosen to prevent stack overflow in the Swift runtime when decoding deeply nested trees. # Conceptual flat node structure (internal, not user-facing) [ { \"id\" : \"0\" , \"type\" : \"VStack\" , \"parentId\" : None , \"childIds\" : [ \"0.0\" , \"0.1\" ]}, { \"id\" : \"0.0\" , \"type\" : \"Text\" , \"parentId\" : \"0\" , \"childIds\" : None }, { \"id\" : \"0.1\" , \"type\" : \"HStack\" , \"parentId\" : \"0\" , \"childIds\" : [ \"0.1.0\" , \"0.1.1\" ]}, { \"id\" : \"0.1.0\" , \"type\" : \"Button\" , \"parentId\" : \"0.1\" , \"childIds\" : None }, { \"id\" : \"0.1.1\" , \"type\" : \"Button\" , \"parentId\" : \"0.1\" , \"childIds\" : None }, ] The to_flat_list() method on View performs this serialization iteratively using an explicit stack, avoiding Python recursion limits as well.","title":"Flat Node Serialization"},{"location":"concepts/view-tree/#depth-limit","text":"View trees are limited to a maximum depth of 100 levels . If your tree exceeds this, Nib raises a NibDepthError : NibDepthError : View tree exceeds maximum depth of 100 ( current : 101 ). Simplify your view hierarchy or check for unintended nesting . This limit exists to protect against: Accidental infinite nesting (e.g., a view including itself). Stack overflow in the Swift runtime during rendering. Performance degradation from excessively deep layouts. In practice, menu bar app UIs rarely exceed 10-20 levels of nesting. Flattening deep hierarchies If you are dynamically generating views and hitting the depth limit, restructure your layout. Use ScrollView with a flat VStack instead of deeply nested groups. Use List for large collections instead of nesting stacks.","title":"Depth Limit"},{"location":"concepts/view-tree/#visibility","text":"Any view can be hidden by setting visible=False : error_message = nib . Text ( \"Something went wrong\" , foreground_color = nib . Color . RED , visible = False , ) def show_error (): error_message . visible = True def hide_error (): error_message . visible = False When visible=False , the view is completely removed from the serialized tree. It does not take up layout space. This is different from opacity=0 , which hides the view visually but still reserves its space in the layout.","title":"Visibility"},{"location":"concepts/view-tree/#background-and-overlay-views","text":"Any view can have a background or overlay that is itself a view. These are serialized as separate nodes in the flat list, linked by backgroundId and overlayId : nib . VStack ( controls = [ nib . Text ( \"Content\" )], background = nib . Rectangle ( corner_radius = 12 , fill = \"#1a1a2e\" , stroke = \"#2a2a4e\" , stroke_width = 1 , ), padding = 16 , ) The background view is rendered behind the main view. The overlay view is rendered on top.","title":"Background and Overlay Views"},{"location":"concepts/view-tree/#serialization-format","text":"Each node in the flat list contains: Field Type Description id string Position-based identifier type string SwiftUI view type name props dict View-specific properties modifiers list or null Styling modifiers parentId string or null ID of parent node childIds list or null IDs of child nodes backgroundId string or null ID of background view node overlayId string or null ID of overlay view node animationContext dict or null Per-view animation configuration","title":"Serialization Format"},{"location":"examples/","text":"Complete, runnable example applications that demonstrate how to build real menu bar apps with Nib. Each example includes full source code with a step-by-step explanation. Gallery \u00b6 Example Description Counter App A minimal counter with increment, decrement, and reset. Covers app configuration, reactive text, callbacks, context menus, and the view tree Todo App A task list with add, complete, and delete. Demonstrates TextField input, List and Section layout, Toggle for completion, and dynamic view updates System Monitor A dashboard showing battery, network, display, and thermal info. Uses multiple system services, on_appear for auto-refresh, and card-style layouts Drawing App A freehand drawing canvas with color and width selectors. Demonstrates the Canvas view, pan gesture handling, and the nib.draw module Running Examples \u00b6 All examples follow the same pattern. Save the code to a .py file and run it with: nib run your_example.py Or, for development with hot reload on file changes: nib run your_example.py -r Template \u00b6 Every Nib app follows this structure: import nib def main ( app : nib . App ): # 1. Configure the app app . title = \"My App\" app . icon = nib . SFSymbol ( \"star\" ) app . width = 300 app . height = 200 # 2. Create views label = nib . Text ( \"Hello\" ) # 3. Define callbacks def on_click (): label . content = \"Clicked!\" # 4. Build the view tree app . build ( nib . VStack ( controls = [ label , nib . Button ( \"Click\" , action = on_click )], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Index"},{"location":"examples/#gallery","text":"Example Description Counter App A minimal counter with increment, decrement, and reset. Covers app configuration, reactive text, callbacks, context menus, and the view tree Todo App A task list with add, complete, and delete. Demonstrates TextField input, List and Section layout, Toggle for completion, and dynamic view updates System Monitor A dashboard showing battery, network, display, and thermal info. Uses multiple system services, on_appear for auto-refresh, and card-style layouts Drawing App A freehand drawing canvas with color and width selectors. Demonstrates the Canvas view, pan gesture handling, and the nib.draw module","title":"Gallery"},{"location":"examples/#running-examples","text":"All examples follow the same pattern. Save the code to a .py file and run it with: nib run your_example.py Or, for development with hot reload on file changes: nib run your_example.py -r","title":"Running Examples"},{"location":"examples/#template","text":"Every Nib app follows this structure: import nib def main ( app : nib . App ): # 1. Configure the app app . title = \"My App\" app . icon = nib . SFSymbol ( \"star\" ) app . width = 300 app . height = 200 # 2. Create views label = nib . Text ( \"Hello\" ) # 3. Define callbacks def on_click (): label . content = \"Clicked!\" # 4. Build the view tree app . build ( nib . VStack ( controls = [ label , nib . Button ( \"Click\" , action = on_click )], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Template"},{"location":"examples/counter/","text":"A minimal counter application that demonstrates the fundamentals of Nib: app configuration, reactive views, callbacks, context menus, and building the view tree. Full Source \u00b6 import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number\" ) app . width = 250 app . height = 150 count = nib . Text ( \"0\" , font = nib . Font . system ( 48 , nib . FontWeight . BOLD )) def increment (): count . content = str ( int ( count . content ) + 1 ) def decrement (): val = int ( count . content ) - 1 count . content = str ( max ( 0 , val )) def reset (): count . content = \"0\" app . menu = [ nib . MenuItem ( \"Reset\" , action = reset , icon = \"arrow.counterclockwise\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] app . build ( nib . VStack ( controls = [ count , nib . HStack ( controls = [ nib . Button ( \"-\" , action = decrement , style = nib . ButtonStyle . BORDERED ), nib . Button ( \"+\" , action = increment , style = nib . ButtonStyle . BORDERED_PROMINENT ), ], spacing = 12 , ), ], spacing = 16 , padding = 24 , ) ) nib . run ( main ) Walkthrough \u00b6 Imports and entry point \u00b6 import nib The single import nib gives you access to every view, layout, type, and utility in the SDK. The nib.run(main) call at the bottom starts the app by passing your main function to the runtime. App configuration \u00b6 app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number\" ) app . width = 250 app . height = 150 These properties control the menu bar appearance and the popover window size: title sets the text shown next to the icon in the menu bar. icon accepts an SF Symbol name. Apple provides thousands of built-in icons at developer.apple.com/sf-symbols . width and height set the popover dimensions in points. Creating views \u00b6 count = nib . Text ( \"0\" , font = nib . Font . system ( 48 , nib . FontWeight . BOLD )) Views are created as Python objects. Here, nib.Text displays a string. The font parameter uses nib.Font.system() to create a system font at size 48 with bold weight. By storing the view in a variable ( count ), you can modify its properties later to trigger UI updates. Defining callbacks \u00b6 def increment (): count . content = str ( int ( count . content ) + 1 ) def decrement (): val = int ( count . content ) - 1 count . content = str ( max ( 0 , val )) def reset (): count . content = \"0\" Callbacks are plain Python functions. When a callback assigns a new value to a view property (like count.content ), Nib's reactivity system automatically diffs the view tree and sends a patch to the Swift runtime. The UI updates immediately. Note how decrement clamps the value at zero using max(0, val) . Context menu \u00b6 app . menu = [ nib . MenuItem ( \"Reset\" , action = reset , icon = \"arrow.counterclockwise\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] The app.menu property defines the right-click context menu on the status bar icon. Each MenuItem takes a label, an optional callback, an optional SF Symbol icon, and an optional keyboard shortcut. MenuDivider adds a visual separator. Building the view tree \u00b6 app . build ( nib . VStack ( controls = [ count , nib . HStack ( controls = [ nib . Button ( \"-\" , action = decrement , style = nib . ButtonStyle . BORDERED ), nib . Button ( \"+\" , action = increment , style = nib . ButtonStyle . BORDERED_PROMINENT ), ], spacing = 12 , ), ], spacing = 16 , padding = 24 , ) ) app.build() sets the root view. The tree is composed of nested layout containers: VStack arranges children vertically. The controls list contains the count text and a nested HStack . HStack arranges the two buttons horizontally. spacing sets the gap between children in points. padding adds space around the entire stack. ButtonStyle.BORDERED gives a subtle outline; ButtonStyle.BORDERED_PROMINENT gives a filled, accented appearance. Running the app \u00b6 nib . run ( main ) This is the entry point. It creates an App instance, passes it to your main function, and starts the event loop. The app appears in the menu bar and opens a popover when clicked. nib run counter.py","title":"Counter App"},{"location":"examples/counter/#full-source","text":"import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number\" ) app . width = 250 app . height = 150 count = nib . Text ( \"0\" , font = nib . Font . system ( 48 , nib . FontWeight . BOLD )) def increment (): count . content = str ( int ( count . content ) + 1 ) def decrement (): val = int ( count . content ) - 1 count . content = str ( max ( 0 , val )) def reset (): count . content = \"0\" app . menu = [ nib . MenuItem ( \"Reset\" , action = reset , icon = \"arrow.counterclockwise\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] app . build ( nib . VStack ( controls = [ count , nib . HStack ( controls = [ nib . Button ( \"-\" , action = decrement , style = nib . ButtonStyle . BORDERED ), nib . Button ( \"+\" , action = increment , style = nib . ButtonStyle . BORDERED_PROMINENT ), ], spacing = 12 , ), ], spacing = 16 , padding = 24 , ) ) nib . run ( main )","title":"Full Source"},{"location":"examples/counter/#walkthrough","text":"","title":"Walkthrough"},{"location":"examples/counter/#imports-and-entry-point","text":"import nib The single import nib gives you access to every view, layout, type, and utility in the SDK. The nib.run(main) call at the bottom starts the app by passing your main function to the runtime.","title":"Imports and entry point"},{"location":"examples/counter/#app-configuration","text":"app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number\" ) app . width = 250 app . height = 150 These properties control the menu bar appearance and the popover window size: title sets the text shown next to the icon in the menu bar. icon accepts an SF Symbol name. Apple provides thousands of built-in icons at developer.apple.com/sf-symbols . width and height set the popover dimensions in points.","title":"App configuration"},{"location":"examples/counter/#creating-views","text":"count = nib . Text ( \"0\" , font = nib . Font . system ( 48 , nib . FontWeight . BOLD )) Views are created as Python objects. Here, nib.Text displays a string. The font parameter uses nib.Font.system() to create a system font at size 48 with bold weight. By storing the view in a variable ( count ), you can modify its properties later to trigger UI updates.","title":"Creating views"},{"location":"examples/counter/#defining-callbacks","text":"def increment (): count . content = str ( int ( count . content ) + 1 ) def decrement (): val = int ( count . content ) - 1 count . content = str ( max ( 0 , val )) def reset (): count . content = \"0\" Callbacks are plain Python functions. When a callback assigns a new value to a view property (like count.content ), Nib's reactivity system automatically diffs the view tree and sends a patch to the Swift runtime. The UI updates immediately. Note how decrement clamps the value at zero using max(0, val) .","title":"Defining callbacks"},{"location":"examples/counter/#context-menu","text":"app . menu = [ nib . MenuItem ( \"Reset\" , action = reset , icon = \"arrow.counterclockwise\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] The app.menu property defines the right-click context menu on the status bar icon. Each MenuItem takes a label, an optional callback, an optional SF Symbol icon, and an optional keyboard shortcut. MenuDivider adds a visual separator.","title":"Context menu"},{"location":"examples/counter/#building-the-view-tree","text":"app . build ( nib . VStack ( controls = [ count , nib . HStack ( controls = [ nib . Button ( \"-\" , action = decrement , style = nib . ButtonStyle . BORDERED ), nib . Button ( \"+\" , action = increment , style = nib . ButtonStyle . BORDERED_PROMINENT ), ], spacing = 12 , ), ], spacing = 16 , padding = 24 , ) ) app.build() sets the root view. The tree is composed of nested layout containers: VStack arranges children vertically. The controls list contains the count text and a nested HStack . HStack arranges the two buttons horizontally. spacing sets the gap between children in points. padding adds space around the entire stack. ButtonStyle.BORDERED gives a subtle outline; ButtonStyle.BORDERED_PROMINENT gives a filled, accented appearance.","title":"Building the view tree"},{"location":"examples/counter/#running-the-app","text":"nib . run ( main ) This is the entry point. It creates an App instance, passes it to your main function, and starts the event loop. The app appears in the menu bar and opens a popover when clicked. nib run counter.py","title":"Running the app"},{"location":"examples/drawing-app/","text":"A freehand drawing application using the Canvas view with pan gesture handling. Demonstrates how to draw lines on a canvas, change stroke color and width, and clear the drawing. Full Source \u00b6 import nib def main ( app : nib . App ): app . title = \"Draw\" app . icon = nib . SFSymbol ( \"pencil.tip\" ) app . width = 440 app . height = 380 # Canvas with gesture support canvas = nib . Canvas ( width = 420 , height = 300 , background_color = \"#FFFFFF\" , enable_gestures = True , ) # Drawing state last_x = 0.0 last_y = 0.0 stroke_color = \"#000000\" stroke_width = 3 def on_pan_start ( e : nib . PanEvent ): nonlocal last_x , last_y last_x = e . x last_y = e . y def on_pan_update ( e : nib . PanEvent ): nonlocal last_x , last_y canvas . append ( nib . draw . Line ( x1 = last_x , y1 = last_y , x2 = e . x , y2 = e . y , stroke = stroke_color , stroke_width = stroke_width , line_cap = \"round\" , ) ) last_x = e . x last_y = e . y canvas . on_pan_start = on_pan_start canvas . on_pan_update = on_pan_update # Clear canvas def clear_canvas (): canvas . clear () # Color selectors def set_black (): nonlocal stroke_color stroke_color = \"#000000\" def set_red (): nonlocal stroke_color stroke_color = \"#e74c3c\" def set_blue (): nonlocal stroke_color stroke_color = \"#3498db\" def set_green (): nonlocal stroke_color stroke_color = \"#2ecc71\" # Width selectors def set_thin (): nonlocal stroke_width stroke_width = 2 def set_medium (): nonlocal stroke_width stroke_width = 5 def set_thick (): nonlocal stroke_width stroke_width = 10 app . build ( nib . VStack ( controls = [ # Toolbar nib . HStack ( controls = [ nib . Button ( \"Clear\" , action = clear_canvas ), nib . Spacer (), nib . Text ( \"Color:\" , font = nib . Font . CAPTION ), nib . Button ( \"Black\" , action = set_black ), nib . Button ( \"Red\" , action = set_red ), nib . Button ( \"Blue\" , action = set_blue ), nib . Button ( \"Green\" , action = set_green ), nib . Spacer (), nib . Text ( \"Width:\" , font = nib . Font . CAPTION ), nib . Button ( \"Thin\" , action = set_thin ), nib . Button ( \"Med\" , action = set_medium ), nib . Button ( \"Thick\" , action = set_thick ), ], spacing = 4 , ), # Canvas with border nib . VStack ( controls = [ canvas ], background = nib . Rectangle ( corner_radius = 5 , stroke = \"#cccccc\" , stroke_width = 1 , ), ), ], spacing = 10 , padding = 10 , ) ) nib . run ( main ) Walkthrough \u00b6 Creating a Canvas \u00b6 canvas = nib . Canvas ( width = 420 , height = 300 , background_color = \"#FFFFFF\" , enable_gestures = True , ) The Canvas view provides a Core Graphics-backed drawing surface. Key parameters: Parameter Description width , height Canvas dimensions in points background_color Fill color for the canvas background enable_gestures When True , the canvas emits pan (drag) events Gesture handling \u00b6 def on_pan_start ( e : nib . PanEvent ): nonlocal last_x , last_y last_x = e . x last_y = e . y def on_pan_update ( e : nib . PanEvent ): nonlocal last_x , last_y canvas . append ( nib . draw . Line ( x1 = last_x , y1 = last_y , x2 = e . x , y2 = e . y , stroke = stroke_color , stroke_width = stroke_width , line_cap = \"round\" , ) ) last_x = e . x last_y = e . y canvas . on_pan_start = on_pan_start canvas . on_pan_update = on_pan_update The canvas fires gesture callbacks: on_pan_start -- Called when the user begins a drag. Records the starting position. on_pan_update -- Called continuously as the user drags. Draws a line segment from the previous position to the current position. The PanEvent object provides x and y coordinates relative to the canvas origin. Drawing commands \u00b6 canvas . append ( nib . draw . Line ( x1 = last_x , y1 = last_y , x2 = e . x , y2 = e . y , stroke = stroke_color , stroke_width = stroke_width , line_cap = \"round\" , ) ) The nib.draw module provides drawing primitives that can be appended to a canvas: nib.draw.Line -- A line segment between two points nib.draw.Rect -- A rectangle nib.draw.Circle -- A circle nib.draw.Path -- A custom path with arcs, curves, and lines nib.draw.Text -- Text rendered at a position canvas.append() adds a drawing command incrementally. The Swift runtime renders it immediately without redrawing existing commands. canvas.clear() removes all drawing commands and resets the canvas. Using line_cap=\"round\" \u00b6 The line_cap parameter controls how line endpoints are drawn: \"round\" -- Rounded endpoints (smooth freehand look) \"square\" -- Square endpoints extending beyond the endpoint \"butt\" -- Flat endpoints exactly at the endpoint (default) For freehand drawing, \"round\" produces smooth joins between consecutive line segments. Toolbar layout \u00b6 The toolbar is an HStack with buttons and Spacer views: nib . HStack ( controls = [ nib . Button ( \"Clear\" , action = clear_canvas ), nib . Spacer (), nib . Text ( \"Color:\" , font = nib . Font . CAPTION ), nib . Button ( \"Black\" , action = set_black ), ... nib . Spacer (), nib . Text ( \"Width:\" , font = nib . Font . CAPTION ), nib . Button ( \"Thin\" , action = set_thin ), ... ], spacing = 4 , ) Spacer pushes adjacent views apart, distributing the toolbar into three groups: the clear button on the left, color buttons in the middle, and width buttons on the right. Drawing state \u00b6 stroke_color = \"#000000\" stroke_width = 3 Drawing settings are stored as plain Python variables. The color and width selector buttons update these variables via nonlocal . The next stroke drawn will use the new values. Previously drawn lines are not affected. Canvas border \u00b6 nib . VStack ( controls = [ canvas ], background = nib . Rectangle ( corner_radius = 5 , stroke = \"#cccccc\" , stroke_width = 1 , ), ) The canvas is wrapped in a VStack with a Rectangle background that provides a subtle border. The stroke parameter draws an outline, while corner_radius rounds the corners. Running \u00b6 nib run drawing_app.py","title":"Drawing App"},{"location":"examples/drawing-app/#full-source","text":"import nib def main ( app : nib . App ): app . title = \"Draw\" app . icon = nib . SFSymbol ( \"pencil.tip\" ) app . width = 440 app . height = 380 # Canvas with gesture support canvas = nib . Canvas ( width = 420 , height = 300 , background_color = \"#FFFFFF\" , enable_gestures = True , ) # Drawing state last_x = 0.0 last_y = 0.0 stroke_color = \"#000000\" stroke_width = 3 def on_pan_start ( e : nib . PanEvent ): nonlocal last_x , last_y last_x = e . x last_y = e . y def on_pan_update ( e : nib . PanEvent ): nonlocal last_x , last_y canvas . append ( nib . draw . Line ( x1 = last_x , y1 = last_y , x2 = e . x , y2 = e . y , stroke = stroke_color , stroke_width = stroke_width , line_cap = \"round\" , ) ) last_x = e . x last_y = e . y canvas . on_pan_start = on_pan_start canvas . on_pan_update = on_pan_update # Clear canvas def clear_canvas (): canvas . clear () # Color selectors def set_black (): nonlocal stroke_color stroke_color = \"#000000\" def set_red (): nonlocal stroke_color stroke_color = \"#e74c3c\" def set_blue (): nonlocal stroke_color stroke_color = \"#3498db\" def set_green (): nonlocal stroke_color stroke_color = \"#2ecc71\" # Width selectors def set_thin (): nonlocal stroke_width stroke_width = 2 def set_medium (): nonlocal stroke_width stroke_width = 5 def set_thick (): nonlocal stroke_width stroke_width = 10 app . build ( nib . VStack ( controls = [ # Toolbar nib . HStack ( controls = [ nib . Button ( \"Clear\" , action = clear_canvas ), nib . Spacer (), nib . Text ( \"Color:\" , font = nib . Font . CAPTION ), nib . Button ( \"Black\" , action = set_black ), nib . Button ( \"Red\" , action = set_red ), nib . Button ( \"Blue\" , action = set_blue ), nib . Button ( \"Green\" , action = set_green ), nib . Spacer (), nib . Text ( \"Width:\" , font = nib . Font . CAPTION ), nib . Button ( \"Thin\" , action = set_thin ), nib . Button ( \"Med\" , action = set_medium ), nib . Button ( \"Thick\" , action = set_thick ), ], spacing = 4 , ), # Canvas with border nib . VStack ( controls = [ canvas ], background = nib . Rectangle ( corner_radius = 5 , stroke = \"#cccccc\" , stroke_width = 1 , ), ), ], spacing = 10 , padding = 10 , ) ) nib . run ( main )","title":"Full Source"},{"location":"examples/drawing-app/#walkthrough","text":"","title":"Walkthrough"},{"location":"examples/drawing-app/#creating-a-canvas","text":"canvas = nib . Canvas ( width = 420 , height = 300 , background_color = \"#FFFFFF\" , enable_gestures = True , ) The Canvas view provides a Core Graphics-backed drawing surface. Key parameters: Parameter Description width , height Canvas dimensions in points background_color Fill color for the canvas background enable_gestures When True , the canvas emits pan (drag) events","title":"Creating a Canvas"},{"location":"examples/drawing-app/#gesture-handling","text":"def on_pan_start ( e : nib . PanEvent ): nonlocal last_x , last_y last_x = e . x last_y = e . y def on_pan_update ( e : nib . PanEvent ): nonlocal last_x , last_y canvas . append ( nib . draw . Line ( x1 = last_x , y1 = last_y , x2 = e . x , y2 = e . y , stroke = stroke_color , stroke_width = stroke_width , line_cap = \"round\" , ) ) last_x = e . x last_y = e . y canvas . on_pan_start = on_pan_start canvas . on_pan_update = on_pan_update The canvas fires gesture callbacks: on_pan_start -- Called when the user begins a drag. Records the starting position. on_pan_update -- Called continuously as the user drags. Draws a line segment from the previous position to the current position. The PanEvent object provides x and y coordinates relative to the canvas origin.","title":"Gesture handling"},{"location":"examples/drawing-app/#drawing-commands","text":"canvas . append ( nib . draw . Line ( x1 = last_x , y1 = last_y , x2 = e . x , y2 = e . y , stroke = stroke_color , stroke_width = stroke_width , line_cap = \"round\" , ) ) The nib.draw module provides drawing primitives that can be appended to a canvas: nib.draw.Line -- A line segment between two points nib.draw.Rect -- A rectangle nib.draw.Circle -- A circle nib.draw.Path -- A custom path with arcs, curves, and lines nib.draw.Text -- Text rendered at a position canvas.append() adds a drawing command incrementally. The Swift runtime renders it immediately without redrawing existing commands. canvas.clear() removes all drawing commands and resets the canvas.","title":"Drawing commands"},{"location":"examples/drawing-app/#using-line_capround","text":"The line_cap parameter controls how line endpoints are drawn: \"round\" -- Rounded endpoints (smooth freehand look) \"square\" -- Square endpoints extending beyond the endpoint \"butt\" -- Flat endpoints exactly at the endpoint (default) For freehand drawing, \"round\" produces smooth joins between consecutive line segments.","title":"Using line_cap=\"round\""},{"location":"examples/drawing-app/#toolbar-layout","text":"The toolbar is an HStack with buttons and Spacer views: nib . HStack ( controls = [ nib . Button ( \"Clear\" , action = clear_canvas ), nib . Spacer (), nib . Text ( \"Color:\" , font = nib . Font . CAPTION ), nib . Button ( \"Black\" , action = set_black ), ... nib . Spacer (), nib . Text ( \"Width:\" , font = nib . Font . CAPTION ), nib . Button ( \"Thin\" , action = set_thin ), ... ], spacing = 4 , ) Spacer pushes adjacent views apart, distributing the toolbar into three groups: the clear button on the left, color buttons in the middle, and width buttons on the right.","title":"Toolbar layout"},{"location":"examples/drawing-app/#drawing-state","text":"stroke_color = \"#000000\" stroke_width = 3 Drawing settings are stored as plain Python variables. The color and width selector buttons update these variables via nonlocal . The next stroke drawn will use the new values. Previously drawn lines are not affected.","title":"Drawing state"},{"location":"examples/drawing-app/#canvas-border","text":"nib . VStack ( controls = [ canvas ], background = nib . Rectangle ( corner_radius = 5 , stroke = \"#cccccc\" , stroke_width = 1 , ), ) The canvas is wrapped in a VStack with a Rectangle background that provides a subtle border. The stroke parameter draws an outline, while corner_radius rounds the corners.","title":"Canvas border"},{"location":"examples/drawing-app/#running","text":"nib run drawing_app.py","title":"Running"},{"location":"examples/system-monitor/","text":"A dashboard application that displays battery, network, display, and thermal information using Nib's system services. Demonstrates on_appear for automatic data refresh, card-style layouts, and conditional styling. Full Source \u00b6 import nib from nib.services.battery import ThermalState def main ( app : nib . App ): app . title = \"System Info\" app . icon = nib . SFSymbol ( \"info.circle.fill\" ) app . width = 360 app . height = 520 # Theme colors card_bg = \"#1C1C1E\" text_secondary = \"#8E8E93\" green = \"#30D158\" blue = \"#0A84FF\" orange = \"#FF9F0A\" red = \"#FF453A\" # \u2500\u2500 Helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def make_card ( title , * controls ): return nib . VStack ( controls = [ nib . Text ( title , font = nib . Font . CAPTION , foreground_color = text_secondary ), * controls , ], alignment = nib . HorizontalAlignment . LEADING , spacing = 8 , padding = 12 , background = nib . Rectangle ( corner_radius = 10 , fill = card_bg , opacity = 0.6 ), ) def make_row ( icon , label , value_view , icon_color = None ): return nib . HStack ( controls = [ nib . SFSymbol ( icon , font = nib . Font . system ( 14 ), foreground_color = icon_color or text_secondary ), nib . Text ( label , foreground_color = text_secondary ), nib . Spacer (), value_view , ], spacing = 8 , ) # \u2500\u2500 Battery \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 battery_level = nib . Text ( \"--\" , font = nib . Font . system ( 24 , weight = nib . FontWeight . BOLD )) battery_state = nib . Text ( \"--\" , font = nib . Font . CAPTION , foreground_color = text_secondary ) battery_time = nib . Text ( \"\" , font = nib . Font . CAPTION , foreground_color = text_secondary ) def refresh_battery (): try : info = app . battery . get_status () if info . has_battery and info . level is not None : battery_level . content = f \" { info . level : .0f } %\" if info . level >= 50 : battery_level . foreground_color = green elif info . level >= 20 : battery_level . foreground_color = orange else : battery_level . foreground_color = red battery_state . content = info . state . value . replace ( \"_\" , \" \" ) . title () if info . is_charging and info . time_to_full_formatted : battery_time . content = f \"Full in { info . time_to_full_formatted } \" elif info . time_remaining_formatted : battery_time . content = f \" { info . time_remaining_formatted } remaining\" else : battery_time . content = \"\" else : battery_level . content = \"AC\" battery_level . foreground_color = blue battery_state . content = \"No Battery\" except Exception : battery_level . content = \"N/A\" battery_card = make_card ( \"BATTERY\" , nib . HStack ( controls = [ nib . VStack ( controls = [ battery_level , battery_state ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), nib . Spacer (), battery_time , ], ), ) # \u2500\u2500 Battery Health \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 health_pct = nib . Text ( \"--\" , font = nib . Font . system ( 18 , weight = nib . FontWeight . SEMIBOLD )) health_cycles = nib . Text ( \"--\" , foreground_color = text_secondary ) health_temp = nib . Text ( \"--\" , foreground_color = text_secondary ) health_cond = nib . Text ( \"--\" , foreground_color = text_secondary ) def refresh_health (): try : h = app . battery . get_health () if h . health_percent is not None : health_pct . content = f \" { h . health_percent : .0f } %\" health_pct . foreground_color = green if h . health_percent >= 80 else orange health_cycles . content = f \" { h . cycle_count } cycles\" if h . cycle_count else \"N/A\" health_temp . content = f \" { h . temperature_celsius : .1f } C\" if h . temperature_celsius else \"N/A\" health_cond . content = h . condition or \"N/A\" except Exception : health_pct . content = \"N/A\" health_card = make_card ( \"BATTERY HEALTH\" , make_row ( \"heart.fill\" , \"Health\" , health_pct , green ), make_row ( \"arrow.triangle.2.circlepath\" , \"Cycles\" , health_cycles ), make_row ( \"thermometer\" , \"Temp\" , health_temp ), make_row ( \"checkmark.shield\" , \"Condition\" , health_cond ), ) # \u2500\u2500 Thermal \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 thermal_text = nib . Text ( \"--\" , font = nib . Font . system ( 16 , weight = nib . FontWeight . SEMIBOLD )) def refresh_thermal (): try : t = app . battery . get_thermal_state () thermal_text . content = t . state . value . title () if t . state == ThermalState . NOMINAL : thermal_text . foreground_color = green elif t . state == ThermalState . FAIR : thermal_text . foreground_color = orange else : thermal_text . foreground_color = red except Exception : thermal_text . content = \"N/A\" thermal_card = make_card ( \"THERMAL\" , thermal_text ) # \u2500\u2500 Display \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 display_name = nib . Text ( \"--\" , font = nib . Font . system ( 14 , weight = nib . FontWeight . SEMIBOLD )) display_res = nib . Text ( \"--\" , foreground_color = text_secondary ) display_bright = nib . Text ( \"--\" , foreground_color = text_secondary ) display_refresh = nib . Text ( \"--\" , foreground_color = text_secondary ) def refresh_display (): try : info = app . screen . get_info () display_name . content = info . name or \"Display\" display_res . content = f \" { info . width : .0f } x { info . height : .0f } @ { info . scale : .0f } x\" display_bright . content = ( f \" { info . brightness * 100 : .0f } %\" if info . brightness is not None else \"N/A\" ) display_refresh . content = ( f \" { info . refresh_rate : .0f } Hz\" if info . refresh_rate else \"N/A\" ) except Exception : display_name . content = \"N/A\" display_card = make_card ( \"DISPLAY\" , display_name , make_row ( \"rectangle.on.rectangle\" , \"Resolution\" , display_res ), make_row ( \"sun.max\" , \"Brightness\" , display_bright , orange ), make_row ( \"speedometer\" , \"Refresh\" , display_refresh ), ) # \u2500\u2500 Network \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 net_status = nib . Text ( \"--\" , font = nib . Font . system ( 16 , weight = nib . FontWeight . SEMIBOLD )) net_type = nib . Text ( \"--\" , foreground_color = text_secondary ) net_ssid = nib . Text ( \"\" , foreground_color = text_secondary ) def refresh_network (): try : info = app . connectivity . get_status () if info . is_connected : net_status . content = \"Connected\" net_status . foreground_color = green net_type . content = info . type . value . title () net_ssid . content = info . ssid or \"\" else : net_status . content = \"Offline\" net_status . foreground_color = red net_type . content = \"No Connection\" net_ssid . content = \"\" except Exception : net_status . content = \"N/A\" network_card = make_card ( \"NETWORK\" , nib . HStack ( controls = [ net_status , nib . Spacer (), net_type ], spacing = 8 ), net_ssid , ) # \u2500\u2500 Refresh All \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def refresh_all (): refresh_battery () refresh_health () refresh_thermal () refresh_display () refresh_network () app . on_appear = refresh_all # \u2500\u2500 Build \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 app . build ( nib . ScrollView ( controls = [ nib . VStack ( controls = [ battery_card , health_card , thermal_card , display_card , network_card , nib . Button ( \"Refresh All\" , action = refresh_all , style = nib . ButtonStyle . BORDERED , ), ], spacing = 10 , padding = 12 , ), ], ) ) nib . run ( main ) Walkthrough \u00b6 Using system services \u00b6 Each card fetches data from a different system service: Card Service Method Battery app.battery get_status() Battery Health app.battery get_health() Thermal app.battery get_thermal_state() Display app.screen get_info() Network app.connectivity get_status() Services are synchronous -- call the method and use the result immediately: info = app . battery . get_status () battery_level . content = f \" { info . level : .0f } %\" Refreshing on popover open \u00b6 app . on_appear = refresh_all The on_appear callback fires every time the popover opens. This ensures data is fresh each time the user clicks the menu bar icon, without polling in the background. Card layout pattern \u00b6 The make_card helper creates a consistent card style: def make_card ( title , * controls ): return nib . VStack ( controls = [ nib . Text ( title , font = nib . Font . CAPTION , foreground_color = text_secondary ), * controls , ], alignment = nib . HorizontalAlignment . LEADING , spacing = 8 , padding = 12 , background = nib . Rectangle ( corner_radius = 10 , fill = card_bg , opacity = 0.6 ), ) The background modifier accepts a shape view ( Rectangle , Circle , etc.) to draw behind the content. Using corner_radius and a dark fill creates the card appearance. Conditional styling \u00b6 The battery level color changes based on the value: if info . level >= 50 : battery_level . foreground_color = green elif info . level >= 20 : battery_level . foreground_color = orange else : battery_level . foreground_color = red Assigning foreground_color triggers a UI patch, so the color updates immediately without rebuilding the entire view tree. Error handling \u00b6 Each refresh function wraps the service call in a try/except block: try : info = app . battery . get_status () # ... update views except Exception : battery_level . content = \"N/A\" This prevents a service timeout or unavailable hardware (e.g., no battery on a desktop Mac) from crashing the app. Running \u00b6 nib run system_monitor.py","title":"System Monitor"},{"location":"examples/system-monitor/#full-source","text":"import nib from nib.services.battery import ThermalState def main ( app : nib . App ): app . title = \"System Info\" app . icon = nib . SFSymbol ( \"info.circle.fill\" ) app . width = 360 app . height = 520 # Theme colors card_bg = \"#1C1C1E\" text_secondary = \"#8E8E93\" green = \"#30D158\" blue = \"#0A84FF\" orange = \"#FF9F0A\" red = \"#FF453A\" # \u2500\u2500 Helpers \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def make_card ( title , * controls ): return nib . VStack ( controls = [ nib . Text ( title , font = nib . Font . CAPTION , foreground_color = text_secondary ), * controls , ], alignment = nib . HorizontalAlignment . LEADING , spacing = 8 , padding = 12 , background = nib . Rectangle ( corner_radius = 10 , fill = card_bg , opacity = 0.6 ), ) def make_row ( icon , label , value_view , icon_color = None ): return nib . HStack ( controls = [ nib . SFSymbol ( icon , font = nib . Font . system ( 14 ), foreground_color = icon_color or text_secondary ), nib . Text ( label , foreground_color = text_secondary ), nib . Spacer (), value_view , ], spacing = 8 , ) # \u2500\u2500 Battery \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 battery_level = nib . Text ( \"--\" , font = nib . Font . system ( 24 , weight = nib . FontWeight . BOLD )) battery_state = nib . Text ( \"--\" , font = nib . Font . CAPTION , foreground_color = text_secondary ) battery_time = nib . Text ( \"\" , font = nib . Font . CAPTION , foreground_color = text_secondary ) def refresh_battery (): try : info = app . battery . get_status () if info . has_battery and info . level is not None : battery_level . content = f \" { info . level : .0f } %\" if info . level >= 50 : battery_level . foreground_color = green elif info . level >= 20 : battery_level . foreground_color = orange else : battery_level . foreground_color = red battery_state . content = info . state . value . replace ( \"_\" , \" \" ) . title () if info . is_charging and info . time_to_full_formatted : battery_time . content = f \"Full in { info . time_to_full_formatted } \" elif info . time_remaining_formatted : battery_time . content = f \" { info . time_remaining_formatted } remaining\" else : battery_time . content = \"\" else : battery_level . content = \"AC\" battery_level . foreground_color = blue battery_state . content = \"No Battery\" except Exception : battery_level . content = \"N/A\" battery_card = make_card ( \"BATTERY\" , nib . HStack ( controls = [ nib . VStack ( controls = [ battery_level , battery_state ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), nib . Spacer (), battery_time , ], ), ) # \u2500\u2500 Battery Health \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 health_pct = nib . Text ( \"--\" , font = nib . Font . system ( 18 , weight = nib . FontWeight . SEMIBOLD )) health_cycles = nib . Text ( \"--\" , foreground_color = text_secondary ) health_temp = nib . Text ( \"--\" , foreground_color = text_secondary ) health_cond = nib . Text ( \"--\" , foreground_color = text_secondary ) def refresh_health (): try : h = app . battery . get_health () if h . health_percent is not None : health_pct . content = f \" { h . health_percent : .0f } %\" health_pct . foreground_color = green if h . health_percent >= 80 else orange health_cycles . content = f \" { h . cycle_count } cycles\" if h . cycle_count else \"N/A\" health_temp . content = f \" { h . temperature_celsius : .1f } C\" if h . temperature_celsius else \"N/A\" health_cond . content = h . condition or \"N/A\" except Exception : health_pct . content = \"N/A\" health_card = make_card ( \"BATTERY HEALTH\" , make_row ( \"heart.fill\" , \"Health\" , health_pct , green ), make_row ( \"arrow.triangle.2.circlepath\" , \"Cycles\" , health_cycles ), make_row ( \"thermometer\" , \"Temp\" , health_temp ), make_row ( \"checkmark.shield\" , \"Condition\" , health_cond ), ) # \u2500\u2500 Thermal \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 thermal_text = nib . Text ( \"--\" , font = nib . Font . system ( 16 , weight = nib . FontWeight . SEMIBOLD )) def refresh_thermal (): try : t = app . battery . get_thermal_state () thermal_text . content = t . state . value . title () if t . state == ThermalState . NOMINAL : thermal_text . foreground_color = green elif t . state == ThermalState . FAIR : thermal_text . foreground_color = orange else : thermal_text . foreground_color = red except Exception : thermal_text . content = \"N/A\" thermal_card = make_card ( \"THERMAL\" , thermal_text ) # \u2500\u2500 Display \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 display_name = nib . Text ( \"--\" , font = nib . Font . system ( 14 , weight = nib . FontWeight . SEMIBOLD )) display_res = nib . Text ( \"--\" , foreground_color = text_secondary ) display_bright = nib . Text ( \"--\" , foreground_color = text_secondary ) display_refresh = nib . Text ( \"--\" , foreground_color = text_secondary ) def refresh_display (): try : info = app . screen . get_info () display_name . content = info . name or \"Display\" display_res . content = f \" { info . width : .0f } x { info . height : .0f } @ { info . scale : .0f } x\" display_bright . content = ( f \" { info . brightness * 100 : .0f } %\" if info . brightness is not None else \"N/A\" ) display_refresh . content = ( f \" { info . refresh_rate : .0f } Hz\" if info . refresh_rate else \"N/A\" ) except Exception : display_name . content = \"N/A\" display_card = make_card ( \"DISPLAY\" , display_name , make_row ( \"rectangle.on.rectangle\" , \"Resolution\" , display_res ), make_row ( \"sun.max\" , \"Brightness\" , display_bright , orange ), make_row ( \"speedometer\" , \"Refresh\" , display_refresh ), ) # \u2500\u2500 Network \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 net_status = nib . Text ( \"--\" , font = nib . Font . system ( 16 , weight = nib . FontWeight . SEMIBOLD )) net_type = nib . Text ( \"--\" , foreground_color = text_secondary ) net_ssid = nib . Text ( \"\" , foreground_color = text_secondary ) def refresh_network (): try : info = app . connectivity . get_status () if info . is_connected : net_status . content = \"Connected\" net_status . foreground_color = green net_type . content = info . type . value . title () net_ssid . content = info . ssid or \"\" else : net_status . content = \"Offline\" net_status . foreground_color = red net_type . content = \"No Connection\" net_ssid . content = \"\" except Exception : net_status . content = \"N/A\" network_card = make_card ( \"NETWORK\" , nib . HStack ( controls = [ net_status , nib . Spacer (), net_type ], spacing = 8 ), net_ssid , ) # \u2500\u2500 Refresh All \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 def refresh_all (): refresh_battery () refresh_health () refresh_thermal () refresh_display () refresh_network () app . on_appear = refresh_all # \u2500\u2500 Build \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 app . build ( nib . ScrollView ( controls = [ nib . VStack ( controls = [ battery_card , health_card , thermal_card , display_card , network_card , nib . Button ( \"Refresh All\" , action = refresh_all , style = nib . ButtonStyle . BORDERED , ), ], spacing = 10 , padding = 12 , ), ], ) ) nib . run ( main )","title":"Full Source"},{"location":"examples/system-monitor/#walkthrough","text":"","title":"Walkthrough"},{"location":"examples/system-monitor/#using-system-services","text":"Each card fetches data from a different system service: Card Service Method Battery app.battery get_status() Battery Health app.battery get_health() Thermal app.battery get_thermal_state() Display app.screen get_info() Network app.connectivity get_status() Services are synchronous -- call the method and use the result immediately: info = app . battery . get_status () battery_level . content = f \" { info . level : .0f } %\"","title":"Using system services"},{"location":"examples/system-monitor/#refreshing-on-popover-open","text":"app . on_appear = refresh_all The on_appear callback fires every time the popover opens. This ensures data is fresh each time the user clicks the menu bar icon, without polling in the background.","title":"Refreshing on popover open"},{"location":"examples/system-monitor/#card-layout-pattern","text":"The make_card helper creates a consistent card style: def make_card ( title , * controls ): return nib . VStack ( controls = [ nib . Text ( title , font = nib . Font . CAPTION , foreground_color = text_secondary ), * controls , ], alignment = nib . HorizontalAlignment . LEADING , spacing = 8 , padding = 12 , background = nib . Rectangle ( corner_radius = 10 , fill = card_bg , opacity = 0.6 ), ) The background modifier accepts a shape view ( Rectangle , Circle , etc.) to draw behind the content. Using corner_radius and a dark fill creates the card appearance.","title":"Card layout pattern"},{"location":"examples/system-monitor/#conditional-styling","text":"The battery level color changes based on the value: if info . level >= 50 : battery_level . foreground_color = green elif info . level >= 20 : battery_level . foreground_color = orange else : battery_level . foreground_color = red Assigning foreground_color triggers a UI patch, so the color updates immediately without rebuilding the entire view tree.","title":"Conditional styling"},{"location":"examples/system-monitor/#error-handling","text":"Each refresh function wraps the service call in a try/except block: try : info = app . battery . get_status () # ... update views except Exception : battery_level . content = \"N/A\" This prevents a service timeout or unavailable hardware (e.g., no battery on a desktop Mac) from crashing the app.","title":"Error handling"},{"location":"examples/system-monitor/#running","text":"nib run system_monitor.py","title":"Running"},{"location":"examples/todo/","text":"A task list application that demonstrates text input, dynamic list rendering, toggles for marking tasks complete, and deleting items from the view tree. Full Source \u00b6 import nib def main ( app : nib . App ): app . title = \"Todo\" app . icon = nib . SFSymbol ( \"checklist\" ) app . width = 340 app . height = 450 # State todos = [] # list of {\"text\": str, \"done\": bool, \"views\": dict} todo_section = nib . Section ( header = \"Tasks\" , controls = []) done_section = nib . Section ( header = \"Completed\" , controls = []) input_field = nib . TextField ( placeholder = \"What needs to be done?\" , on_submit = lambda _ : add_todo ()) def rebuild_lists (): \"\"\"Rebuild both sections from the todos list.\"\"\" pending = [ t for t in todos if not t [ \"done\" ]] completed = [ t for t in todos if t [ \"done\" ]] todo_section . controls = [ make_row ( t ) for t in pending ] done_section . controls = [ make_row ( t ) for t in completed ] def make_row ( todo ): \"\"\"Create a view row for a single todo item.\"\"\" def toggle_done ( is_on ): todo [ \"done\" ] = is_on rebuild_lists () def delete (): todos . remove ( todo ) rebuild_lists () return nib . HStack ( controls = [ nib . Toggle ( is_on = todo [ \"done\" ], label = \"\" , on_change = toggle_done , ), nib . Text ( todo [ \"text\" ], foreground_color = nib . Color . SECONDARY if todo [ \"done\" ] else nib . Color . PRIMARY , ), nib . Spacer (), nib . Button ( icon = \"trash\" , action = delete , role = nib . ButtonRole . DESTRUCTIVE , style = nib . ButtonStyle . BORDERLESS , ), ], spacing = 8 , ) def add_todo (): text = input_field . text . strip () if text : todos . append ({ \"text\" : text , \"done\" : False }) input_field . text = \"\" rebuild_lists () def clear_completed (): nonlocal todos todos = [ t for t in todos if not t [ \"done\" ]] rebuild_lists () # Context menu app . menu = [ nib . MenuItem ( \"Clear Completed\" , action = clear_completed , icon = \"trash\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] app . build ( nib . VStack ( controls = [ nib . Text ( \"Todo\" , font = nib . Font . TITLE ), nib . HStack ( controls = [ input_field , nib . Button ( \"Add\" , action = add_todo , style = nib . ButtonStyle . BORDERED_PROMINENT , ), ], spacing = 8 , ), nib . Divider (), nib . ScrollView ( controls = [ nib . VStack ( controls = [ todo_section , done_section ], spacing = 12 , ), ], ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Walkthrough \u00b6 Data model \u00b6 todos = [] # list of {\"text\": str, \"done\": bool} The app uses a plain Python list of dictionaries as its data model. Each todo has a text string and a done boolean. There is no ORM or special state container needed -- Nib's reactivity triggers when you reassign view properties. Text input and submission \u00b6 input_field = nib . TextField ( placeholder = \"What needs to be done?\" , on_submit = lambda _ : add_todo ()) TextField provides a text input with an on_submit callback that fires when the user presses Enter. The text property can be read to get the current value and written to clear the field after adding a todo. Dynamic list rendering \u00b6 def rebuild_lists (): pending = [ t for t in todos if not t [ \"done\" ]] completed = [ t for t in todos if t [ \"done\" ]] todo_section . controls = [ make_row ( t ) for t in pending ] done_section . controls = [ make_row ( t ) for t in completed ] When the data changes, the rebuild_lists function partitions the todos into pending and completed, then reassigns the controls property on each Section . Nib diffs the old and new view trees and patches only the changed nodes. Row factory \u00b6 def make_row ( todo ): def toggle_done ( is_on ): todo [ \"done\" ] = is_on rebuild_lists () def delete (): todos . remove ( todo ) rebuild_lists () return nib . HStack ( controls = [ nib . Toggle ( is_on = todo [ \"done\" ], label = \"\" , on_change = toggle_done ), nib . Text ( todo [ \"text\" ], ... ), nib . Spacer (), nib . Button ( icon = \"trash\" , action = delete , ... ), ], spacing = 8 , ) Each row is an HStack containing: A Toggle checkbox that marks the task as complete A Text label with conditional styling (secondary color when done) A Spacer to push the delete button to the right edge A destructive icon-only Button for deletion The callbacks use closures to capture the specific todo dictionary, so each row manipulates the correct item. Layout structure \u00b6 The main layout uses a VStack with: A title text An input row ( HStack with TextField and Button ) A Divider separator A ScrollView containing the two Section groups The ScrollView ensures the list is scrollable when there are many items. The Section views group tasks under \"Tasks\" and \"Completed\" headers. Running \u00b6 nib run todo.py","title":"Todo App"},{"location":"examples/todo/#full-source","text":"import nib def main ( app : nib . App ): app . title = \"Todo\" app . icon = nib . SFSymbol ( \"checklist\" ) app . width = 340 app . height = 450 # State todos = [] # list of {\"text\": str, \"done\": bool, \"views\": dict} todo_section = nib . Section ( header = \"Tasks\" , controls = []) done_section = nib . Section ( header = \"Completed\" , controls = []) input_field = nib . TextField ( placeholder = \"What needs to be done?\" , on_submit = lambda _ : add_todo ()) def rebuild_lists (): \"\"\"Rebuild both sections from the todos list.\"\"\" pending = [ t for t in todos if not t [ \"done\" ]] completed = [ t for t in todos if t [ \"done\" ]] todo_section . controls = [ make_row ( t ) for t in pending ] done_section . controls = [ make_row ( t ) for t in completed ] def make_row ( todo ): \"\"\"Create a view row for a single todo item.\"\"\" def toggle_done ( is_on ): todo [ \"done\" ] = is_on rebuild_lists () def delete (): todos . remove ( todo ) rebuild_lists () return nib . HStack ( controls = [ nib . Toggle ( is_on = todo [ \"done\" ], label = \"\" , on_change = toggle_done , ), nib . Text ( todo [ \"text\" ], foreground_color = nib . Color . SECONDARY if todo [ \"done\" ] else nib . Color . PRIMARY , ), nib . Spacer (), nib . Button ( icon = \"trash\" , action = delete , role = nib . ButtonRole . DESTRUCTIVE , style = nib . ButtonStyle . BORDERLESS , ), ], spacing = 8 , ) def add_todo (): text = input_field . text . strip () if text : todos . append ({ \"text\" : text , \"done\" : False }) input_field . text = \"\" rebuild_lists () def clear_completed (): nonlocal todos todos = [ t for t in todos if not t [ \"done\" ]] rebuild_lists () # Context menu app . menu = [ nib . MenuItem ( \"Clear Completed\" , action = clear_completed , icon = \"trash\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] app . build ( nib . VStack ( controls = [ nib . Text ( \"Todo\" , font = nib . Font . TITLE ), nib . HStack ( controls = [ input_field , nib . Button ( \"Add\" , action = add_todo , style = nib . ButtonStyle . BORDERED_PROMINENT , ), ], spacing = 8 , ), nib . Divider (), nib . ScrollView ( controls = [ nib . VStack ( controls = [ todo_section , done_section ], spacing = 12 , ), ], ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Full Source"},{"location":"examples/todo/#walkthrough","text":"","title":"Walkthrough"},{"location":"examples/todo/#data-model","text":"todos = [] # list of {\"text\": str, \"done\": bool} The app uses a plain Python list of dictionaries as its data model. Each todo has a text string and a done boolean. There is no ORM or special state container needed -- Nib's reactivity triggers when you reassign view properties.","title":"Data model"},{"location":"examples/todo/#text-input-and-submission","text":"input_field = nib . TextField ( placeholder = \"What needs to be done?\" , on_submit = lambda _ : add_todo ()) TextField provides a text input with an on_submit callback that fires when the user presses Enter. The text property can be read to get the current value and written to clear the field after adding a todo.","title":"Text input and submission"},{"location":"examples/todo/#dynamic-list-rendering","text":"def rebuild_lists (): pending = [ t for t in todos if not t [ \"done\" ]] completed = [ t for t in todos if t [ \"done\" ]] todo_section . controls = [ make_row ( t ) for t in pending ] done_section . controls = [ make_row ( t ) for t in completed ] When the data changes, the rebuild_lists function partitions the todos into pending and completed, then reassigns the controls property on each Section . Nib diffs the old and new view trees and patches only the changed nodes.","title":"Dynamic list rendering"},{"location":"examples/todo/#row-factory","text":"def make_row ( todo ): def toggle_done ( is_on ): todo [ \"done\" ] = is_on rebuild_lists () def delete (): todos . remove ( todo ) rebuild_lists () return nib . HStack ( controls = [ nib . Toggle ( is_on = todo [ \"done\" ], label = \"\" , on_change = toggle_done ), nib . Text ( todo [ \"text\" ], ... ), nib . Spacer (), nib . Button ( icon = \"trash\" , action = delete , ... ), ], spacing = 8 , ) Each row is an HStack containing: A Toggle checkbox that marks the task as complete A Text label with conditional styling (secondary color when done) A Spacer to push the delete button to the right edge A destructive icon-only Button for deletion The callbacks use closures to capture the specific todo dictionary, so each row manipulates the correct item.","title":"Row factory"},{"location":"examples/todo/#layout-structure","text":"The main layout uses a VStack with: A title text An input row ( HStack with TextField and Button ) A Divider separator A ScrollView containing the two Section groups The ScrollView ensures the list is scrollable when there are many items. The Section views group tasks under \"Tasks\" and \"Completed\" headers.","title":"Layout structure"},{"location":"examples/todo/#running","text":"nib run todo.py","title":"Running"},{"location":"getting-started/","text":"This section walks you through installing Nib, creating your first project, and understanding how a Nib application is structured. By the end, you will have a working macOS menu bar app written entirely in Python. Installation -- Install Nib and verify your environment. Quick Start -- Scaffold a project and run it in under a minute. Your First App -- Build a counter app from scratch, step by step. Project Structure -- Understand the standard layout, assets, and configuration.","title":"Index"},{"location":"getting-started/first-app/","text":"This tutorial walks through building a counter app from scratch. You will learn how to configure the app, create views, handle user interaction, and add a context menu. 1. Create the file \u00b6 Create a new file called main.py and start with the Nib import: import nib 2. Define the main function \u00b6 Nib uses a function-based entry point. Your main function receives an App instance that you configure: import nib def main ( app : nib . App ): pass nib . run ( main ) nib.run(main) creates the app, calls your function, and starts the event loop. This is the recommended pattern for all Nib applications. 3. Configure the app \u00b6 Set the title that appears next to the menu bar icon, the icon itself, and the popover window size: import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number.circle.fill\" ) app . width = 280 app . height = 200 nib . run ( main ) Note nib.SFSymbol accepts any SF Symbols name. You can browse available symbols using the SF Symbols app from Apple. 4. Add views \u00b6 Create a Text view to display the counter value and a Button to increment it: import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number.circle.fill\" ) app . width = 280 app . height = 200 counter_display = nib . Text ( \"0\" , font = nib . Font . TITLE ) increment_button = nib . Button ( \"Add +1\" ) app . build ( nib . VStack ( controls = [ counter_display , increment_button ], spacing = 12 , padding = 24 , ) ) nib . run ( main ) app.build() sets the root view of the application. Here we use a VStack to lay out the text and button vertically. The controls parameter takes a list of child views. 5. Make it reactive \u00b6 Define an action function and wire it to the button. When you mutate a view property, Nib automatically diffs the view tree and sends only the changes to the Swift runtime: import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number.circle.fill\" ) app . width = 280 app . height = 200 count = 0 counter_display = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): nonlocal count count += 1 counter_display . content = str ( count ) app . build ( nib . VStack ( controls = [ counter_display , nib . Button ( \"Add +1\" , action = increment ), ], spacing = 12 , padding = 24 , ) ) nib . run ( main ) The key line is counter_display.content = str(count) . Assigning a new value to a view property triggers an automatic re-render -- no manual state management, no observers, no signals. Just mutate the property and the UI updates. Tip Every view property that affects the UI is reactive. For example, changing button.foreground_color = nib.Color.RED or text.font = nib.Font.CAPTION will re-render instantly. 6. Add a context menu \u00b6 The context menu appears when the user right-clicks the menu bar icon. Define it with app.menu : import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number.circle.fill\" ) app . width = 280 app . height = 200 count = 0 counter_display = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): nonlocal count count += 1 counter_display . content = str ( count ) def reset (): nonlocal count count = 0 counter_display . content = \"0\" app . menu = [ nib . MenuItem ( \"Reset Counter\" , action = reset , icon = \"arrow.counterclockwise\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , icon = \"power\" ), ] app . build ( nib . VStack ( controls = [ counter_display , nib . Button ( \"Add +1\" , action = increment ), ], spacing = 12 , padding = 24 , ) ) nib . run ( main ) MenuItem accepts a title, an action callback, and an optional SF Symbol icon. MenuDivider inserts a separator line. 7. Run it \u00b6 Save the file and launch it: nib run main.py Click the icon in your menu bar to open the popover. Press the button to increment the counter. Right-click the icon to see the context menu. Complete code \u00b6 Here is the full application in one file: \"\"\"Counter - A simple Nib menu bar app.\"\"\" import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number.circle.fill\" ) app . width = 280 app . height = 200 count = 0 counter_display = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): nonlocal count count += 1 counter_display . content = str ( count ) def reset (): nonlocal count count = 0 counter_display . content = \"0\" app . menu = [ nib . MenuItem ( \"Reset Counter\" , action = reset , icon = \"arrow.counterclockwise\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , icon = \"power\" ), ] app . build ( nib . VStack ( controls = [ nib . Text ( \"Counter\" , font = nib . Font . HEADLINE ), counter_display , nib . Button ( \"Add +1\" , action = increment ), ], spacing = 12 , padding = 24 , ) ) nib . run ( main ) Class-based approach \u00b6 Nib also supports a class-based pattern where you subclass nib.App and override the body method. This can be useful for smaller apps or when you prefer an object-oriented style: import nib class MyApp ( nib . App ): def body ( self ) -> nib . View : return nib . VStack ( controls = [ nib . Text ( \"Hello from Nib!\" , font = nib . Font . TITLE ), nib . Text ( \"A class-based app.\" , foreground_color = nib . Color . GRAY ), ], spacing = 8 , padding = 24 , ) MyApp ( icon = \"star.fill\" ) . run () The constructor accepts title , icon , and identifier parameters. Call .run() to start the application. Note The function-based approach ( nib.run(main) ) is recommended for most apps because it keeps setup logic in a single function and avoids the need for subclassing. The class-based approach does not support reactive property mutations in the same way -- it is better suited for static UIs. Next steps \u00b6 Project Structure -- Learn about assets, fonts, and the pyproject.toml configuration.","title":"Your First App"},{"location":"getting-started/first-app/#1-create-the-file","text":"Create a new file called main.py and start with the Nib import: import nib","title":"1. Create the file"},{"location":"getting-started/first-app/#2-define-the-main-function","text":"Nib uses a function-based entry point. Your main function receives an App instance that you configure: import nib def main ( app : nib . App ): pass nib . run ( main ) nib.run(main) creates the app, calls your function, and starts the event loop. This is the recommended pattern for all Nib applications.","title":"2. Define the main function"},{"location":"getting-started/first-app/#3-configure-the-app","text":"Set the title that appears next to the menu bar icon, the icon itself, and the popover window size: import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number.circle.fill\" ) app . width = 280 app . height = 200 nib . run ( main ) Note nib.SFSymbol accepts any SF Symbols name. You can browse available symbols using the SF Symbols app from Apple.","title":"3. Configure the app"},{"location":"getting-started/first-app/#4-add-views","text":"Create a Text view to display the counter value and a Button to increment it: import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number.circle.fill\" ) app . width = 280 app . height = 200 counter_display = nib . Text ( \"0\" , font = nib . Font . TITLE ) increment_button = nib . Button ( \"Add +1\" ) app . build ( nib . VStack ( controls = [ counter_display , increment_button ], spacing = 12 , padding = 24 , ) ) nib . run ( main ) app.build() sets the root view of the application. Here we use a VStack to lay out the text and button vertically. The controls parameter takes a list of child views.","title":"4. Add views"},{"location":"getting-started/first-app/#5-make-it-reactive","text":"Define an action function and wire it to the button. When you mutate a view property, Nib automatically diffs the view tree and sends only the changes to the Swift runtime: import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number.circle.fill\" ) app . width = 280 app . height = 200 count = 0 counter_display = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): nonlocal count count += 1 counter_display . content = str ( count ) app . build ( nib . VStack ( controls = [ counter_display , nib . Button ( \"Add +1\" , action = increment ), ], spacing = 12 , padding = 24 , ) ) nib . run ( main ) The key line is counter_display.content = str(count) . Assigning a new value to a view property triggers an automatic re-render -- no manual state management, no observers, no signals. Just mutate the property and the UI updates. Tip Every view property that affects the UI is reactive. For example, changing button.foreground_color = nib.Color.RED or text.font = nib.Font.CAPTION will re-render instantly.","title":"5. Make it reactive"},{"location":"getting-started/first-app/#6-add-a-context-menu","text":"The context menu appears when the user right-clicks the menu bar icon. Define it with app.menu : import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number.circle.fill\" ) app . width = 280 app . height = 200 count = 0 counter_display = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): nonlocal count count += 1 counter_display . content = str ( count ) def reset (): nonlocal count count = 0 counter_display . content = \"0\" app . menu = [ nib . MenuItem ( \"Reset Counter\" , action = reset , icon = \"arrow.counterclockwise\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , icon = \"power\" ), ] app . build ( nib . VStack ( controls = [ counter_display , nib . Button ( \"Add +1\" , action = increment ), ], spacing = 12 , padding = 24 , ) ) nib . run ( main ) MenuItem accepts a title, an action callback, and an optional SF Symbol icon. MenuDivider inserts a separator line.","title":"6. Add a context menu"},{"location":"getting-started/first-app/#7-run-it","text":"Save the file and launch it: nib run main.py Click the icon in your menu bar to open the popover. Press the button to increment the counter. Right-click the icon to see the context menu.","title":"7. Run it"},{"location":"getting-started/first-app/#complete-code","text":"Here is the full application in one file: \"\"\"Counter - A simple Nib menu bar app.\"\"\" import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number.circle.fill\" ) app . width = 280 app . height = 200 count = 0 counter_display = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): nonlocal count count += 1 counter_display . content = str ( count ) def reset (): nonlocal count count = 0 counter_display . content = \"0\" app . menu = [ nib . MenuItem ( \"Reset Counter\" , action = reset , icon = \"arrow.counterclockwise\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , icon = \"power\" ), ] app . build ( nib . VStack ( controls = [ nib . Text ( \"Counter\" , font = nib . Font . HEADLINE ), counter_display , nib . Button ( \"Add +1\" , action = increment ), ], spacing = 12 , padding = 24 , ) ) nib . run ( main )","title":"Complete code"},{"location":"getting-started/first-app/#class-based-approach","text":"Nib also supports a class-based pattern where you subclass nib.App and override the body method. This can be useful for smaller apps or when you prefer an object-oriented style: import nib class MyApp ( nib . App ): def body ( self ) -> nib . View : return nib . VStack ( controls = [ nib . Text ( \"Hello from Nib!\" , font = nib . Font . TITLE ), nib . Text ( \"A class-based app.\" , foreground_color = nib . Color . GRAY ), ], spacing = 8 , padding = 24 , ) MyApp ( icon = \"star.fill\" ) . run () The constructor accepts title , icon , and identifier parameters. Call .run() to start the application. Note The function-based approach ( nib.run(main) ) is recommended for most apps because it keeps setup logic in a single function and avoids the need for subclassing. The class-based approach does not support reactive property mutations in the same way -- it is better suited for static UIs.","title":"Class-based approach"},{"location":"getting-started/first-app/#next-steps","text":"Project Structure -- Learn about assets, fonts, and the pyproject.toml configuration.","title":"Next steps"},{"location":"getting-started/installation/","text":"Requirements \u00b6 Nib requires: Requirement Minimum version macOS 14 (Sonoma)+ Python 3.10+ Note Nib apps are macOS-only. The framework relies on SwiftUI for rendering and system APIs that are exclusive to Apple platforms. Install via pip \u00b6 The recommended way to install Nib is from PyPI: pip install pynib This installs the Python SDK and the pre-built Swift runtime binary. No Xcode or Swift toolchain required. Verify the installation \u00b6 After installing, confirm that the CLI is available: nib --version You should see output like: nib 0.1.6 Tip If nib is not found, make sure the Python bin directory is on your PATH . When using a virtual environment, activate it first. Using a virtual environment \u00b6 It is good practice to install Nib inside a virtual environment: python3 -m venv .venv source .venv/bin/activate pip install pynib Building from source \u00b6 If you want to contribute to Nib or need the latest unreleased changes, you can build from source. 1. Clone the repository \u00b6 git clone https://github.com/Bbalduzz/nib.git cd nib 2. Build the Swift runtime and install \u00b6 The make install command builds the universal Swift runtime binary (arm64 + x86_64) and installs the Python package in editable mode: make install This runs two steps under the hood: Build the Swift runtime -- Compiles the Swift package in release mode and copies the nib-runtime binary into the Python SDK. Install the Python SDK -- Runs pip install -e . so that changes to the Python code are reflected immediately. Warning Building from source requires Xcode and the Swift toolchain. You can install Xcode from the Mac App Store or use the Xcode Command Line Tools ( xcode-select --install ). Build the runtime only \u00b6 If you only need to rebuild the Swift side without reinstalling the Python package: make build-runtime The compiled binary lands at sdk/python/nib/bin/nib-runtime . Next steps \u00b6 With Nib installed, head to the Quick Start to create and run your first project.","title":"Installation"},{"location":"getting-started/installation/#requirements","text":"Nib requires: Requirement Minimum version macOS 14 (Sonoma)+ Python 3.10+ Note Nib apps are macOS-only. The framework relies on SwiftUI for rendering and system APIs that are exclusive to Apple platforms.","title":"Requirements"},{"location":"getting-started/installation/#install-via-pip","text":"The recommended way to install Nib is from PyPI: pip install pynib This installs the Python SDK and the pre-built Swift runtime binary. No Xcode or Swift toolchain required.","title":"Install via pip"},{"location":"getting-started/installation/#verify-the-installation","text":"After installing, confirm that the CLI is available: nib --version You should see output like: nib 0.1.6 Tip If nib is not found, make sure the Python bin directory is on your PATH . When using a virtual environment, activate it first.","title":"Verify the installation"},{"location":"getting-started/installation/#using-a-virtual-environment","text":"It is good practice to install Nib inside a virtual environment: python3 -m venv .venv source .venv/bin/activate pip install pynib","title":"Using a virtual environment"},{"location":"getting-started/installation/#building-from-source","text":"If you want to contribute to Nib or need the latest unreleased changes, you can build from source.","title":"Building from source"},{"location":"getting-started/installation/#1-clone-the-repository","text":"git clone https://github.com/Bbalduzz/nib.git cd nib","title":"1. Clone the repository"},{"location":"getting-started/installation/#2-build-the-swift-runtime-and-install","text":"The make install command builds the universal Swift runtime binary (arm64 + x86_64) and installs the Python package in editable mode: make install This runs two steps under the hood: Build the Swift runtime -- Compiles the Swift package in release mode and copies the nib-runtime binary into the Python SDK. Install the Python SDK -- Runs pip install -e . so that changes to the Python code are reflected immediately. Warning Building from source requires Xcode and the Swift toolchain. You can install Xcode from the Mac App Store or use the Xcode Command Line Tools ( xcode-select --install ).","title":"2. Build the Swift runtime and install"},{"location":"getting-started/installation/#build-the-runtime-only","text":"If you only need to rebuild the Swift side without reinstalling the Python package: make build-runtime The compiled binary lands at sdk/python/nib/bin/nib-runtime .","title":"Build the runtime only"},{"location":"getting-started/installation/#next-steps","text":"With Nib installed, head to the Quick Start to create and run your first project.","title":"Next steps"},{"location":"getting-started/project-structure/","text":"This page covers the standard layout of a Nib project, how assets are discovered, and how to configure your app through pyproject.toml . Standard layout \u00b6 A project created with nib create follows this structure: myapp/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main.py # Application entry point \u2502 \u2514\u2500\u2500 assets/ # Icons, images, fonts \u2502 \u2514\u2500\u2500 .gitkeep \u251c\u2500\u2500 pyproject.toml # Project metadata and Nib build config \u2514\u2500\u2500 README.md You are free to organize your Python code however you like -- Nib only needs to know the path to your entry point script. The layout above is a convention, not a requirement. Entry point \u00b6 The entry point is the Python file that contains your nib.run(main) or MyApp().run() call. It is specified in two places: Development mode -- passed as an argument to nib run : bash nib run src/main.py Build mode -- configured in pyproject.toml : toml [tool.nib] entry = \"src/main.py\" Assets directory \u00b6 The assets/ directory holds images, icons, fonts, and any other static files your app needs. Nib auto-detects the assets directory at startup by looking in these locations (in order): assets/ next to the entry point script assets/ in the parent directory (handles src/main.py finding assets/ at root) src/assets/ from the working directory For example, with the standard layout, running nib run src/main.py will find src/assets/ automatically. Tip You can override the auto-detected path by passing assets_dir to nib.run() : python nib.run(main, assets_dir=\"my_custom_assets\") Or set it explicitly before running: python nib.App.set_assets_dir(\"/absolute/path/to/assets\") Referencing assets in code \u00b6 Use relative paths from the assets directory when referencing files. Nib resolves them to absolute paths automatically: # If assets/logo.png exists: nib . Image ( source = \"logo.png\" ) # Subdirectories work too: nib . Image ( source = \"icons/settings.png\" ) Absolute paths and URLs are passed through without resolution: nib . Image ( source = \"/Users/me/photos/cat.jpg\" ) nib . Image ( source = \"https://example.com/image.png\" ) Fonts \u00b6 Nib automatically detects font files placed in the assets directory. Supported formats are .ttf , .otf , .ttc , .woff , and .woff2 . Place your font files anywhere inside assets/ : src/assets/ \u251c\u2500\u2500 Geist-Regular.ttf \u251c\u2500\u2500 Geist-Bold.ttf \u2514\u2500\u2500 icons/ \u2514\u2500\u2500 app-icon.png The font name is derived from the filename without the extension. Use it with Font.custom() : nib . Text ( \"Hello, custom font!\" , font = nib . Font . custom ( \"Geist-Regular\" , size = 16 ), ) You can also register fonts from arbitrary paths or URLs using app.fonts : app . fonts = { \"MyFont\" : \"/absolute/path/to/MyFont.ttf\" , \"WebFont\" : \"https://example.com/fonts/WebFont.otf\" , } Note Fonts placed in the assets directory are registered automatically and do not need to be added to app.fonts . User-specified fonts in app.fonts take precedence if there is a name conflict. Images \u00b6 Place image files ( .png , .jpg , .svg , etc.) in the assets directory and reference them by relative path: # assets/icon.png nib . Image ( source = \"icon.png\" , width = 64 , height = 64 ) # assets/photos/banner.jpg nib . Image ( source = \"photos/banner.jpg\" , content_mode = nib . ContentMode . FIT ) For the app icon used in nib build , place an icon.png at src/assets/icon.png . The build system converts it to .icns format automatically. pyproject.toml configuration \u00b6 The [tool.nib] section configures the Nib CLI. The [tool.nib.build] section controls the nib build command. Entry point \u00b6 [tool.nib] entry = \"src/main.py\" This tells nib build which file to use as the application entry point. Build configuration \u00b6 [tool.nib.build] # App display name (defaults to project name) name = \"My App\" # Bundle identifier (defaults to com.nib.<name>) identifier = \"com.example.myapp\" # App version (defaults to project version) version = \"1.0.0\" # App icon (defaults to src/assets/icon.png if it exists) icon = \"src/assets/icon.png\" # Minimum macOS version (defaults to current) min_macos = \"14.0\" # Packages to exclude from bundling exclude = [] # Extra dependencies to include if auto-detection misses them extra_deps = [] Info.plist options \u00b6 Advanced options for the macOS application bundle: [tool.nib.build.plist] copyright = \"Copyright 2025 Your Name\" category = \"public.app-category.utilities\" notification_style = \"banner\" # \"banner\", \"alert\", or \"none\" dock_icon = false # true to show in Dock url_schemes = [ \"myapp\" ] # Custom URL schemes # Privacy usage descriptions [tool.nib.build.plist.usage] camera = \"This app needs camera access for video capture.\" microphone = \"This app needs microphone access for recording.\" Development mode vs bundled mode \u00b6 Nib apps behave differently depending on how they are launched: Development mode ( nib run ) \u00b6 Python launches the Swift runtime as a child process. Assets are read directly from the filesystem using the auto-detected path. File changes trigger hot reload -- the Python process restarts while the Swift runtime stays alive. Bundled mode ( nib build output) \u00b6 The Swift runtime is the main executable. It launches an embedded Python interpreter. Assets are bundled inside the .app at Contents/Resources/assets/ . The NIB_SOCKET environment variable is set by the Swift runtime so Python knows it is running in bundled mode. Warning Paths that work in development (e.g., ../../data/file.txt ) may not work in a bundled app. Always use the assets directory for static files, or resolve paths at runtime using os.path relative to your script. Asset resolution is handled transparently. Code like nib.Image(source=\"logo.png\") works in both modes without changes -- Nib resolves the path from the assets directory regardless of whether it is on disk or inside the app bundle.","title":"Project Structure"},{"location":"getting-started/project-structure/#standard-layout","text":"A project created with nib create follows this structure: myapp/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main.py # Application entry point \u2502 \u2514\u2500\u2500 assets/ # Icons, images, fonts \u2502 \u2514\u2500\u2500 .gitkeep \u251c\u2500\u2500 pyproject.toml # Project metadata and Nib build config \u2514\u2500\u2500 README.md You are free to organize your Python code however you like -- Nib only needs to know the path to your entry point script. The layout above is a convention, not a requirement.","title":"Standard layout"},{"location":"getting-started/project-structure/#entry-point","text":"The entry point is the Python file that contains your nib.run(main) or MyApp().run() call. It is specified in two places: Development mode -- passed as an argument to nib run : bash nib run src/main.py Build mode -- configured in pyproject.toml : toml [tool.nib] entry = \"src/main.py\"","title":"Entry point"},{"location":"getting-started/project-structure/#assets-directory","text":"The assets/ directory holds images, icons, fonts, and any other static files your app needs. Nib auto-detects the assets directory at startup by looking in these locations (in order): assets/ next to the entry point script assets/ in the parent directory (handles src/main.py finding assets/ at root) src/assets/ from the working directory For example, with the standard layout, running nib run src/main.py will find src/assets/ automatically. Tip You can override the auto-detected path by passing assets_dir to nib.run() : python nib.run(main, assets_dir=\"my_custom_assets\") Or set it explicitly before running: python nib.App.set_assets_dir(\"/absolute/path/to/assets\")","title":"Assets directory"},{"location":"getting-started/project-structure/#referencing-assets-in-code","text":"Use relative paths from the assets directory when referencing files. Nib resolves them to absolute paths automatically: # If assets/logo.png exists: nib . Image ( source = \"logo.png\" ) # Subdirectories work too: nib . Image ( source = \"icons/settings.png\" ) Absolute paths and URLs are passed through without resolution: nib . Image ( source = \"/Users/me/photos/cat.jpg\" ) nib . Image ( source = \"https://example.com/image.png\" )","title":"Referencing assets in code"},{"location":"getting-started/project-structure/#fonts","text":"Nib automatically detects font files placed in the assets directory. Supported formats are .ttf , .otf , .ttc , .woff , and .woff2 . Place your font files anywhere inside assets/ : src/assets/ \u251c\u2500\u2500 Geist-Regular.ttf \u251c\u2500\u2500 Geist-Bold.ttf \u2514\u2500\u2500 icons/ \u2514\u2500\u2500 app-icon.png The font name is derived from the filename without the extension. Use it with Font.custom() : nib . Text ( \"Hello, custom font!\" , font = nib . Font . custom ( \"Geist-Regular\" , size = 16 ), ) You can also register fonts from arbitrary paths or URLs using app.fonts : app . fonts = { \"MyFont\" : \"/absolute/path/to/MyFont.ttf\" , \"WebFont\" : \"https://example.com/fonts/WebFont.otf\" , } Note Fonts placed in the assets directory are registered automatically and do not need to be added to app.fonts . User-specified fonts in app.fonts take precedence if there is a name conflict.","title":"Fonts"},{"location":"getting-started/project-structure/#images","text":"Place image files ( .png , .jpg , .svg , etc.) in the assets directory and reference them by relative path: # assets/icon.png nib . Image ( source = \"icon.png\" , width = 64 , height = 64 ) # assets/photos/banner.jpg nib . Image ( source = \"photos/banner.jpg\" , content_mode = nib . ContentMode . FIT ) For the app icon used in nib build , place an icon.png at src/assets/icon.png . The build system converts it to .icns format automatically.","title":"Images"},{"location":"getting-started/project-structure/#pyprojecttoml-configuration","text":"The [tool.nib] section configures the Nib CLI. The [tool.nib.build] section controls the nib build command.","title":"pyproject.toml configuration"},{"location":"getting-started/project-structure/#entry-point_1","text":"[tool.nib] entry = \"src/main.py\" This tells nib build which file to use as the application entry point.","title":"Entry point"},{"location":"getting-started/project-structure/#build-configuration","text":"[tool.nib.build] # App display name (defaults to project name) name = \"My App\" # Bundle identifier (defaults to com.nib.<name>) identifier = \"com.example.myapp\" # App version (defaults to project version) version = \"1.0.0\" # App icon (defaults to src/assets/icon.png if it exists) icon = \"src/assets/icon.png\" # Minimum macOS version (defaults to current) min_macos = \"14.0\" # Packages to exclude from bundling exclude = [] # Extra dependencies to include if auto-detection misses them extra_deps = []","title":"Build configuration"},{"location":"getting-started/project-structure/#infoplist-options","text":"Advanced options for the macOS application bundle: [tool.nib.build.plist] copyright = \"Copyright 2025 Your Name\" category = \"public.app-category.utilities\" notification_style = \"banner\" # \"banner\", \"alert\", or \"none\" dock_icon = false # true to show in Dock url_schemes = [ \"myapp\" ] # Custom URL schemes # Privacy usage descriptions [tool.nib.build.plist.usage] camera = \"This app needs camera access for video capture.\" microphone = \"This app needs microphone access for recording.\"","title":"Info.plist options"},{"location":"getting-started/project-structure/#development-mode-vs-bundled-mode","text":"Nib apps behave differently depending on how they are launched:","title":"Development mode vs bundled mode"},{"location":"getting-started/project-structure/#development-mode-nib-run","text":"Python launches the Swift runtime as a child process. Assets are read directly from the filesystem using the auto-detected path. File changes trigger hot reload -- the Python process restarts while the Swift runtime stays alive.","title":"Development mode (nib run)"},{"location":"getting-started/project-structure/#bundled-mode-nib-build-output","text":"The Swift runtime is the main executable. It launches an embedded Python interpreter. Assets are bundled inside the .app at Contents/Resources/assets/ . The NIB_SOCKET environment variable is set by the Swift runtime so Python knows it is running in bundled mode. Warning Paths that work in development (e.g., ../../data/file.txt ) may not work in a bundled app. Always use the assets directory for static files, or resolve paths at runtime using os.path relative to your script. Asset resolution is handled transparently. Code like nib.Image(source=\"logo.png\") works in both modes without changes -- Nib resolves the path from the assets directory regardless of whether it is on disk or inside the app bundle.","title":"Bundled mode (nib build output)"},{"location":"getting-started/quickstart/","text":"This page gets you from zero to a running menu bar app in under a minute. Create a new project \u00b6 Use the nib create command to scaffold a project: nib create myapp You will see output like: Creating nib project : Myapp Created : src / main . py Created : pyproject . toml Created : README . md Created : src / assets / Project created at : / path / to / myapp Next steps : cd myapp python src / main . py # Run in development nib build # Build standalone app What gets generated \u00b6 The scaffolded project has the following layout: myapp/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main.py # Application entry point \u2502 \u2514\u2500\u2500 assets/ # Icons, images, fonts \u251c\u2500\u2500 pyproject.toml # Project metadata and Nib build config \u2514\u2500\u2500 README.md # Basic documentation src/main.py \u00b6 The generated entry point is a counter app that demonstrates the core concepts -- app configuration, views, reactivity, and a context menu: \"\"\" Myapp - A nib application \"\"\" import nib def main ( app : nib . App ): app . title = \"Myapp\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . menu = [ nib . MenuItem ( \"Quit\" , action = app . quit ), ] counter = nib . Text ( \"0\" ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Hello, Myapp!\" , font = nib . Font . title ), counter , nib . Button ( \"Click me\" , action = increment ), ], spacing = 16 , padding = 24 , ) ) nib . run ( main ) pyproject.toml \u00b6 The generated pyproject.toml contains project metadata and Nib build configuration. Most options are commented out with sensible defaults: [project] name = \"myapp\" version = \"0.1.0\" description = \"Myapp - A nib application\" requires-python = \">=3.10\" dependencies = [ \"nib\" , ] [tool.nib] entry = \"src/main.py\" [tool.nib.build] name = \"Myapp\" # identifier = \"com.example.myapp\" # version = \"1.0.0\" # icon = \"src/assets/icon.png\" Run the app \u00b6 Navigate into the project directory and launch it with nib run : cd myapp nib run src/main.py A new icon appears in your macOS menu bar. Click it to open the popover and see your app. Every time you save a .py file, Nib hot-reloads the application automatically. Tip Use the -r flag to watch subdirectories recursively for changes: bash nib run src/main.py -r What just happened \u00b6 When you run nib run , the following happens: Python starts your script and builds the view tree. Swift runtime launches as a separate process, creating a native macOS menu bar app. The two processes connect over a Unix socket using MessagePack serialization. Python sends the full view tree to Swift, which renders it as native SwiftUI. Watchdog monitors your files and reloads the Python side on every save, keeping the Swift runtime alive. Next steps \u00b6 Your First App -- Build an app from scratch to understand every piece. Project Structure -- Learn about assets, fonts, and build configuration.","title":"Quick Start"},{"location":"getting-started/quickstart/#create-a-new-project","text":"Use the nib create command to scaffold a project: nib create myapp You will see output like: Creating nib project : Myapp Created : src / main . py Created : pyproject . toml Created : README . md Created : src / assets / Project created at : / path / to / myapp Next steps : cd myapp python src / main . py # Run in development nib build # Build standalone app","title":"Create a new project"},{"location":"getting-started/quickstart/#what-gets-generated","text":"The scaffolded project has the following layout: myapp/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main.py # Application entry point \u2502 \u2514\u2500\u2500 assets/ # Icons, images, fonts \u251c\u2500\u2500 pyproject.toml # Project metadata and Nib build config \u2514\u2500\u2500 README.md # Basic documentation","title":"What gets generated"},{"location":"getting-started/quickstart/#srcmainpy","text":"The generated entry point is a counter app that demonstrates the core concepts -- app configuration, views, reactivity, and a context menu: \"\"\" Myapp - A nib application \"\"\" import nib def main ( app : nib . App ): app . title = \"Myapp\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . menu = [ nib . MenuItem ( \"Quit\" , action = app . quit ), ] counter = nib . Text ( \"0\" ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Hello, Myapp!\" , font = nib . Font . title ), counter , nib . Button ( \"Click me\" , action = increment ), ], spacing = 16 , padding = 24 , ) ) nib . run ( main )","title":"src/main.py"},{"location":"getting-started/quickstart/#pyprojecttoml","text":"The generated pyproject.toml contains project metadata and Nib build configuration. Most options are commented out with sensible defaults: [project] name = \"myapp\" version = \"0.1.0\" description = \"Myapp - A nib application\" requires-python = \">=3.10\" dependencies = [ \"nib\" , ] [tool.nib] entry = \"src/main.py\" [tool.nib.build] name = \"Myapp\" # identifier = \"com.example.myapp\" # version = \"1.0.0\" # icon = \"src/assets/icon.png\"","title":"pyproject.toml"},{"location":"getting-started/quickstart/#run-the-app","text":"Navigate into the project directory and launch it with nib run : cd myapp nib run src/main.py A new icon appears in your macOS menu bar. Click it to open the popover and see your app. Every time you save a .py file, Nib hot-reloads the application automatically. Tip Use the -r flag to watch subdirectories recursively for changes: bash nib run src/main.py -r","title":"Run the app"},{"location":"getting-started/quickstart/#what-just-happened","text":"When you run nib run , the following happens: Python starts your script and builds the view tree. Swift runtime launches as a separate process, creating a native macOS menu bar app. The two processes connect over a Unix socket using MessagePack serialization. Python sends the full view tree to Swift, which renders it as native SwiftUI. Watchdog monitors your files and reloads the Python side on every save, keeping the Swift runtime alive.","title":"What just happened"},{"location":"getting-started/quickstart/#next-steps","text":"Your First App -- Build an app from scratch to understand every piece. Project Structure -- Learn about assets, fonts, and build configuration.","title":"Next steps"},{"location":"guides/","text":"Practical guides for building macOS menu bar applications with Nib. Each guide covers a specific topic with code examples you can copy into your project. Guide Description Building Layouts Stack, scroll, list, form, grid, and spacer containers Styling & Theming Backgrounds, borders, shadows, opacity, corner radius, and clip shapes Colors & Gradients Named colors, hex, RGB, RGBA, and linear/radial/angular gradients Typography & Fonts System fonts, custom fonts, font weights, text styles, and attributed strings Animations & Transitions Timing curves, springs, content transitions, and view transitions Context Menu Right-click menu items, submenus, shortcuts, badges, and custom views Settings & Persistence Settings class, UserDefaults, settings pages with tabs Notifications Push and scheduled notifications, sounds, actions, and text input System Services Battery, connectivity, screen, keychain, camera, launch at login, permissions File Dialogs Open, save, and directory picker dialogs with native NSOpenPanel/NSSavePanel Canvas Drawing Core Graphics drawing surface with shapes, gradients, text, and gesture handling Charts Swift Charts integration with line, bar, area, point, sector, and rule marks Navigation NavigationStack, NavigationLink, and DisclosureGroup for hierarchical navigation Drag & Drop File drag-and-drop handling on any container view Hotkeys & Clipboard Global keyboard shortcuts and system clipboard access Custom Fonts Loading custom TTF/OTF fonts from assets, paths, or URLs Assets Asset directory, resolution, and bundled mode support","title":"Index"},{"location":"guides/animations/","text":"Nib supports three categories of animation: property animations that interpolate value changes, content transitions that animate text and content swaps, and view transitions that animate when views appear or disappear. Animation Class \u00b6 The Animation class defines timing curves. Apply it to any view with the animation parameter. When a property of that view changes, the change is animated. import nib counter = nib . Text ( \"0\" , animation = nib . Animation . spring ()) Timing curves \u00b6 Factory method Behavior Animation.linear(duration) Constant speed Animation.easeIn(duration) Slow start, fast end Animation.easeOut(duration) Fast start, slow end Animation.easeInOut(duration) Slow start and end Animation.spring(response, damping) Physics-based spring All timing curves accept a duration parameter in seconds (default: 0.3 ): nib . Animation . linear ( duration = 0.5 ) nib . Animation . easeInOut ( duration = 1.0 ) nib . Animation . easeOut ( duration = 0.15 ) Spring animation \u00b6 Spring animations have two parameters: response -- how quickly the spring settles (lower = faster, default 0.3 ) damping -- how much the spring bounces ( 0.0 = bounces forever, 1.0 = no bounce, default 0.7 ) # Snappy spring with slight bounce nib . Animation . spring ( response = 0.3 , damping = 0.7 ) # Bouncy spring nib . Animation . spring ( response = 0.4 , damping = 0.4 ) # Stiff spring, no bounce nib . Animation . spring ( response = 0.2 , damping = 1.0 ) Presets \u00b6 Four presets are available for common cases: nib . Animation . default # easeInOut(0.3) nib . Animation . fast # easeOut(0.15) nib . Animation . slow # easeInOut(0.5) nib . Animation . bouncy # spring(response=0.3, damping=0.5) Example: Animated counter \u00b6 import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number\" ) app . width = 200 app . height = 150 count = 0 label = nib . Text ( \"0\" , font = nib . Font . LARGE_TITLE , animation = nib . Animation . spring ()) def increment (): nonlocal count count += 1 label . content = str ( count ) app . build ( nib . VStack ( controls = [ label , nib . Button ( \"Add\" , action = increment ), ], spacing = 16 , padding = 24 , ) ) nib . run ( main ) Content Transitions \u00b6 Content transitions animate how the content of a view changes. They are most useful with Text views when the displayed value updates. Apply with the content_transition parameter: nib . Text ( \"42\" , content_transition = nib . ContentTransition . NUMERIC_TEXT ) Transition Effect ContentTransition.IDENTITY No animation (default) ContentTransition.INTERPOLATE Smoothly interpolate between old and new content ContentTransition.OPACITY Cross-fade between old and new content ContentTransition.NUMERIC_TEXT Roll digits up when numbers increase ContentTransition.NUMERIC_TEXT_DOWN Roll digits down when numbers decrease Numeric text transition \u00b6 NUMERIC_TEXT is ideal for counters, timers, and scores. Digits roll upward when the number increases: import nib def main ( app : nib . App ): app . title = \"Score\" app . icon = nib . SFSymbol ( \"star\" ) app . width = 200 app . height = 150 score = 0 score_label = nib . Text ( \"0\" , font = nib . Font . system ( 48 , nib . FontWeight . BOLD ), content_transition = nib . ContentTransition . NUMERIC_TEXT , animation = nib . Animation . spring (), ) def add_point (): nonlocal score score += 10 score_label . content = str ( score ) app . build ( nib . VStack ( controls = [ score_label , nib . Button ( \"+10\" , action = add_point )], spacing = 16 , padding = 24 , ) ) nib . run ( main ) Tip Pair content_transition with animation for the best effect. The animation controls the timing curve, while the content transition controls the visual style. View Transitions \u00b6 View transitions animate when a view appears or disappears from the view hierarchy. Apply with the transition parameter. nib . Text ( \"Appearing!\" , transition = nib . Transition . OPACITY ) Simple transitions \u00b6 Transition Effect Transition.IDENTITY No animation Transition.OPACITY Fade in/out Transition.SCALE Scale up from center on appear, scale down on disappear Transition.SLIDE Slide in from leading edge, slide out to trailing edge Transition.MOVE_LEADING Move in from the left Transition.MOVE_TRAILING Move in from the right Transition.MOVE_TOP Move in from the top Transition.MOVE_BOTTOM Move in from the bottom Transition.PUSH Push new content in, push old content out Asymmetric transitions \u00b6 Use different animations for appearing and disappearing: nib . Text ( \"Slide in, fade out\" , transition = nib . Transition . asymmetric ( insertion = nib . Transition . SLIDE , removal = nib . Transition . OPACITY , ), ) nib . Text ( \"Scale in, move out\" , transition = nib . Transition . asymmetric ( insertion = nib . Transition . SCALE , removal = nib . Transition . MOVE_BOTTOM , ), ) Combined transitions \u00b6 Apply multiple transition effects simultaneously: nib . Text ( \"Fade and scale together\" , transition = nib . Transition . combined ( nib . Transition . OPACITY , nib . Transition . SCALE , ), ) Custom keyframe transitions \u00b6 Build fully custom transitions with keyframe interpolation: # Custom swoosh transition swoosh = ( nib . Transition . custom ( \"swoosh\" ) . at ( 0.0 , opacity = 0 , scale = 0.5 , offset_x =- 50 ) . at ( 0.5 , opacity = 1 , scale = 1.1 , offset_x = 10 ) . at ( 1.0 , opacity = 1 , scale = 1.0 , offset_x = 0 ) . build () ) nib . Text ( \"Swoosh!\" , transition = swoosh ) Keyframe properties: Property Description opacity View opacity (0.0 to 1.0) scale Scale factor (1.0 = normal) blur Gaussian blur radius offset_x Horizontal offset in points offset_y Vertical offset in points Pre-built custom transitions \u00b6 Nib includes two ready-made custom transitions: # Pop-fade: scales up slightly while fading in nib . Text ( \"Pop!\" , transition = nib . Transition . pop_fade ()) # Bounce-in: overshoots then settles nib . Text ( \"Bounce!\" , transition = nib . Transition . bounce_in ()) Example: Animated Visibility Toggle \u00b6 Combine animation and transition with the visible property to animate showing and hiding views: import nib def main ( app : nib . App ): app . title = \"Toggle View\" app . icon = nib . SFSymbol ( \"eye\" ) app . width = 280 app . height = 250 detail = nib . VStack ( controls = [ nib . Text ( \"Detail Panel\" , font = nib . Font . HEADLINE ), nib . Text ( \"This panel fades and scales in.\" , foreground_color = nib . Color . SECONDARY ), ], spacing = 8 , padding = 16 , background = nib . Rectangle ( corner_radius = 10 , fill = \"#1c1c1e\" ), transition = nib . Transition . combined ( nib . Transition . OPACITY , nib . Transition . SCALE ), animation = nib . Animation . spring (), ) def toggle (): detail . visible = not detail . visible app . build ( nib . VStack ( controls = [ nib . Button ( \"Toggle Detail\" , action = toggle ), detail , ], spacing = 16 , padding = 24 , animation = nib . Animation . easeInOut ( 0.3 ), ) ) nib . run ( main )","title":"Animations & Transitions"},{"location":"guides/animations/#animation-class","text":"The Animation class defines timing curves. Apply it to any view with the animation parameter. When a property of that view changes, the change is animated. import nib counter = nib . Text ( \"0\" , animation = nib . Animation . spring ())","title":"Animation Class"},{"location":"guides/animations/#timing-curves","text":"Factory method Behavior Animation.linear(duration) Constant speed Animation.easeIn(duration) Slow start, fast end Animation.easeOut(duration) Fast start, slow end Animation.easeInOut(duration) Slow start and end Animation.spring(response, damping) Physics-based spring All timing curves accept a duration parameter in seconds (default: 0.3 ): nib . Animation . linear ( duration = 0.5 ) nib . Animation . easeInOut ( duration = 1.0 ) nib . Animation . easeOut ( duration = 0.15 )","title":"Timing curves"},{"location":"guides/animations/#spring-animation","text":"Spring animations have two parameters: response -- how quickly the spring settles (lower = faster, default 0.3 ) damping -- how much the spring bounces ( 0.0 = bounces forever, 1.0 = no bounce, default 0.7 ) # Snappy spring with slight bounce nib . Animation . spring ( response = 0.3 , damping = 0.7 ) # Bouncy spring nib . Animation . spring ( response = 0.4 , damping = 0.4 ) # Stiff spring, no bounce nib . Animation . spring ( response = 0.2 , damping = 1.0 )","title":"Spring animation"},{"location":"guides/animations/#presets","text":"Four presets are available for common cases: nib . Animation . default # easeInOut(0.3) nib . Animation . fast # easeOut(0.15) nib . Animation . slow # easeInOut(0.5) nib . Animation . bouncy # spring(response=0.3, damping=0.5)","title":"Presets"},{"location":"guides/animations/#example-animated-counter","text":"import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number\" ) app . width = 200 app . height = 150 count = 0 label = nib . Text ( \"0\" , font = nib . Font . LARGE_TITLE , animation = nib . Animation . spring ()) def increment (): nonlocal count count += 1 label . content = str ( count ) app . build ( nib . VStack ( controls = [ label , nib . Button ( \"Add\" , action = increment ), ], spacing = 16 , padding = 24 , ) ) nib . run ( main )","title":"Example: Animated counter"},{"location":"guides/animations/#content-transitions","text":"Content transitions animate how the content of a view changes. They are most useful with Text views when the displayed value updates. Apply with the content_transition parameter: nib . Text ( \"42\" , content_transition = nib . ContentTransition . NUMERIC_TEXT ) Transition Effect ContentTransition.IDENTITY No animation (default) ContentTransition.INTERPOLATE Smoothly interpolate between old and new content ContentTransition.OPACITY Cross-fade between old and new content ContentTransition.NUMERIC_TEXT Roll digits up when numbers increase ContentTransition.NUMERIC_TEXT_DOWN Roll digits down when numbers decrease","title":"Content Transitions"},{"location":"guides/animations/#numeric-text-transition","text":"NUMERIC_TEXT is ideal for counters, timers, and scores. Digits roll upward when the number increases: import nib def main ( app : nib . App ): app . title = \"Score\" app . icon = nib . SFSymbol ( \"star\" ) app . width = 200 app . height = 150 score = 0 score_label = nib . Text ( \"0\" , font = nib . Font . system ( 48 , nib . FontWeight . BOLD ), content_transition = nib . ContentTransition . NUMERIC_TEXT , animation = nib . Animation . spring (), ) def add_point (): nonlocal score score += 10 score_label . content = str ( score ) app . build ( nib . VStack ( controls = [ score_label , nib . Button ( \"+10\" , action = add_point )], spacing = 16 , padding = 24 , ) ) nib . run ( main ) Tip Pair content_transition with animation for the best effect. The animation controls the timing curve, while the content transition controls the visual style.","title":"Numeric text transition"},{"location":"guides/animations/#view-transitions","text":"View transitions animate when a view appears or disappears from the view hierarchy. Apply with the transition parameter. nib . Text ( \"Appearing!\" , transition = nib . Transition . OPACITY )","title":"View Transitions"},{"location":"guides/animations/#simple-transitions","text":"Transition Effect Transition.IDENTITY No animation Transition.OPACITY Fade in/out Transition.SCALE Scale up from center on appear, scale down on disappear Transition.SLIDE Slide in from leading edge, slide out to trailing edge Transition.MOVE_LEADING Move in from the left Transition.MOVE_TRAILING Move in from the right Transition.MOVE_TOP Move in from the top Transition.MOVE_BOTTOM Move in from the bottom Transition.PUSH Push new content in, push old content out","title":"Simple transitions"},{"location":"guides/animations/#asymmetric-transitions","text":"Use different animations for appearing and disappearing: nib . Text ( \"Slide in, fade out\" , transition = nib . Transition . asymmetric ( insertion = nib . Transition . SLIDE , removal = nib . Transition . OPACITY , ), ) nib . Text ( \"Scale in, move out\" , transition = nib . Transition . asymmetric ( insertion = nib . Transition . SCALE , removal = nib . Transition . MOVE_BOTTOM , ), )","title":"Asymmetric transitions"},{"location":"guides/animations/#combined-transitions","text":"Apply multiple transition effects simultaneously: nib . Text ( \"Fade and scale together\" , transition = nib . Transition . combined ( nib . Transition . OPACITY , nib . Transition . SCALE , ), )","title":"Combined transitions"},{"location":"guides/animations/#custom-keyframe-transitions","text":"Build fully custom transitions with keyframe interpolation: # Custom swoosh transition swoosh = ( nib . Transition . custom ( \"swoosh\" ) . at ( 0.0 , opacity = 0 , scale = 0.5 , offset_x =- 50 ) . at ( 0.5 , opacity = 1 , scale = 1.1 , offset_x = 10 ) . at ( 1.0 , opacity = 1 , scale = 1.0 , offset_x = 0 ) . build () ) nib . Text ( \"Swoosh!\" , transition = swoosh ) Keyframe properties: Property Description opacity View opacity (0.0 to 1.0) scale Scale factor (1.0 = normal) blur Gaussian blur radius offset_x Horizontal offset in points offset_y Vertical offset in points","title":"Custom keyframe transitions"},{"location":"guides/animations/#pre-built-custom-transitions","text":"Nib includes two ready-made custom transitions: # Pop-fade: scales up slightly while fading in nib . Text ( \"Pop!\" , transition = nib . Transition . pop_fade ()) # Bounce-in: overshoots then settles nib . Text ( \"Bounce!\" , transition = nib . Transition . bounce_in ())","title":"Pre-built custom transitions"},{"location":"guides/animations/#example-animated-visibility-toggle","text":"Combine animation and transition with the visible property to animate showing and hiding views: import nib def main ( app : nib . App ): app . title = \"Toggle View\" app . icon = nib . SFSymbol ( \"eye\" ) app . width = 280 app . height = 250 detail = nib . VStack ( controls = [ nib . Text ( \"Detail Panel\" , font = nib . Font . HEADLINE ), nib . Text ( \"This panel fades and scales in.\" , foreground_color = nib . Color . SECONDARY ), ], spacing = 8 , padding = 16 , background = nib . Rectangle ( corner_radius = 10 , fill = \"#1c1c1e\" ), transition = nib . Transition . combined ( nib . Transition . OPACITY , nib . Transition . SCALE ), animation = nib . Animation . spring (), ) def toggle (): detail . visible = not detail . visible app . build ( nib . VStack ( controls = [ nib . Button ( \"Toggle Detail\" , action = toggle ), detail , ], spacing = 16 , padding = 24 , animation = nib . Animation . easeInOut ( 0.3 ), ) ) nib . run ( main )","title":"Example: Animated Visibility Toggle"},{"location":"guides/assets/","text":"Nib provides an asset system for managing images, fonts, and other files used by your application. Assets are resolved automatically in both development and bundled modes. Assets directory \u00b6 Place your asset files in an assets/ directory next to your script: myapp/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main.py \u2502 \u2514\u2500\u2500 assets/ \u2502 \u251c\u2500\u2500 logo.png \u2502 \u251c\u2500\u2500 icon.png \u2502 \u2514\u2500\u2500 fonts/ \u2502 \u2514\u2500\u2500 Geist-Regular.ttf Nib auto-detects the assets directory by searching these locations (in order): <script_dir>/assets -- same directory as your main script <script_dir>/../assets -- parent directory (if your script is in src/ ) <script_dir>/src/assets -- src/assets from the project root Note The nib create command scaffolds a project with src/assets/ already in place. Manual configuration \u00b6 If your assets are in a non-standard location, set the path explicitly: import nib nib . App . set_assets_dir ( \"path/to/my/assets\" ) Relative paths are resolved relative to your script's directory. You can also pass an absolute path: nib . App . set_assets_dir ( \"/Users/me/shared-assets\" ) Or set it when calling nib.run() : nib . run ( main , assets_dir = \"my_assets\" ) Resolving asset paths \u00b6 Use App.resolve_asset() to convert a relative asset path to an absolute path: logo_path = nib . App . resolve_asset ( \"images/logo.png\" ) # Returns: \"/Users/me/myapp/src/assets/images/logo.png\" The method handles both development and bundled modes transparently. Resolution rules \u00b6 Absolute paths ( /Users/me/file.png ) are returned as-is URLs ( https://example.com/image.png ) are returned as-is Relative paths ( images/logo.png ) are resolved relative to the assets directory If the asset is not found, an empty string is returned and a warning is logged Using assets in views \u00b6 Images \u00b6 The Image view resolves paths relative to the assets directory automatically: # Resolves to assets/logo.png nib . Image ( source = \"logo.png\" ) # Subdirectory nib . Image ( source = \"images/hero.png\" ) # Absolute path (bypasses assets resolution) nib . Image ( source = \"/Users/me/Desktop/photo.jpg\" ) # URL (downloaded by Swift runtime) nib . Image ( source = \"https://example.com/image.png\" ) Fonts \u00b6 Font files placed in the assets directory are auto-detected. See the Custom Fonts guide for details. Other files \u00b6 For non-view assets (data files, templates, etc.), use resolve_asset() to get the path and then read the file normally: config_path = nib . App . resolve_asset ( \"config.json\" ) if config_path : import json with open ( config_path ) as f : config = json . load ( f ) Development vs. bundled mode \u00b6 The asset system works transparently across both modes: Development mode ( nib run ) \u00b6 In development mode, asset paths point directly to your project's assets/ directory on disk. Changes to asset files are picked up immediately. Project directory : src / assets / logo . png -> resolves to / Users / me / myapp / src / assets / logo . png Bundled mode ( nib build ) \u00b6 When you build a standalone .app bundle with nib build , assets are copied into the Contents/Resources/assets directory inside the app bundle: MyApp.app/ \u2514\u2500\u2500 Contents/ \u251c\u2500\u2500 MacOS/ \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 Resources/ \u251c\u2500\u2500 app/ \u2502 \u2514\u2500\u2500 main.py (or .pyc) \u2514\u2500\u2500 assets/ \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 fonts/ \u2514\u2500\u2500 Geist-Regular.ttf Nib detects bundled mode automatically and resolves assets from Contents/Resources/assets . No code changes are needed when switching between development and production. Organizing assets \u00b6 A recommended structure for larger projects: assets/ \u251c\u2500\u2500 images/ \u2502 \u251c\u2500\u2500 logo.png \u2502 \u251c\u2500\u2500 icon.png \u2502 \u2514\u2500\u2500 backgrounds/ \u2502 \u2514\u2500\u2500 hero.png \u251c\u2500\u2500 fonts/ \u2502 \u251c\u2500\u2500 Geist-Regular.ttf \u2502 \u2514\u2500\u2500 Geist-Bold.ttf \u2514\u2500\u2500 data/ \u2514\u2500\u2500 defaults.json Use subdirectory paths when referencing assets: nib . Image ( source = \"images/logo.png\" ) nib . Image ( source = \"images/backgrounds/hero.png\" ) config_path = nib . App . resolve_asset ( \"data/defaults.json\" ) Complete example \u00b6 import nib import json def main ( app : nib . App ): app . title = \"Gallery\" app . icon = nib . SFSymbol ( \"photo.stack\" ) app . width = 350 app . height = 400 # Load image names from a JSON manifest in assets manifest_path = nib . App . resolve_asset ( \"manifest.json\" ) if manifest_path : with open ( manifest_path ) as f : image_names = json . load ( f ) else : image_names = [ \"photo1.png\" , \"photo2.png\" ] current_index = 0 image_view = nib . Image ( source = f \"images/ { image_names [ current_index ] } \" , width = 300 , height = 250 , corner_radius = 8 , ) counter = nib . Text ( f \"1 / { len ( image_names ) } \" , foreground_color = nib . Color . GRAY , ) def next_image (): nonlocal current_index current_index = ( current_index + 1 ) % len ( image_names ) image_view . source = f \"images/ { image_names [ current_index ] } \" counter . content = f \" { current_index + 1 } / { len ( image_names ) } \" def prev_image (): nonlocal current_index current_index = ( current_index - 1 ) % len ( image_names ) image_view . source = f \"images/ { image_names [ current_index ] } \" counter . content = f \" { current_index + 1 } / { len ( image_names ) } \" app . build ( nib . VStack ( controls = [ nib . Text ( \"Photo Gallery\" , font = nib . Font . TITLE ), image_view , nib . HStack ( controls = [ nib . Button ( \"Previous\" , action = prev_image ), nib . Spacer (), counter , nib . Spacer (), nib . Button ( \"Next\" , action = next_image ), ], ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Tip Use nib.App.resolve_asset() only when you need the absolute path for Python file operations. For view parameters like nib.Image(source=...) , pass the relative path directly -- the Swift runtime resolves it automatically.","title":"Assets"},{"location":"guides/assets/#assets-directory","text":"Place your asset files in an assets/ directory next to your script: myapp/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main.py \u2502 \u2514\u2500\u2500 assets/ \u2502 \u251c\u2500\u2500 logo.png \u2502 \u251c\u2500\u2500 icon.png \u2502 \u2514\u2500\u2500 fonts/ \u2502 \u2514\u2500\u2500 Geist-Regular.ttf Nib auto-detects the assets directory by searching these locations (in order): <script_dir>/assets -- same directory as your main script <script_dir>/../assets -- parent directory (if your script is in src/ ) <script_dir>/src/assets -- src/assets from the project root Note The nib create command scaffolds a project with src/assets/ already in place.","title":"Assets directory"},{"location":"guides/assets/#manual-configuration","text":"If your assets are in a non-standard location, set the path explicitly: import nib nib . App . set_assets_dir ( \"path/to/my/assets\" ) Relative paths are resolved relative to your script's directory. You can also pass an absolute path: nib . App . set_assets_dir ( \"/Users/me/shared-assets\" ) Or set it when calling nib.run() : nib . run ( main , assets_dir = \"my_assets\" )","title":"Manual configuration"},{"location":"guides/assets/#resolving-asset-paths","text":"Use App.resolve_asset() to convert a relative asset path to an absolute path: logo_path = nib . App . resolve_asset ( \"images/logo.png\" ) # Returns: \"/Users/me/myapp/src/assets/images/logo.png\" The method handles both development and bundled modes transparently.","title":"Resolving asset paths"},{"location":"guides/assets/#resolution-rules","text":"Absolute paths ( /Users/me/file.png ) are returned as-is URLs ( https://example.com/image.png ) are returned as-is Relative paths ( images/logo.png ) are resolved relative to the assets directory If the asset is not found, an empty string is returned and a warning is logged","title":"Resolution rules"},{"location":"guides/assets/#using-assets-in-views","text":"","title":"Using assets in views"},{"location":"guides/assets/#images","text":"The Image view resolves paths relative to the assets directory automatically: # Resolves to assets/logo.png nib . Image ( source = \"logo.png\" ) # Subdirectory nib . Image ( source = \"images/hero.png\" ) # Absolute path (bypasses assets resolution) nib . Image ( source = \"/Users/me/Desktop/photo.jpg\" ) # URL (downloaded by Swift runtime) nib . Image ( source = \"https://example.com/image.png\" )","title":"Images"},{"location":"guides/assets/#fonts","text":"Font files placed in the assets directory are auto-detected. See the Custom Fonts guide for details.","title":"Fonts"},{"location":"guides/assets/#other-files","text":"For non-view assets (data files, templates, etc.), use resolve_asset() to get the path and then read the file normally: config_path = nib . App . resolve_asset ( \"config.json\" ) if config_path : import json with open ( config_path ) as f : config = json . load ( f )","title":"Other files"},{"location":"guides/assets/#development-vs-bundled-mode","text":"The asset system works transparently across both modes:","title":"Development vs. bundled mode"},{"location":"guides/assets/#development-mode-nib-run","text":"In development mode, asset paths point directly to your project's assets/ directory on disk. Changes to asset files are picked up immediately. Project directory : src / assets / logo . png -> resolves to / Users / me / myapp / src / assets / logo . png","title":"Development mode (nib run)"},{"location":"guides/assets/#bundled-mode-nib-build","text":"When you build a standalone .app bundle with nib build , assets are copied into the Contents/Resources/assets directory inside the app bundle: MyApp.app/ \u2514\u2500\u2500 Contents/ \u251c\u2500\u2500 MacOS/ \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 Resources/ \u251c\u2500\u2500 app/ \u2502 \u2514\u2500\u2500 main.py (or .pyc) \u2514\u2500\u2500 assets/ \u251c\u2500\u2500 logo.png \u2514\u2500\u2500 fonts/ \u2514\u2500\u2500 Geist-Regular.ttf Nib detects bundled mode automatically and resolves assets from Contents/Resources/assets . No code changes are needed when switching between development and production.","title":"Bundled mode (nib build)"},{"location":"guides/assets/#organizing-assets","text":"A recommended structure for larger projects: assets/ \u251c\u2500\u2500 images/ \u2502 \u251c\u2500\u2500 logo.png \u2502 \u251c\u2500\u2500 icon.png \u2502 \u2514\u2500\u2500 backgrounds/ \u2502 \u2514\u2500\u2500 hero.png \u251c\u2500\u2500 fonts/ \u2502 \u251c\u2500\u2500 Geist-Regular.ttf \u2502 \u2514\u2500\u2500 Geist-Bold.ttf \u2514\u2500\u2500 data/ \u2514\u2500\u2500 defaults.json Use subdirectory paths when referencing assets: nib . Image ( source = \"images/logo.png\" ) nib . Image ( source = \"images/backgrounds/hero.png\" ) config_path = nib . App . resolve_asset ( \"data/defaults.json\" )","title":"Organizing assets"},{"location":"guides/assets/#complete-example","text":"import nib import json def main ( app : nib . App ): app . title = \"Gallery\" app . icon = nib . SFSymbol ( \"photo.stack\" ) app . width = 350 app . height = 400 # Load image names from a JSON manifest in assets manifest_path = nib . App . resolve_asset ( \"manifest.json\" ) if manifest_path : with open ( manifest_path ) as f : image_names = json . load ( f ) else : image_names = [ \"photo1.png\" , \"photo2.png\" ] current_index = 0 image_view = nib . Image ( source = f \"images/ { image_names [ current_index ] } \" , width = 300 , height = 250 , corner_radius = 8 , ) counter = nib . Text ( f \"1 / { len ( image_names ) } \" , foreground_color = nib . Color . GRAY , ) def next_image (): nonlocal current_index current_index = ( current_index + 1 ) % len ( image_names ) image_view . source = f \"images/ { image_names [ current_index ] } \" counter . content = f \" { current_index + 1 } / { len ( image_names ) } \" def prev_image (): nonlocal current_index current_index = ( current_index - 1 ) % len ( image_names ) image_view . source = f \"images/ { image_names [ current_index ] } \" counter . content = f \" { current_index + 1 } / { len ( image_names ) } \" app . build ( nib . VStack ( controls = [ nib . Text ( \"Photo Gallery\" , font = nib . Font . TITLE ), image_view , nib . HStack ( controls = [ nib . Button ( \"Previous\" , action = prev_image ), nib . Spacer (), counter , nib . Spacer (), nib . Button ( \"Next\" , action = next_image ), ], ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Tip Use nib.App.resolve_asset() only when you need the absolute path for Python file operations. For view parameters like nib.Image(source=...) , pass the relative path directly -- the Swift runtime resolves it automatically.","title":"Complete example"},{"location":"guides/canvas/","text":"The Canvas view provides a drawing surface backed by Core Graphics. You can render shapes, lines, text, and images using declarative drawing commands from the nib.draw module. Creating a canvas \u00b6 import nib canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#1a1a1a\" ) Parameter Type Default Description width float 100 Width of the drawing area in points height float 100 Height of the drawing area in points background_color str None Background color as hex string, or None for transparent enable_gestures bool False Enable pan/hover gesture tracking The canvas also accepts all standard view modifiers ( padding , opacity , corner_radius , etc.) as keyword arguments. Drawing commands \u00b6 All drawing commands live in the nib.draw module. Pass a list of commands to canvas.draw() : canvas . draw ([ nib . draw . Rect ( x = 10 , y = 10 , width = 100 , height = 50 , fill = \"#3498db\" ), nib . draw . Circle ( cx = 200 , cy = 100 , radius = 40 , fill = \"#e74c3c\" ), nib . draw . Line ( x1 = 10 , y1 = 200 , x2 = 390 , y2 = 200 , stroke = \"#2ecc71\" ), nib . draw . Text ( \"Hello Canvas!\" , x = 10 , y = 280 , fill = \"#ffffff\" ), ]) Rect \u00b6 Draws a rectangle, optionally with rounded corners: nib . draw . Rect ( x = 10 , y = 10 , width = 100 , height = 80 , corner_radius = 8 , fill = \"#3498db\" , stroke = \"#2980b9\" , stroke_width = 2 , opacity = 0.9 , ) Parameter Type Default Description x float -- X coordinate of top-left corner y float -- Y coordinate of top-left corner width float -- Width of the rectangle height float -- Height of the rectangle corner_radius float 0 Radius for rounded corners fill color/gradient None Fill color or gradient stroke color None Stroke color stroke_width float 1 Stroke width opacity float 1.0 Opacity from 0.0 to 1.0 blend_mode BlendMode None Compositing blend mode Circle \u00b6 Draws a circle from a center point and radius: nib . draw . Circle ( cx = 200 , cy = 100 , radius = 40 , fill = \"#e74c3c\" ) Parameter Type Default Description cx float -- X coordinate of center cy float -- Y coordinate of center radius float -- Circle radius fill color/gradient None Fill color or gradient stroke color None Stroke color stroke_width float 1 Stroke width opacity float 1.0 Opacity Ellipse \u00b6 Draws an ellipse with independent horizontal and vertical radii: nib . draw . Ellipse ( cx = 150 , cy = 100 , rx = 80 , ry = 40 , fill = \"#9b59b6\" ) Line \u00b6 Draws a straight line between two points: nib . draw . Line ( x1 = 10 , y1 = 10 , x2 = 200 , y2 = 200 , stroke = \"#000000\" , stroke_width = 2 , line_cap = \"round\" , # \"butt\", \"round\", or \"square\" ) Text \u00b6 Draws text at a position: nib . draw . Text ( \"Hello World\" , x = 10 , y = 50 , fill = \"#ffffff\" , font = nib . Font . system ( 20 , weight = nib . FontWeight . BOLD ), alignment = nib . HorizontalAlignment . CENTER , ) Parameter Type Default Description content str -- The text string to draw x float -- X coordinate of text origin y float -- Y coordinate of text origin fill color \"#000000\" Text color font Font None Font configuration alignment HorizontalAlignment \"left\" Text alignment opacity float 1.0 Opacity Arc \u00b6 Draws an arc segment: import math nib . draw . Arc ( cx = 100 , cy = 100 , radius = 50 , start_angle = 0 , end_angle = math . pi , fill = \"#f39c12\" , stroke = \"#e67e22\" , ) Path \u00b6 Draws a path from a list of points: nib . draw . Path ( points = [( 10 , 10 ), ( 100 , 50 ), ( 50 , 100 )], closed = True , fill = \"#2ecc71\" , stroke = \"#27ae60\" , stroke_width = 2 , ) Polygon \u00b6 A convenience wrapper around Path with closed=True : nib . draw . Polygon ( points = [( 100 , 10 ), ( 190 , 80 ), ( 160 , 170 ), ( 40 , 170 ), ( 10 , 80 )], fill = \"#1abc9c\" , ) BezierPath \u00b6 Draws complex curves using typed path elements: from nib.draw import BezierPath , MoveTo , CubicTo , QuadraticTo , LineTo , Close nib . draw . BezierPath ( elements = [ MoveTo ( 50 , 150 ), CubicTo ( cp1x = 50 , cp1y = 50 , cp2x = 150 , cp2y = 50 , x = 150 , y = 150 ), Close (), ], fill = \"#e74c3c\" , stroke = \"#c0392b\" , ) Available path elements: Element Parameters Description MoveTo(x, y) x, y Move to a point without drawing LineTo(x, y) x, y Draw a straight line to a point CubicTo(...) cp1x, cp1y, cp2x, cp2y, x, y Cubic bezier curve QuadraticTo(...) cp1x, cp1y, x, y, w Quadratic bezier curve Close() -- Close the path back to the start ArcTo(...) x, y, radius, rotation, large_arc, clockwise Arc segment Oval(...) x, y, width, height Ellipse inscribed in rectangle PathRect(...) x, y, width, height, border_radius Rectangle sub-path SubPath(...) x, y, elements Nested sub-path at offset Image \u00b6 Draws an image from raw bytes: with open ( \"photo.jpg\" , \"rb\" ) as f : nib . draw . Image ( data = f . read (), x = 10 , y = 10 , width = 200 , height = 150 , ) Points \u00b6 Draws a set of points with different modes: nib . draw . Points ( points = [( 10 , 10 ), ( 50 , 50 ), ( 100 , 30 ), ( 150 , 80 )], point_mode = nib . draw . PointMode . POINTS , # POINTS, LINES, or POLYGON stroke = \"#e74c3c\" , stroke_width = 5 , stroke_cap = \"round\" , ) Fill \u00b6 Fills the entire canvas with a color or gradient: nib . draw . Fill ( fill = \"#1a1a1a\" ) Colors \u00b6 All color parameters accept hex strings or nib.Color objects: # Hex strings nib . draw . Rect ( x = 0 , y = 0 , width = 100 , height = 100 , fill = \"#FF5733\" ) # nib.Color constants nib . draw . Circle ( cx = 50 , cy = 50 , radius = 30 , fill = nib . Color . RED ) Gradients \u00b6 Fill parameters on Rect , Circle , Ellipse , BezierPath , and Fill accept gradient objects instead of solid colors: LinearGradient \u00b6 nib . draw . Rect ( x = 0 , y = 0 , width = 200 , height = 100 , fill = nib . draw . LinearGradient ( start = ( 0 , 0 ), end = ( 200 , 100 ), colors = [ \"#FF0000\" , \"#0000FF\" ], stops = [ 0.0 , 1.0 ], # optional ), ) RadialGradient \u00b6 nib . draw . Circle ( cx = 100 , cy = 100 , radius = 80 , fill = nib . draw . RadialGradient ( center = ( 100 , 100 ), radius = 80 , colors = [ nib . Color . YELLOW , nib . Color . RED ], ), ) SweepGradient \u00b6 nib . draw . Circle ( cx = 100 , cy = 100 , radius = 80 , fill = nib . draw . SweepGradient ( center = ( 100 , 100 ), colors = [ nib . Color . RED , nib . Color . GREEN , nib . Color . BLUE , nib . Color . RED ], ), ) Drawing methods \u00b6 The Canvas provides three methods to manage drawing commands: canvas.draw(commands) \u00b6 Replaces all current commands and triggers a re-render: canvas . draw ([ nib . draw . Rect ( x = 0 , y = 0 , width = 100 , height = 100 , fill = \"#3498db\" ), ]) canvas.append(command) \u00b6 Adds a single command to the existing list: canvas . append ( nib . draw . Circle ( cx = 50 , cy = 50 , radius = 20 , fill = \"#e74c3c\" )) canvas.clear() \u00b6 Removes all commands and updates the display: canvas . clear () Gesture handling \u00b6 Enable gestures to respond to mouse and trackpad input on the canvas. Gestures are enabled automatically when you provide any gesture callback: canvas = nib . Canvas ( width = 400 , height = 300 , on_pan_start = handle_start , on_pan_update = handle_update , on_pan_end = handle_end , on_hover = handle_hover , ) You can also set gesture callbacks after creation: canvas = nib . Canvas ( width = 400 , height = 300 ) canvas . on_pan_start = handle_start canvas . on_pan_update = handle_update PanEvent \u00b6 All gesture callbacks receive a PanEvent dataclass with the cursor coordinates: from nib import PanEvent def handle_update ( e : PanEvent ): print ( f \"x= { e . x } , y= { e . y } \" ) Field Type Description x float X coordinate in canvas coordinates y float Y coordinate in canvas coordinates Available gesture callbacks \u00b6 Callback Fired when on_pan_start Mouse button pressed down on canvas on_pan_update Mouse dragged while button held on_pan_end Mouse button released on_hover Mouse moves over canvas (no button held) Complete example: drawing app \u00b6 A simple drawing application that lets you draw freehand lines by dragging the mouse: import nib def main ( app : nib . App ): app . title = \"Draw\" app . icon = nib . SFSymbol ( \"pencil.tip\" ) app . width = 420 app . height = 380 canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#ffffff\" , ) color = \"#000000\" stroke_width = 3 last_pos = None def on_start ( e : nib . PanEvent ): nonlocal last_pos last_pos = ( e . x , e . y ) def on_update ( e : nib . PanEvent ): nonlocal last_pos if last_pos : canvas . append ( nib . draw . Line ( x1 = last_pos [ 0 ], y1 = last_pos [ 1 ], x2 = e . x , y2 = e . y , stroke = color , stroke_width = stroke_width , line_cap = \"round\" , )) last_pos = ( e . x , e . y ) def on_end ( e : nib . PanEvent ): nonlocal last_pos last_pos = None canvas . on_pan_start = on_start canvas . on_pan_update = on_update canvas . on_pan_end = on_end def clear_canvas (): canvas . clear () def set_black (): nonlocal color color = \"#000000\" def set_red (): nonlocal color color = \"#e74c3c\" def set_blue (): nonlocal color color = \"#3498db\" app . build ( nib . VStack ( controls = [ canvas , nib . HStack ( controls = [ nib . Button ( \"Black\" , action = set_black ), nib . Button ( \"Red\" , action = set_red ), nib . Button ( \"Blue\" , action = set_blue ), nib . Spacer (), nib . Button ( \"Clear\" , action = clear_canvas ), ], spacing = 8 , ), ], spacing = 8 , padding = 10 , ) ) nib . run ( main ) Tip Use canvas.append() inside on_pan_update for efficient incremental drawing. Using canvas.draw() with the full command list on every mouse move would be slower for complex drawings. Reactive properties \u00b6 Canvas dimensions and background color are reactive. Changing them triggers a re-render: canvas . canvas_width = 500 canvas . canvas_height = 400 canvas . background_color = \"#2c3e50\"","title":"Canvas Drawing"},{"location":"guides/canvas/#creating-a-canvas","text":"import nib canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#1a1a1a\" ) Parameter Type Default Description width float 100 Width of the drawing area in points height float 100 Height of the drawing area in points background_color str None Background color as hex string, or None for transparent enable_gestures bool False Enable pan/hover gesture tracking The canvas also accepts all standard view modifiers ( padding , opacity , corner_radius , etc.) as keyword arguments.","title":"Creating a canvas"},{"location":"guides/canvas/#drawing-commands","text":"All drawing commands live in the nib.draw module. Pass a list of commands to canvas.draw() : canvas . draw ([ nib . draw . Rect ( x = 10 , y = 10 , width = 100 , height = 50 , fill = \"#3498db\" ), nib . draw . Circle ( cx = 200 , cy = 100 , radius = 40 , fill = \"#e74c3c\" ), nib . draw . Line ( x1 = 10 , y1 = 200 , x2 = 390 , y2 = 200 , stroke = \"#2ecc71\" ), nib . draw . Text ( \"Hello Canvas!\" , x = 10 , y = 280 , fill = \"#ffffff\" ), ])","title":"Drawing commands"},{"location":"guides/canvas/#rect","text":"Draws a rectangle, optionally with rounded corners: nib . draw . Rect ( x = 10 , y = 10 , width = 100 , height = 80 , corner_radius = 8 , fill = \"#3498db\" , stroke = \"#2980b9\" , stroke_width = 2 , opacity = 0.9 , ) Parameter Type Default Description x float -- X coordinate of top-left corner y float -- Y coordinate of top-left corner width float -- Width of the rectangle height float -- Height of the rectangle corner_radius float 0 Radius for rounded corners fill color/gradient None Fill color or gradient stroke color None Stroke color stroke_width float 1 Stroke width opacity float 1.0 Opacity from 0.0 to 1.0 blend_mode BlendMode None Compositing blend mode","title":"Rect"},{"location":"guides/canvas/#circle","text":"Draws a circle from a center point and radius: nib . draw . Circle ( cx = 200 , cy = 100 , radius = 40 , fill = \"#e74c3c\" ) Parameter Type Default Description cx float -- X coordinate of center cy float -- Y coordinate of center radius float -- Circle radius fill color/gradient None Fill color or gradient stroke color None Stroke color stroke_width float 1 Stroke width opacity float 1.0 Opacity","title":"Circle"},{"location":"guides/canvas/#ellipse","text":"Draws an ellipse with independent horizontal and vertical radii: nib . draw . Ellipse ( cx = 150 , cy = 100 , rx = 80 , ry = 40 , fill = \"#9b59b6\" )","title":"Ellipse"},{"location":"guides/canvas/#line","text":"Draws a straight line between two points: nib . draw . Line ( x1 = 10 , y1 = 10 , x2 = 200 , y2 = 200 , stroke = \"#000000\" , stroke_width = 2 , line_cap = \"round\" , # \"butt\", \"round\", or \"square\" )","title":"Line"},{"location":"guides/canvas/#text","text":"Draws text at a position: nib . draw . Text ( \"Hello World\" , x = 10 , y = 50 , fill = \"#ffffff\" , font = nib . Font . system ( 20 , weight = nib . FontWeight . BOLD ), alignment = nib . HorizontalAlignment . CENTER , ) Parameter Type Default Description content str -- The text string to draw x float -- X coordinate of text origin y float -- Y coordinate of text origin fill color \"#000000\" Text color font Font None Font configuration alignment HorizontalAlignment \"left\" Text alignment opacity float 1.0 Opacity","title":"Text"},{"location":"guides/canvas/#arc","text":"Draws an arc segment: import math nib . draw . Arc ( cx = 100 , cy = 100 , radius = 50 , start_angle = 0 , end_angle = math . pi , fill = \"#f39c12\" , stroke = \"#e67e22\" , )","title":"Arc"},{"location":"guides/canvas/#path","text":"Draws a path from a list of points: nib . draw . Path ( points = [( 10 , 10 ), ( 100 , 50 ), ( 50 , 100 )], closed = True , fill = \"#2ecc71\" , stroke = \"#27ae60\" , stroke_width = 2 , )","title":"Path"},{"location":"guides/canvas/#polygon","text":"A convenience wrapper around Path with closed=True : nib . draw . Polygon ( points = [( 100 , 10 ), ( 190 , 80 ), ( 160 , 170 ), ( 40 , 170 ), ( 10 , 80 )], fill = \"#1abc9c\" , )","title":"Polygon"},{"location":"guides/canvas/#bezierpath","text":"Draws complex curves using typed path elements: from nib.draw import BezierPath , MoveTo , CubicTo , QuadraticTo , LineTo , Close nib . draw . BezierPath ( elements = [ MoveTo ( 50 , 150 ), CubicTo ( cp1x = 50 , cp1y = 50 , cp2x = 150 , cp2y = 50 , x = 150 , y = 150 ), Close (), ], fill = \"#e74c3c\" , stroke = \"#c0392b\" , ) Available path elements: Element Parameters Description MoveTo(x, y) x, y Move to a point without drawing LineTo(x, y) x, y Draw a straight line to a point CubicTo(...) cp1x, cp1y, cp2x, cp2y, x, y Cubic bezier curve QuadraticTo(...) cp1x, cp1y, x, y, w Quadratic bezier curve Close() -- Close the path back to the start ArcTo(...) x, y, radius, rotation, large_arc, clockwise Arc segment Oval(...) x, y, width, height Ellipse inscribed in rectangle PathRect(...) x, y, width, height, border_radius Rectangle sub-path SubPath(...) x, y, elements Nested sub-path at offset","title":"BezierPath"},{"location":"guides/canvas/#image","text":"Draws an image from raw bytes: with open ( \"photo.jpg\" , \"rb\" ) as f : nib . draw . Image ( data = f . read (), x = 10 , y = 10 , width = 200 , height = 150 , )","title":"Image"},{"location":"guides/canvas/#points","text":"Draws a set of points with different modes: nib . draw . Points ( points = [( 10 , 10 ), ( 50 , 50 ), ( 100 , 30 ), ( 150 , 80 )], point_mode = nib . draw . PointMode . POINTS , # POINTS, LINES, or POLYGON stroke = \"#e74c3c\" , stroke_width = 5 , stroke_cap = \"round\" , )","title":"Points"},{"location":"guides/canvas/#fill","text":"Fills the entire canvas with a color or gradient: nib . draw . Fill ( fill = \"#1a1a1a\" )","title":"Fill"},{"location":"guides/canvas/#colors","text":"All color parameters accept hex strings or nib.Color objects: # Hex strings nib . draw . Rect ( x = 0 , y = 0 , width = 100 , height = 100 , fill = \"#FF5733\" ) # nib.Color constants nib . draw . Circle ( cx = 50 , cy = 50 , radius = 30 , fill = nib . Color . RED )","title":"Colors"},{"location":"guides/canvas/#gradients","text":"Fill parameters on Rect , Circle , Ellipse , BezierPath , and Fill accept gradient objects instead of solid colors:","title":"Gradients"},{"location":"guides/canvas/#lineargradient","text":"nib . draw . Rect ( x = 0 , y = 0 , width = 200 , height = 100 , fill = nib . draw . LinearGradient ( start = ( 0 , 0 ), end = ( 200 , 100 ), colors = [ \"#FF0000\" , \"#0000FF\" ], stops = [ 0.0 , 1.0 ], # optional ), )","title":"LinearGradient"},{"location":"guides/canvas/#radialgradient","text":"nib . draw . Circle ( cx = 100 , cy = 100 , radius = 80 , fill = nib . draw . RadialGradient ( center = ( 100 , 100 ), radius = 80 , colors = [ nib . Color . YELLOW , nib . Color . RED ], ), )","title":"RadialGradient"},{"location":"guides/canvas/#sweepgradient","text":"nib . draw . Circle ( cx = 100 , cy = 100 , radius = 80 , fill = nib . draw . SweepGradient ( center = ( 100 , 100 ), colors = [ nib . Color . RED , nib . Color . GREEN , nib . Color . BLUE , nib . Color . RED ], ), )","title":"SweepGradient"},{"location":"guides/canvas/#drawing-methods","text":"The Canvas provides three methods to manage drawing commands:","title":"Drawing methods"},{"location":"guides/canvas/#canvasdrawcommands","text":"Replaces all current commands and triggers a re-render: canvas . draw ([ nib . draw . Rect ( x = 0 , y = 0 , width = 100 , height = 100 , fill = \"#3498db\" ), ])","title":"canvas.draw(commands)"},{"location":"guides/canvas/#canvasappendcommand","text":"Adds a single command to the existing list: canvas . append ( nib . draw . Circle ( cx = 50 , cy = 50 , radius = 20 , fill = \"#e74c3c\" ))","title":"canvas.append(command)"},{"location":"guides/canvas/#canvasclear","text":"Removes all commands and updates the display: canvas . clear ()","title":"canvas.clear()"},{"location":"guides/canvas/#gesture-handling","text":"Enable gestures to respond to mouse and trackpad input on the canvas. Gestures are enabled automatically when you provide any gesture callback: canvas = nib . Canvas ( width = 400 , height = 300 , on_pan_start = handle_start , on_pan_update = handle_update , on_pan_end = handle_end , on_hover = handle_hover , ) You can also set gesture callbacks after creation: canvas = nib . Canvas ( width = 400 , height = 300 ) canvas . on_pan_start = handle_start canvas . on_pan_update = handle_update","title":"Gesture handling"},{"location":"guides/canvas/#panevent","text":"All gesture callbacks receive a PanEvent dataclass with the cursor coordinates: from nib import PanEvent def handle_update ( e : PanEvent ): print ( f \"x= { e . x } , y= { e . y } \" ) Field Type Description x float X coordinate in canvas coordinates y float Y coordinate in canvas coordinates","title":"PanEvent"},{"location":"guides/canvas/#available-gesture-callbacks","text":"Callback Fired when on_pan_start Mouse button pressed down on canvas on_pan_update Mouse dragged while button held on_pan_end Mouse button released on_hover Mouse moves over canvas (no button held)","title":"Available gesture callbacks"},{"location":"guides/canvas/#complete-example-drawing-app","text":"A simple drawing application that lets you draw freehand lines by dragging the mouse: import nib def main ( app : nib . App ): app . title = \"Draw\" app . icon = nib . SFSymbol ( \"pencil.tip\" ) app . width = 420 app . height = 380 canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#ffffff\" , ) color = \"#000000\" stroke_width = 3 last_pos = None def on_start ( e : nib . PanEvent ): nonlocal last_pos last_pos = ( e . x , e . y ) def on_update ( e : nib . PanEvent ): nonlocal last_pos if last_pos : canvas . append ( nib . draw . Line ( x1 = last_pos [ 0 ], y1 = last_pos [ 1 ], x2 = e . x , y2 = e . y , stroke = color , stroke_width = stroke_width , line_cap = \"round\" , )) last_pos = ( e . x , e . y ) def on_end ( e : nib . PanEvent ): nonlocal last_pos last_pos = None canvas . on_pan_start = on_start canvas . on_pan_update = on_update canvas . on_pan_end = on_end def clear_canvas (): canvas . clear () def set_black (): nonlocal color color = \"#000000\" def set_red (): nonlocal color color = \"#e74c3c\" def set_blue (): nonlocal color color = \"#3498db\" app . build ( nib . VStack ( controls = [ canvas , nib . HStack ( controls = [ nib . Button ( \"Black\" , action = set_black ), nib . Button ( \"Red\" , action = set_red ), nib . Button ( \"Blue\" , action = set_blue ), nib . Spacer (), nib . Button ( \"Clear\" , action = clear_canvas ), ], spacing = 8 , ), ], spacing = 8 , padding = 10 , ) ) nib . run ( main ) Tip Use canvas.append() inside on_pan_update for efficient incremental drawing. Using canvas.draw() with the full command list on every mouse move would be slower for complex drawings.","title":"Complete example: drawing app"},{"location":"guides/canvas/#reactive-properties","text":"Canvas dimensions and background color are reactive. Changing them triggers a re-render: canvas . canvas_width = 500 canvas . canvas_height = 400 canvas . background_color = \"#2c3e50\"","title":"Reactive properties"},{"location":"guides/charts/","text":"Nib integrates with Swift Charts to provide native, GPU-accelerated data visualizations. You define charts using a declarative API: provide your data as a list of dictionaries, and specify mark types that map data fields to visual properties. Creating a chart \u00b6 import nib chart = nib . Chart ( data = [ { \"month\" : \"Jan\" , \"sales\" : 100 }, { \"month\" : \"Feb\" , \"sales\" : 150 }, { \"month\" : \"Mar\" , \"sales\" : 200 }, { \"month\" : \"Apr\" , \"sales\" : 175 }, { \"month\" : \"May\" , \"sales\" : 250 }, ], marks = [ nib . LineMark ( x = \"month\" , y = \"sales\" )], width = 350 , height = 220 , ) The Chart constructor takes: Parameter Type Description data list[dict] List of data rows as dictionaries marks list[BaseMark] List of mark objects defining the visualization x_axis ChartAxis X-axis configuration (optional) y_axis ChartAxis Y-axis configuration (optional) legend ChartLegend or bool Legend configuration, or False to hide chart_background str Background color for the entire chart plot_background str Background color for the plot area only Standard view modifiers ( width , height , padding , corner_radius , etc.) are also supported. Data format \u00b6 Data is a list of dictionaries where each dictionary represents a row. The keys correspond to the field names used in your marks: data = [ { \"month\" : \"Jan\" , \"revenue\" : 4200 , \"expenses\" : 3100 }, { \"month\" : \"Feb\" , \"revenue\" : 5100 , \"expenses\" : 3400 }, { \"month\" : \"Mar\" , \"revenue\" : 4800 , \"expenses\" : 3200 }, ] Note Nib converts row-based data to a columnar format internally for efficient serialization. You always work with the row-based format in your Python code. Mark types \u00b6 LineMark \u00b6 Connects data points with a continuous line. Best for trends over time: nib . LineMark ( x = \"month\" , y = \"sales\" ) Parameter Type Description x str or PlottableField Data field for x-axis y str or PlottableField Data field for y-axis foreground_style str or PlottableField Line color or field for multi-series symbol SymbolShape or PlottableField Marker shape at each point interpolation InterpolationMethod Curve type between points line_width float Line width in points opacity float Opacity from 0.0 to 1.0 BarMark \u00b6 Displays data as rectangular bars. Best for comparing categories: nib . BarMark ( x = \"category\" , y = \"value\" ) Parameter Type Description x str or PlottableField Data field for x-axis y str or PlottableField Data field for y-axis width float Fixed bar width in points height float Fixed bar height in points foreground_style str or PlottableField Bar color or field for grouping stacking StackingMethod Stacking mode for multi-series corner_radius float Rounded corner radius opacity float Opacity from 0.0 to 1.0 AreaMark \u00b6 Fills the region between a line and a baseline: nib . AreaMark ( x = \"date\" , y = \"revenue\" , foreground_style = \"#3B82F6\" , opacity = 0.3 ) Parameter Type Description x str or PlottableField Data field for x-axis y str or PlottableField Data field for upper boundary y_start str or PlottableField Data field for lower boundary (optional) foreground_style str or PlottableField Fill color or field for multi-series interpolation InterpolationMethod Curve type stacking StackingMethod Stacking mode opacity float Opacity from 0.0 to 1.0 PointMark \u00b6 Displays individual data points as symbols. Best for scatter plots: nib . PointMark ( x = \"height\" , y = \"weight\" , foreground_style = \"#EF4444\" ) Parameter Type Description x str or PlottableField Data field for x-axis y str or PlottableField Data field for y-axis foreground_style str or PlottableField Point color or field for coloring symbol SymbolShape or PlottableField Marker shape symbol_size float Marker size in square points opacity float Opacity from 0.0 to 1.0 SectorMark \u00b6 Creates pie and donut charts: nib . SectorMark ( angle = \"value\" , foreground_style = nib . PlottableField ( \"category\" ), ) Parameter Type Description angle str or PlottableField Data field for sector sizes foreground_style str or PlottableField Color or field for per-segment colors inner_radius float Inner radius (0 = pie, >0 = donut) outer_radius float Outer radius corner_radius float Rounded segment corners opacity float Opacity from 0.0 to 1.0 RuleMark \u00b6 Draws a reference line (horizontal or vertical): # Horizontal line at y=100 nib . RuleMark ( y = 100 , foreground_style = \"#EF4444\" , line_width = 2 ) # Vertical line at x position nib . RuleMark ( x = \"2024-06-15\" , foreground_style = \"#6366F1\" ) Parameter Type Description x value or field X position for vertical rule y value or field Y position for horizontal rule x_start / x_end value or field Horizontal bounds for segments y_start / y_end value or field Vertical bounds for segments foreground_style str or PlottableField Line color line_width float Line width RectMark \u00b6 Draws filled rectangles for heatmaps and range charts: nib . RectMark ( x = \"weekday\" , y = \"hour\" , foreground_style = nib . PlottableField ( \"intensity\" ), corner_radius = 2 , ) PlottableField \u00b6 Use PlottableField to reference data columns with optional type hints: from nib import PlottableField # Simple field reference (equivalent to just passing \"month\") nib . LineMark ( x = PlottableField ( \"month\" ), y = PlottableField ( \"sales\" )) # With type hint for proper scale selection nib . LineMark ( x = PlottableField ( \"date\" , type = \"temporal\" ), y = PlottableField ( \"temperature\" , type = \"quantitative\" ), ) Available types: \"quantitative\" (numeric), \"nominal\" (categorical), \"temporal\" (dates/times). Multiple series \u00b6 To display multiple data series with automatic color assignment, pass a PlottableField as foreground_style : data = [ { \"month\" : \"Jan\" , \"value\" : 100 , \"series\" : \"Revenue\" }, { \"month\" : \"Jan\" , \"value\" : 80 , \"series\" : \"Expenses\" }, { \"month\" : \"Feb\" , \"value\" : 150 , \"series\" : \"Revenue\" }, { \"month\" : \"Feb\" , \"value\" : 90 , \"series\" : \"Expenses\" }, { \"month\" : \"Mar\" , \"value\" : 200 , \"series\" : \"Revenue\" }, { \"month\" : \"Mar\" , \"value\" : 110 , \"series\" : \"Expenses\" }, ] chart = nib . Chart ( data = data , marks = [ nib . LineMark ( x = \"month\" , y = \"value\" , foreground_style = nib . PlottableField ( \"series\" ), ), ], width = 350 , height = 220 , ) Swift Charts automatically assigns distinct colors to each unique value in the series field. Combining marks \u00b6 Combine multiple mark types in a single chart for layered visualizations: chart = nib . Chart ( data = data , marks = [ nib . AreaMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" , opacity = 0.2 ), nib . LineMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" ), nib . PointMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" ), nib . RuleMark ( y = 150 , foreground_style = \"#EF4444\" , line_width = 1 ), ], width = 350 , height = 220 , ) This creates an area chart with a line overlay, point markers at each data point, and a horizontal reference line at y=150. Axis configuration \u00b6 Use ChartAxis to customize axis appearance: chart = nib . Chart ( data = data , marks = [ nib . BarMark ( x = \"month\" , y = \"revenue\" )], x_axis = nib . ChartAxis ( label = \"Month\" , position = \"bottom\" , ), y_axis = nib . ChartAxis ( label = \"Revenue ($)\" , grid_lines = True , format = \"currency\" , grid_color = \"#333333\" , label_color = \"#666666\" , ), ) Parameter Type Default Description label str None Axis label text position str auto \"bottom\" , \"top\" , \"leading\" , or \"trailing\" grid_lines bool False Show grid lines hidden bool False Hide the axis entirely format str auto \"number\" , \"currency\" , or \"percent\" values list None Explicit tick mark values label_color str None Color for axis labels grid_color str None Color for grid lines Legend configuration \u00b6 Control the chart legend with ChartLegend : chart = nib . Chart ( data = data , marks = [ nib . LineMark ( x = \"month\" , y = \"value\" , foreground_style = nib . PlottableField ( \"series\" ))], legend = nib . ChartLegend ( position = \"bottom\" , title = \"Category\" , ), ) # Or hide the legend entirely chart = nib . Chart ( data = data , marks = [ ... ], legend = False , ) Parameter Type Description position str \"top\" , \"bottom\" , \"leading\" , \"trailing\" , or \"automatic\" hidden bool Hide the legend title str Title text displayed above legend items InterpolationMethod \u00b6 Control how lines and areas are drawn between data points: nib . LineMark ( x = \"month\" , y = \"sales\" , interpolation = nib . InterpolationMethod . MONOTONE , ) Value Description LINEAR Straight lines between points (default) MONOTONE Smooth curve that preserves monotonicity CATMULL_ROM Smooth cubic spline through all points CARDINAL Smooth curve with adjustable tension STEP_START Step at the start of each interval STEP_CENTER Step at the midpoint between points STEP_END Step at the end of each interval StackingMethod \u00b6 Control how overlapping bars or areas are stacked: nib . BarMark ( x = \"month\" , y = \"sales\" , foreground_style = nib . PlottableField ( \"region\" ), stacking = nib . StackingMethod . STANDARD , ) Value Description STANDARD Stack values on top of each other NORMALIZED Scale stacks to 100% CENTER Center stacks (stream graph effect) SymbolShape \u00b6 Marker shapes for PointMark and LineMark : nib . PointMark ( x = \"x\" , y = \"y\" , symbol = nib . SymbolShape . DIAMOND ) Available shapes: CIRCLE , SQUARE , TRIANGLE , DIAMOND , CROSS , PLUS , PENTAGON , HEXAGON . Reactive data updates \u00b6 Chart data is reactive. Updating it triggers an automatic re-render: # Replace all data chart . data = new_data # Append a single row chart . append_data ({ \"month\" : \"Jun\" , \"sales\" : 300 }) # Update a specific row chart . update_data ( 0 , { \"month\" : \"Jan\" , \"sales\" : 120 }) # Clear all data chart . clear_data () Complete example \u00b6 A sales dashboard with a bar chart, trend line, and live data updates: import nib import random def main ( app : nib . App ): app . title = \"Sales\" app . icon = nib . SFSymbol ( \"chart.bar.fill\" ) app . width = 400 app . height = 450 data = [ { \"month\" : \"Jan\" , \"sales\" : 120 , \"target\" : 100 }, { \"month\" : \"Feb\" , \"sales\" : 150 , \"target\" : 130 }, { \"month\" : \"Mar\" , \"sales\" : 180 , \"target\" : 160 }, { \"month\" : \"Apr\" , \"sales\" : 160 , \"target\" : 170 }, { \"month\" : \"May\" , \"sales\" : 210 , \"target\" : 190 }, { \"month\" : \"Jun\" , \"sales\" : 240 , \"target\" : 220 }, ] chart = nib . Chart ( data = data , marks = [ nib . BarMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" , corner_radius = 4 , ), nib . LineMark ( x = \"month\" , y = \"target\" , foreground_style = \"#EF4444\" , line_width = 2 , symbol = nib . SymbolShape . CIRCLE , interpolation = nib . InterpolationMethod . MONOTONE , ), ], x_axis = nib . ChartAxis ( label = \"Month\" ), y_axis = nib . ChartAxis ( label = \"Units Sold\" , grid_lines = True , grid_color = \"#e5e7eb\" , ), chart_background = \"#ffffff\" , width = 370 , height = 250 , padding = 8 , corner_radius = 12 , ) total_label = nib . Text ( f \"Total: { sum ( d [ 'sales' ] for d in data ) } units\" , font = nib . Font . HEADLINE , ) # Donut chart for breakdown pie_data = [ { \"category\" : \"Online\" , \"value\" : 450 }, { \"category\" : \"Retail\" , \"value\" : 320 }, { \"category\" : \"Wholesale\" , \"value\" : 290 }, ] donut = nib . Chart ( data = pie_data , marks = [ nib . SectorMark ( angle = \"value\" , foreground_style = nib . PlottableField ( \"category\" ), inner_radius = 40 , outer_radius = 70 , corner_radius = 3 , ), ], legend = nib . ChartLegend ( position = \"bottom\" ), width = 370 , height = 160 , ) app . build ( nib . VStack ( controls = [ total_label , chart , nib . Text ( \"Sales by Channel\" , font = nib . Font . SUBHEADLINE ), donut , ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Charts"},{"location":"guides/charts/#creating-a-chart","text":"import nib chart = nib . Chart ( data = [ { \"month\" : \"Jan\" , \"sales\" : 100 }, { \"month\" : \"Feb\" , \"sales\" : 150 }, { \"month\" : \"Mar\" , \"sales\" : 200 }, { \"month\" : \"Apr\" , \"sales\" : 175 }, { \"month\" : \"May\" , \"sales\" : 250 }, ], marks = [ nib . LineMark ( x = \"month\" , y = \"sales\" )], width = 350 , height = 220 , ) The Chart constructor takes: Parameter Type Description data list[dict] List of data rows as dictionaries marks list[BaseMark] List of mark objects defining the visualization x_axis ChartAxis X-axis configuration (optional) y_axis ChartAxis Y-axis configuration (optional) legend ChartLegend or bool Legend configuration, or False to hide chart_background str Background color for the entire chart plot_background str Background color for the plot area only Standard view modifiers ( width , height , padding , corner_radius , etc.) are also supported.","title":"Creating a chart"},{"location":"guides/charts/#data-format","text":"Data is a list of dictionaries where each dictionary represents a row. The keys correspond to the field names used in your marks: data = [ { \"month\" : \"Jan\" , \"revenue\" : 4200 , \"expenses\" : 3100 }, { \"month\" : \"Feb\" , \"revenue\" : 5100 , \"expenses\" : 3400 }, { \"month\" : \"Mar\" , \"revenue\" : 4800 , \"expenses\" : 3200 }, ] Note Nib converts row-based data to a columnar format internally for efficient serialization. You always work with the row-based format in your Python code.","title":"Data format"},{"location":"guides/charts/#mark-types","text":"","title":"Mark types"},{"location":"guides/charts/#linemark","text":"Connects data points with a continuous line. Best for trends over time: nib . LineMark ( x = \"month\" , y = \"sales\" ) Parameter Type Description x str or PlottableField Data field for x-axis y str or PlottableField Data field for y-axis foreground_style str or PlottableField Line color or field for multi-series symbol SymbolShape or PlottableField Marker shape at each point interpolation InterpolationMethod Curve type between points line_width float Line width in points opacity float Opacity from 0.0 to 1.0","title":"LineMark"},{"location":"guides/charts/#barmark","text":"Displays data as rectangular bars. Best for comparing categories: nib . BarMark ( x = \"category\" , y = \"value\" ) Parameter Type Description x str or PlottableField Data field for x-axis y str or PlottableField Data field for y-axis width float Fixed bar width in points height float Fixed bar height in points foreground_style str or PlottableField Bar color or field for grouping stacking StackingMethod Stacking mode for multi-series corner_radius float Rounded corner radius opacity float Opacity from 0.0 to 1.0","title":"BarMark"},{"location":"guides/charts/#areamark","text":"Fills the region between a line and a baseline: nib . AreaMark ( x = \"date\" , y = \"revenue\" , foreground_style = \"#3B82F6\" , opacity = 0.3 ) Parameter Type Description x str or PlottableField Data field for x-axis y str or PlottableField Data field for upper boundary y_start str or PlottableField Data field for lower boundary (optional) foreground_style str or PlottableField Fill color or field for multi-series interpolation InterpolationMethod Curve type stacking StackingMethod Stacking mode opacity float Opacity from 0.0 to 1.0","title":"AreaMark"},{"location":"guides/charts/#pointmark","text":"Displays individual data points as symbols. Best for scatter plots: nib . PointMark ( x = \"height\" , y = \"weight\" , foreground_style = \"#EF4444\" ) Parameter Type Description x str or PlottableField Data field for x-axis y str or PlottableField Data field for y-axis foreground_style str or PlottableField Point color or field for coloring symbol SymbolShape or PlottableField Marker shape symbol_size float Marker size in square points opacity float Opacity from 0.0 to 1.0","title":"PointMark"},{"location":"guides/charts/#sectormark","text":"Creates pie and donut charts: nib . SectorMark ( angle = \"value\" , foreground_style = nib . PlottableField ( \"category\" ), ) Parameter Type Description angle str or PlottableField Data field for sector sizes foreground_style str or PlottableField Color or field for per-segment colors inner_radius float Inner radius (0 = pie, >0 = donut) outer_radius float Outer radius corner_radius float Rounded segment corners opacity float Opacity from 0.0 to 1.0","title":"SectorMark"},{"location":"guides/charts/#rulemark","text":"Draws a reference line (horizontal or vertical): # Horizontal line at y=100 nib . RuleMark ( y = 100 , foreground_style = \"#EF4444\" , line_width = 2 ) # Vertical line at x position nib . RuleMark ( x = \"2024-06-15\" , foreground_style = \"#6366F1\" ) Parameter Type Description x value or field X position for vertical rule y value or field Y position for horizontal rule x_start / x_end value or field Horizontal bounds for segments y_start / y_end value or field Vertical bounds for segments foreground_style str or PlottableField Line color line_width float Line width","title":"RuleMark"},{"location":"guides/charts/#rectmark","text":"Draws filled rectangles for heatmaps and range charts: nib . RectMark ( x = \"weekday\" , y = \"hour\" , foreground_style = nib . PlottableField ( \"intensity\" ), corner_radius = 2 , )","title":"RectMark"},{"location":"guides/charts/#plottablefield","text":"Use PlottableField to reference data columns with optional type hints: from nib import PlottableField # Simple field reference (equivalent to just passing \"month\") nib . LineMark ( x = PlottableField ( \"month\" ), y = PlottableField ( \"sales\" )) # With type hint for proper scale selection nib . LineMark ( x = PlottableField ( \"date\" , type = \"temporal\" ), y = PlottableField ( \"temperature\" , type = \"quantitative\" ), ) Available types: \"quantitative\" (numeric), \"nominal\" (categorical), \"temporal\" (dates/times).","title":"PlottableField"},{"location":"guides/charts/#multiple-series","text":"To display multiple data series with automatic color assignment, pass a PlottableField as foreground_style : data = [ { \"month\" : \"Jan\" , \"value\" : 100 , \"series\" : \"Revenue\" }, { \"month\" : \"Jan\" , \"value\" : 80 , \"series\" : \"Expenses\" }, { \"month\" : \"Feb\" , \"value\" : 150 , \"series\" : \"Revenue\" }, { \"month\" : \"Feb\" , \"value\" : 90 , \"series\" : \"Expenses\" }, { \"month\" : \"Mar\" , \"value\" : 200 , \"series\" : \"Revenue\" }, { \"month\" : \"Mar\" , \"value\" : 110 , \"series\" : \"Expenses\" }, ] chart = nib . Chart ( data = data , marks = [ nib . LineMark ( x = \"month\" , y = \"value\" , foreground_style = nib . PlottableField ( \"series\" ), ), ], width = 350 , height = 220 , ) Swift Charts automatically assigns distinct colors to each unique value in the series field.","title":"Multiple series"},{"location":"guides/charts/#combining-marks","text":"Combine multiple mark types in a single chart for layered visualizations: chart = nib . Chart ( data = data , marks = [ nib . AreaMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" , opacity = 0.2 ), nib . LineMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" ), nib . PointMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" ), nib . RuleMark ( y = 150 , foreground_style = \"#EF4444\" , line_width = 1 ), ], width = 350 , height = 220 , ) This creates an area chart with a line overlay, point markers at each data point, and a horizontal reference line at y=150.","title":"Combining marks"},{"location":"guides/charts/#axis-configuration","text":"Use ChartAxis to customize axis appearance: chart = nib . Chart ( data = data , marks = [ nib . BarMark ( x = \"month\" , y = \"revenue\" )], x_axis = nib . ChartAxis ( label = \"Month\" , position = \"bottom\" , ), y_axis = nib . ChartAxis ( label = \"Revenue ($)\" , grid_lines = True , format = \"currency\" , grid_color = \"#333333\" , label_color = \"#666666\" , ), ) Parameter Type Default Description label str None Axis label text position str auto \"bottom\" , \"top\" , \"leading\" , or \"trailing\" grid_lines bool False Show grid lines hidden bool False Hide the axis entirely format str auto \"number\" , \"currency\" , or \"percent\" values list None Explicit tick mark values label_color str None Color for axis labels grid_color str None Color for grid lines","title":"Axis configuration"},{"location":"guides/charts/#legend-configuration","text":"Control the chart legend with ChartLegend : chart = nib . Chart ( data = data , marks = [ nib . LineMark ( x = \"month\" , y = \"value\" , foreground_style = nib . PlottableField ( \"series\" ))], legend = nib . ChartLegend ( position = \"bottom\" , title = \"Category\" , ), ) # Or hide the legend entirely chart = nib . Chart ( data = data , marks = [ ... ], legend = False , ) Parameter Type Description position str \"top\" , \"bottom\" , \"leading\" , \"trailing\" , or \"automatic\" hidden bool Hide the legend title str Title text displayed above legend items","title":"Legend configuration"},{"location":"guides/charts/#interpolationmethod","text":"Control how lines and areas are drawn between data points: nib . LineMark ( x = \"month\" , y = \"sales\" , interpolation = nib . InterpolationMethod . MONOTONE , ) Value Description LINEAR Straight lines between points (default) MONOTONE Smooth curve that preserves monotonicity CATMULL_ROM Smooth cubic spline through all points CARDINAL Smooth curve with adjustable tension STEP_START Step at the start of each interval STEP_CENTER Step at the midpoint between points STEP_END Step at the end of each interval","title":"InterpolationMethod"},{"location":"guides/charts/#stackingmethod","text":"Control how overlapping bars or areas are stacked: nib . BarMark ( x = \"month\" , y = \"sales\" , foreground_style = nib . PlottableField ( \"region\" ), stacking = nib . StackingMethod . STANDARD , ) Value Description STANDARD Stack values on top of each other NORMALIZED Scale stacks to 100% CENTER Center stacks (stream graph effect)","title":"StackingMethod"},{"location":"guides/charts/#symbolshape","text":"Marker shapes for PointMark and LineMark : nib . PointMark ( x = \"x\" , y = \"y\" , symbol = nib . SymbolShape . DIAMOND ) Available shapes: CIRCLE , SQUARE , TRIANGLE , DIAMOND , CROSS , PLUS , PENTAGON , HEXAGON .","title":"SymbolShape"},{"location":"guides/charts/#reactive-data-updates","text":"Chart data is reactive. Updating it triggers an automatic re-render: # Replace all data chart . data = new_data # Append a single row chart . append_data ({ \"month\" : \"Jun\" , \"sales\" : 300 }) # Update a specific row chart . update_data ( 0 , { \"month\" : \"Jan\" , \"sales\" : 120 }) # Clear all data chart . clear_data ()","title":"Reactive data updates"},{"location":"guides/charts/#complete-example","text":"A sales dashboard with a bar chart, trend line, and live data updates: import nib import random def main ( app : nib . App ): app . title = \"Sales\" app . icon = nib . SFSymbol ( \"chart.bar.fill\" ) app . width = 400 app . height = 450 data = [ { \"month\" : \"Jan\" , \"sales\" : 120 , \"target\" : 100 }, { \"month\" : \"Feb\" , \"sales\" : 150 , \"target\" : 130 }, { \"month\" : \"Mar\" , \"sales\" : 180 , \"target\" : 160 }, { \"month\" : \"Apr\" , \"sales\" : 160 , \"target\" : 170 }, { \"month\" : \"May\" , \"sales\" : 210 , \"target\" : 190 }, { \"month\" : \"Jun\" , \"sales\" : 240 , \"target\" : 220 }, ] chart = nib . Chart ( data = data , marks = [ nib . BarMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" , corner_radius = 4 , ), nib . LineMark ( x = \"month\" , y = \"target\" , foreground_style = \"#EF4444\" , line_width = 2 , symbol = nib . SymbolShape . CIRCLE , interpolation = nib . InterpolationMethod . MONOTONE , ), ], x_axis = nib . ChartAxis ( label = \"Month\" ), y_axis = nib . ChartAxis ( label = \"Units Sold\" , grid_lines = True , grid_color = \"#e5e7eb\" , ), chart_background = \"#ffffff\" , width = 370 , height = 250 , padding = 8 , corner_radius = 12 , ) total_label = nib . Text ( f \"Total: { sum ( d [ 'sales' ] for d in data ) } units\" , font = nib . Font . HEADLINE , ) # Donut chart for breakdown pie_data = [ { \"category\" : \"Online\" , \"value\" : 450 }, { \"category\" : \"Retail\" , \"value\" : 320 }, { \"category\" : \"Wholesale\" , \"value\" : 290 }, ] donut = nib . Chart ( data = pie_data , marks = [ nib . SectorMark ( angle = \"value\" , foreground_style = nib . PlottableField ( \"category\" ), inner_radius = 40 , outer_radius = 70 , corner_radius = 3 , ), ], legend = nib . ChartLegend ( position = \"bottom\" ), width = 370 , height = 160 , ) app . build ( nib . VStack ( controls = [ total_label , chart , nib . Text ( \"Sales by Channel\" , font = nib . Font . SUBHEADLINE ), donut , ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Complete example"},{"location":"guides/colors-gradients/","text":"Nib supports named colors, hex strings, RGB/RGBA constructors, semantic system colors, and three gradient types. Colors can be used anywhere a color parameter is accepted: foreground_color , background , fill , stroke , border_color , shadow_color , and more. Named Colors \u00b6 Use constants on the Color class for standard SwiftUI colors: import nib nib . Text ( \"Red\" , foreground_color = nib . Color . RED ) nib . Text ( \"Blue\" , foreground_color = nib . Color . BLUE ) nib . Rectangle ( fill = nib . Color . GREEN , width = 50 , height = 50 ) Full list of named colors: Color Constant Red nib.Color.RED Blue nib.Color.BLUE Green nib.Color.GREEN Yellow nib.Color.YELLOW Orange nib.Color.ORANGE Purple nib.Color.PURPLE Pink nib.Color.PINK White nib.Color.WHITE Black nib.Color.BLACK Gray nib.Color.GRAY Clear (transparent) nib.Color.CLEAR Indigo nib.Color.INDIGO Cyan nib.Color.CYAN Mint nib.Color.MINT Teal nib.Color.TEAL Brown nib.Color.BROWN Semantic Colors \u00b6 Semantic colors adapt automatically to light and dark mode: nib . Text ( \"Primary text\" , foreground_color = nib . Color . PRIMARY ) nib . Text ( \"Secondary text\" , foreground_color = nib . Color . SECONDARY ) nib . Button ( \"Action\" , foreground_color = nib . Color . ACCENT ) Semantic Constant Adapts to Primary nib.Color.PRIMARY Main text color Secondary nib.Color.SECONDARY Dimmed/muted text Accent nib.Color.ACCENT System accent color Hex Colors \u00b6 Create colors from hex strings with or without the # prefix: # Using the constructor nib . Text ( \"Custom Blue\" , foreground_color = nib . Color ( hex = \"#4287f5\" )) nib . Text ( \"No hash\" , foreground_color = nib . Color ( hex = \"4287f5\" )) # With alpha channel (ARGB format) nib . Rectangle ( fill = nib . Color ( hex = \"#7fff6666\" ), width = 100 , height = 50 ) RGB and RGBA \u00b6 Create colors from integer RGB values (0--255) or with a float alpha (0.0--1.0): # RGB (opaque) custom_blue = nib . Color . rgb ( 66 , 135 , 245 ) nib . Text ( \"RGB Blue\" , foreground_color = custom_blue ) # RGBA (with transparency) semi_red = nib . Color . rgba ( 255 , 0 , 0 , 0.5 ) nib . Rectangle ( fill = semi_red , width = 100 , height = 50 ) String Shortcuts \u00b6 Many color parameters also accept plain strings for convenience. Named color strings and hex strings both work: # Named color string nib . Text ( \"Red text\" , foreground_color = \"red\" ) # Hex string nib . VStack ( controls = [ nib . Text ( \"Custom\" )], background = \"#FF5733\" , ) Info String shortcuts are resolved by the Swift runtime. They support all SwiftUI color names and hex values. Color with Opacity \u00b6 Use with_opacity() to create a translucent variant of any color: # 50% transparent indigo nib . Rectangle ( fill = nib . Color . INDIGO . with_opacity ( 0.5 ), width = 100 , height = 50 ) # Works with hex colors too nib . Rectangle ( fill = nib . Color ( hex = \"#4287f5\" ) . with_opacity ( 0.8 ), width = 100 , height = 50 ) LinearGradient \u00b6 LinearGradient transitions colors along a straight line. The start and end points use unit coordinates where (0, 0) is top-left and (1, 1) is bottom-right. # Top-to-bottom gradient (default direction) nib . LinearGradient ( colors = [ nib . Color . RED , nib . Color . BLUE ], width = 200 , height = 100 , ) # Left-to-right gradient nib . LinearGradient ( colors = [ \"#FF0000\" , \"#0000FF\" ], start = ( 0 , 0.5 ), end = ( 1 , 0.5 ), width = 200 , height = 100 , ) # Diagonal gradient nib . LinearGradient ( colors = [ nib . Color . ORANGE , nib . Color . PURPLE ], start = ( 0 , 0 ), end = ( 1 , 1 ), width = 200 , height = 100 , ) Gradient Stops \u00b6 For precise control over color positions, use stops instead of colors . Each stop is a tuple of (position, color) where position ranges from 0.0 to 1.0: nib . LinearGradient ( stops = [ ( 0.0 , \"#FF0000\" ), ( 0.3 , \"#FFFF00\" ), ( 0.7 , \"#00FF00\" ), ( 1.0 , \"#0000FF\" ), ], width = 200 , height = 100 , ) RadialGradient \u00b6 RadialGradient radiates colors outward from a center point: nib . RadialGradient ( colors = [ nib . Color . WHITE , nib . Color . BLACK ], center = ( 0.5 , 0.5 ), start_radius = 0 , end_radius = 100 , width = 200 , height = 200 , ) Off-center spotlight effect: nib . RadialGradient ( colors = [ \"#FFD700\" , \"#000000\" ], center = ( 0.3 , 0.3 ), start_radius = 0 , end_radius = 150 , width = 200 , height = 200 , ) AngularGradient \u00b6 AngularGradient (conic gradient) rotates colors around a center point: # Full color wheel nib . AngularGradient ( colors = [ \"red\" , \"yellow\" , \"green\" , \"cyan\" , \"blue\" , \"magenta\" , \"red\" ], center = ( 0.5 , 0.5 ), width = 200 , height = 200 , ) # Partial arc nib . AngularGradient ( colors = [ nib . Color . BLUE , nib . Color . PURPLE ], center = ( 0.5 , 0.5 ), start_angle = 0 , end_angle = 180 , width = 200 , height = 200 , ) Gradients as Backgrounds \u00b6 Gradient views can be used as background on any container: nib . VStack ( controls = [ nib . Text ( \"Gradient Card\" , font = nib . Font . TITLE , foreground_color = nib . Color . WHITE ), nib . Text ( \"With smooth colors\" , foreground_color = nib . Color . WHITE . with_opacity ( 0.8 )), ], spacing = 8 , padding = 24 , background = nib . LinearGradient ( colors = [ \"#667eea\" , \"#764ba2\" ], start = ( 0 , 0 ), end = ( 1 , 1 ), ), corner_radius = 16 , ) Gradients as Shape Fills \u00b6 Use gradients inside shapes for filled gradient shapes: nib . Rectangle ( corner_radius = 12 , width = 200 , height = 100 , background = nib . LinearGradient ( colors = [ nib . Color . CYAN , nib . Color . BLUE ], ), ) Full Example \u00b6 A complete app showing various color and gradient techniques: import nib def main ( app : nib . App ): app . title = \"Colors\" app . icon = nib . SFSymbol ( \"paintpalette\" ) app . width = 300 app . height = 400 app . build ( nib . ScrollView ( controls = [ nib . VStack ( controls = [ # Named colors row nib . HStack ( controls = [ _swatch ( nib . Color . RED ), _swatch ( nib . Color . ORANGE ), _swatch ( nib . Color . YELLOW ), _swatch ( nib . Color . GREEN ), _swatch ( nib . Color . BLUE ), _swatch ( nib . Color . PURPLE ), ], spacing = 4 , ), # Linear gradient nib . LinearGradient ( colors = [ \"#FF6B6B\" , \"#4ECDC4\" ], start = ( 0 , 0.5 ), end = ( 1 , 0.5 ), height = 60 , corner_radius = 8 , ), # Radial gradient nib . RadialGradient ( colors = [ nib . Color . WHITE , nib . Color . INDIGO ], center = ( 0.5 , 0.5 ), start_radius = 0 , end_radius = 120 , height = 120 , corner_radius = 8 , ), # Angular gradient nib . AngularGradient ( colors = [ \"red\" , \"yellow\" , \"green\" , \"cyan\" , \"blue\" , \"magenta\" , \"red\" ], center = ( 0.5 , 0.5 ), height = 120 , corner_radius = 8 , ), # Gradient card nib . VStack ( controls = [ nib . Text ( \"Gradient Card\" , font = nib . Font . HEADLINE , foreground_color = nib . Color . WHITE ), nib . Text ( \"Beautiful colors\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE . with_opacity ( 0.7 )), ], spacing = 4 , padding = 20 , background = nib . LinearGradient ( colors = [ \"#6366f1\" , \"#a855f7\" , \"#ec4899\" ], start = ( 0 , 0 ), end = ( 1 , 1 ), ), corner_radius = 12 , ), ], spacing = 12 , padding = 16 , ), ], ) ) def _swatch ( color ): return nib . Circle ( fill = color , width = 36 , height = 36 ) nib . run ( main )","title":"Colors & Gradients"},{"location":"guides/colors-gradients/#named-colors","text":"Use constants on the Color class for standard SwiftUI colors: import nib nib . Text ( \"Red\" , foreground_color = nib . Color . RED ) nib . Text ( \"Blue\" , foreground_color = nib . Color . BLUE ) nib . Rectangle ( fill = nib . Color . GREEN , width = 50 , height = 50 ) Full list of named colors: Color Constant Red nib.Color.RED Blue nib.Color.BLUE Green nib.Color.GREEN Yellow nib.Color.YELLOW Orange nib.Color.ORANGE Purple nib.Color.PURPLE Pink nib.Color.PINK White nib.Color.WHITE Black nib.Color.BLACK Gray nib.Color.GRAY Clear (transparent) nib.Color.CLEAR Indigo nib.Color.INDIGO Cyan nib.Color.CYAN Mint nib.Color.MINT Teal nib.Color.TEAL Brown nib.Color.BROWN","title":"Named Colors"},{"location":"guides/colors-gradients/#semantic-colors","text":"Semantic colors adapt automatically to light and dark mode: nib . Text ( \"Primary text\" , foreground_color = nib . Color . PRIMARY ) nib . Text ( \"Secondary text\" , foreground_color = nib . Color . SECONDARY ) nib . Button ( \"Action\" , foreground_color = nib . Color . ACCENT ) Semantic Constant Adapts to Primary nib.Color.PRIMARY Main text color Secondary nib.Color.SECONDARY Dimmed/muted text Accent nib.Color.ACCENT System accent color","title":"Semantic Colors"},{"location":"guides/colors-gradients/#hex-colors","text":"Create colors from hex strings with or without the # prefix: # Using the constructor nib . Text ( \"Custom Blue\" , foreground_color = nib . Color ( hex = \"#4287f5\" )) nib . Text ( \"No hash\" , foreground_color = nib . Color ( hex = \"4287f5\" )) # With alpha channel (ARGB format) nib . Rectangle ( fill = nib . Color ( hex = \"#7fff6666\" ), width = 100 , height = 50 )","title":"Hex Colors"},{"location":"guides/colors-gradients/#rgb-and-rgba","text":"Create colors from integer RGB values (0--255) or with a float alpha (0.0--1.0): # RGB (opaque) custom_blue = nib . Color . rgb ( 66 , 135 , 245 ) nib . Text ( \"RGB Blue\" , foreground_color = custom_blue ) # RGBA (with transparency) semi_red = nib . Color . rgba ( 255 , 0 , 0 , 0.5 ) nib . Rectangle ( fill = semi_red , width = 100 , height = 50 )","title":"RGB and RGBA"},{"location":"guides/colors-gradients/#string-shortcuts","text":"Many color parameters also accept plain strings for convenience. Named color strings and hex strings both work: # Named color string nib . Text ( \"Red text\" , foreground_color = \"red\" ) # Hex string nib . VStack ( controls = [ nib . Text ( \"Custom\" )], background = \"#FF5733\" , ) Info String shortcuts are resolved by the Swift runtime. They support all SwiftUI color names and hex values.","title":"String Shortcuts"},{"location":"guides/colors-gradients/#color-with-opacity","text":"Use with_opacity() to create a translucent variant of any color: # 50% transparent indigo nib . Rectangle ( fill = nib . Color . INDIGO . with_opacity ( 0.5 ), width = 100 , height = 50 ) # Works with hex colors too nib . Rectangle ( fill = nib . Color ( hex = \"#4287f5\" ) . with_opacity ( 0.8 ), width = 100 , height = 50 )","title":"Color with Opacity"},{"location":"guides/colors-gradients/#lineargradient","text":"LinearGradient transitions colors along a straight line. The start and end points use unit coordinates where (0, 0) is top-left and (1, 1) is bottom-right. # Top-to-bottom gradient (default direction) nib . LinearGradient ( colors = [ nib . Color . RED , nib . Color . BLUE ], width = 200 , height = 100 , ) # Left-to-right gradient nib . LinearGradient ( colors = [ \"#FF0000\" , \"#0000FF\" ], start = ( 0 , 0.5 ), end = ( 1 , 0.5 ), width = 200 , height = 100 , ) # Diagonal gradient nib . LinearGradient ( colors = [ nib . Color . ORANGE , nib . Color . PURPLE ], start = ( 0 , 0 ), end = ( 1 , 1 ), width = 200 , height = 100 , )","title":"LinearGradient"},{"location":"guides/colors-gradients/#gradient-stops","text":"For precise control over color positions, use stops instead of colors . Each stop is a tuple of (position, color) where position ranges from 0.0 to 1.0: nib . LinearGradient ( stops = [ ( 0.0 , \"#FF0000\" ), ( 0.3 , \"#FFFF00\" ), ( 0.7 , \"#00FF00\" ), ( 1.0 , \"#0000FF\" ), ], width = 200 , height = 100 , )","title":"Gradient Stops"},{"location":"guides/colors-gradients/#radialgradient","text":"RadialGradient radiates colors outward from a center point: nib . RadialGradient ( colors = [ nib . Color . WHITE , nib . Color . BLACK ], center = ( 0.5 , 0.5 ), start_radius = 0 , end_radius = 100 , width = 200 , height = 200 , ) Off-center spotlight effect: nib . RadialGradient ( colors = [ \"#FFD700\" , \"#000000\" ], center = ( 0.3 , 0.3 ), start_radius = 0 , end_radius = 150 , width = 200 , height = 200 , )","title":"RadialGradient"},{"location":"guides/colors-gradients/#angulargradient","text":"AngularGradient (conic gradient) rotates colors around a center point: # Full color wheel nib . AngularGradient ( colors = [ \"red\" , \"yellow\" , \"green\" , \"cyan\" , \"blue\" , \"magenta\" , \"red\" ], center = ( 0.5 , 0.5 ), width = 200 , height = 200 , ) # Partial arc nib . AngularGradient ( colors = [ nib . Color . BLUE , nib . Color . PURPLE ], center = ( 0.5 , 0.5 ), start_angle = 0 , end_angle = 180 , width = 200 , height = 200 , )","title":"AngularGradient"},{"location":"guides/colors-gradients/#gradients-as-backgrounds","text":"Gradient views can be used as background on any container: nib . VStack ( controls = [ nib . Text ( \"Gradient Card\" , font = nib . Font . TITLE , foreground_color = nib . Color . WHITE ), nib . Text ( \"With smooth colors\" , foreground_color = nib . Color . WHITE . with_opacity ( 0.8 )), ], spacing = 8 , padding = 24 , background = nib . LinearGradient ( colors = [ \"#667eea\" , \"#764ba2\" ], start = ( 0 , 0 ), end = ( 1 , 1 ), ), corner_radius = 16 , )","title":"Gradients as Backgrounds"},{"location":"guides/colors-gradients/#gradients-as-shape-fills","text":"Use gradients inside shapes for filled gradient shapes: nib . Rectangle ( corner_radius = 12 , width = 200 , height = 100 , background = nib . LinearGradient ( colors = [ nib . Color . CYAN , nib . Color . BLUE ], ), )","title":"Gradients as Shape Fills"},{"location":"guides/colors-gradients/#full-example","text":"A complete app showing various color and gradient techniques: import nib def main ( app : nib . App ): app . title = \"Colors\" app . icon = nib . SFSymbol ( \"paintpalette\" ) app . width = 300 app . height = 400 app . build ( nib . ScrollView ( controls = [ nib . VStack ( controls = [ # Named colors row nib . HStack ( controls = [ _swatch ( nib . Color . RED ), _swatch ( nib . Color . ORANGE ), _swatch ( nib . Color . YELLOW ), _swatch ( nib . Color . GREEN ), _swatch ( nib . Color . BLUE ), _swatch ( nib . Color . PURPLE ), ], spacing = 4 , ), # Linear gradient nib . LinearGradient ( colors = [ \"#FF6B6B\" , \"#4ECDC4\" ], start = ( 0 , 0.5 ), end = ( 1 , 0.5 ), height = 60 , corner_radius = 8 , ), # Radial gradient nib . RadialGradient ( colors = [ nib . Color . WHITE , nib . Color . INDIGO ], center = ( 0.5 , 0.5 ), start_radius = 0 , end_radius = 120 , height = 120 , corner_radius = 8 , ), # Angular gradient nib . AngularGradient ( colors = [ \"red\" , \"yellow\" , \"green\" , \"cyan\" , \"blue\" , \"magenta\" , \"red\" ], center = ( 0.5 , 0.5 ), height = 120 , corner_radius = 8 , ), # Gradient card nib . VStack ( controls = [ nib . Text ( \"Gradient Card\" , font = nib . Font . HEADLINE , foreground_color = nib . Color . WHITE ), nib . Text ( \"Beautiful colors\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE . with_opacity ( 0.7 )), ], spacing = 4 , padding = 20 , background = nib . LinearGradient ( colors = [ \"#6366f1\" , \"#a855f7\" , \"#ec4899\" ], start = ( 0 , 0 ), end = ( 1 , 1 ), ), corner_radius = 12 , ), ], spacing = 12 , padding = 16 , ), ], ) ) def _swatch ( color ): return nib . Circle ( fill = color , width = 36 , height = 36 ) nib . run ( main )","title":"Full Example"},{"location":"guides/context-menu/","text":"The context menu appears when a user right-clicks (or Control-clicks) the status bar icon. Set it with app.menu , passing a list of MenuItem and MenuDivider objects. Basic Menu \u00b6 import nib def main ( app : nib . App ): app . title = \"My App\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . width = 300 app . height = 200 def open_settings (): print ( \"Settings opened\" ) app . menu = [ nib . MenuItem ( \"Settings\" , action = open_settings , icon = \"gear\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit ), ] app . build ( nib . Text ( \"Right-click the menu bar icon\" , padding = 24 )) nib . run ( main ) MenuItem Parameters \u00b6 Parameter Type Description title str Menu item text (optional if content is provided) action callable Function called when the item is clicked icon str or SFSymbol SF Symbol name or SFSymbol instance with styling shortcut str Keyboard shortcut (e.g., \"cmd+q\" , \"cmd+shift+n\" ) badge str Badge text on the right side (macOS 14+) state str Checkmark state: \"on\" , \"off\" , or \"mixed\" enabled bool Whether the item is clickable (default True ) content View Custom view content (replaces title/icon) menu list Child items for a submenu height float Custom height for content-based items Icons \u00b6 Pass a string for a simple SF Symbol icon, or an SFSymbol instance for styled icons: # Simple string icon nib . MenuItem ( \"Settings\" , action = handler , icon = \"gear\" ) # Styled icon with color nib . MenuItem ( \"Favorites\" , action = handler , icon = nib . SFSymbol ( \"star.fill\" , foreground_color = nib . Color . YELLOW ), ) Keyboard Shortcuts \u00b6 Use the shortcut parameter with modifier keys joined by + : nib . MenuItem ( \"Settings\" , action = open_settings , shortcut = \"cmd+,\" ) nib . MenuItem ( \"New Window\" , action = new_window , shortcut = \"cmd+n\" ) nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ) nib . MenuItem ( \"Refresh\" , action = refresh , shortcut = \"cmd+shift+r\" ) nib . MenuItem ( \"Toggle\" , action = toggle , shortcut = \"opt+t\" ) Supported modifiers: cmd , shift , opt (or alt ), ctrl . Badges \u00b6 Badges display a small label on the right side of the menu item. They are useful for showing counts or status. nib . MenuItem ( \"Updates\" , action = check_updates , badge = \"3\" ) nib . MenuItem ( \"Messages\" , action = open_messages , badge = \"New\" ) Note Badges require macOS 14 (Sonoma) or later. State Indicators \u00b6 The state parameter shows a checkmark, no mark, or a mixed indicator: nib . MenuItem ( \"Enabled\" , action = toggle_feature , state = \"on\" ) # Checkmark nib . MenuItem ( \"Disabled\" , action = toggle_feature , state = \"off\" ) # No mark nib . MenuItem ( \"Partial\" , action = toggle_feature , state = \"mixed\" ) # Dash mark A common pattern is to toggle the state dynamically: feature_on = False def toggle_feature (): global feature_on feature_on = not feature_on rebuild_menu () def rebuild_menu (): app . menu = [ nib . MenuItem ( \"Feature\" , action = toggle_feature , state = \"on\" if feature_on else \"off\" , icon = \"checkmark.circle\" , ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit ), ] Disabled Items \u00b6 Set enabled=False to gray out an item and prevent clicks: nib . MenuItem ( \"Unavailable\" , enabled = False ) nib . MenuItem ( \"Premium Only\" , action = upgrade , enabled = is_premium ) Menu Dividers \u00b6 MenuDivider draws a horizontal separator line between items: app . menu = [ nib . MenuItem ( \"Action 1\" , action = handler1 ), nib . MenuItem ( \"Action 2\" , action = handler2 ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit ), ] Submenus \u00b6 Nest menus by passing a menu list to a MenuItem : nib . MenuItem ( \"Export\" , icon = \"square.and.arrow.up\" , menu = [ nib . MenuItem ( \"Export as PDF\" , action = export_pdf , icon = \"doc\" ), nib . MenuItem ( \"Export as PNG\" , action = export_png , icon = \"photo\" ), nib . MenuItem ( \"Export as CSV\" , action = export_csv , icon = \"tablecells\" ), ], ) Submenus can be nested to any depth: nib . MenuItem ( \"More\" , icon = \"ellipsis.circle\" , menu = [ nib . MenuItem ( \"Level 1\" , menu = [ nib . MenuItem ( \"Level 2 - A\" , action = handler_a ), nib . MenuItem ( \"Level 2 - B\" , action = handler_b ), ]), ], ) Custom View Content \u00b6 For rich menu items, use the content parameter with any Nib view. When using content , the title and icon parameters are ignored. nib . MenuItem ( content = nib . HStack ( controls = [ nib . SFSymbol ( \"star.fill\" , foreground_color = nib . Color . YELLOW ), nib . VStack ( controls = [ nib . Text ( \"Premium\" , font = nib . Font . HEADLINE ), nib . Text ( \"Upgrade now\" , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), ], spacing = 8 , ), action = upgrade , height = 50 , ) Tip Set the height parameter when using content to ensure the menu item has enough vertical space for your custom view. Full Example \u00b6 A complete menu demonstrating all features: import nib def main ( app : nib . App ): app . title = \"Menu Demo\" app . icon = nib . SFSymbol ( \"menucard\" ) app . width = 300 app . height = 200 notifications_on = True dark_mode = False def toggle_notifications (): nonlocal notifications_on notifications_on = not notifications_on update_menu () def toggle_dark_mode (): nonlocal dark_mode dark_mode = not dark_mode update_menu () def update_menu (): app . menu = [ # Custom view item nib . MenuItem ( content = nib . HStack ( controls = [ nib . SFSymbol ( \"person.circle.fill\" , foreground_color = nib . Color . BLUE , font = nib . Font . TITLE ), nib . VStack ( controls = [ nib . Text ( \"John Doe\" , font = nib . Font . HEADLINE ), nib . Text ( \"john@example.com\" , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), ], spacing = 10 , ), height = 50 , ), nib . MenuDivider (), # State toggle items nib . MenuItem ( \"Notifications\" , action = toggle_notifications , icon = \"bell.fill\" , state = \"on\" if notifications_on else \"off\" , ), nib . MenuItem ( \"Dark Mode\" , action = toggle_dark_mode , icon = \"moon.fill\" , state = \"on\" if dark_mode else \"off\" , ), nib . MenuDivider (), # Badge item nib . MenuItem ( \"Updates Available\" , icon = \"arrow.down.circle\" , badge = \"2\" ), # Disabled item nib . MenuItem ( \"Premium Feature\" , icon = \"lock.fill\" , enabled = False ), # Submenu nib . MenuItem ( \"Export\" , icon = \"square.and.arrow.up\" , menu = [ nib . MenuItem ( \"PDF\" , action = lambda : print ( \"PDF\" ), shortcut = \"cmd+p\" ), nib . MenuItem ( \"PNG\" , action = lambda : print ( \"PNG\" )), nib . MenuItem ( \"CSV\" , action = lambda : print ( \"CSV\" )), ], ), nib . MenuDivider (), # Quit with shortcut nib . MenuItem ( \"Quit\" , action = app . quit , icon = \"power\" , shortcut = \"cmd+q\" ), ] update_menu () app . build ( nib . Text ( \"Right-click the menu bar icon to see the menu.\" , padding = 24 )) nib . run ( main )","title":"Context Menu"},{"location":"guides/context-menu/#basic-menu","text":"import nib def main ( app : nib . App ): app . title = \"My App\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . width = 300 app . height = 200 def open_settings (): print ( \"Settings opened\" ) app . menu = [ nib . MenuItem ( \"Settings\" , action = open_settings , icon = \"gear\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit ), ] app . build ( nib . Text ( \"Right-click the menu bar icon\" , padding = 24 )) nib . run ( main )","title":"Basic Menu"},{"location":"guides/context-menu/#menuitem-parameters","text":"Parameter Type Description title str Menu item text (optional if content is provided) action callable Function called when the item is clicked icon str or SFSymbol SF Symbol name or SFSymbol instance with styling shortcut str Keyboard shortcut (e.g., \"cmd+q\" , \"cmd+shift+n\" ) badge str Badge text on the right side (macOS 14+) state str Checkmark state: \"on\" , \"off\" , or \"mixed\" enabled bool Whether the item is clickable (default True ) content View Custom view content (replaces title/icon) menu list Child items for a submenu height float Custom height for content-based items","title":"MenuItem Parameters"},{"location":"guides/context-menu/#icons","text":"Pass a string for a simple SF Symbol icon, or an SFSymbol instance for styled icons: # Simple string icon nib . MenuItem ( \"Settings\" , action = handler , icon = \"gear\" ) # Styled icon with color nib . MenuItem ( \"Favorites\" , action = handler , icon = nib . SFSymbol ( \"star.fill\" , foreground_color = nib . Color . YELLOW ), )","title":"Icons"},{"location":"guides/context-menu/#keyboard-shortcuts","text":"Use the shortcut parameter with modifier keys joined by + : nib . MenuItem ( \"Settings\" , action = open_settings , shortcut = \"cmd+,\" ) nib . MenuItem ( \"New Window\" , action = new_window , shortcut = \"cmd+n\" ) nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ) nib . MenuItem ( \"Refresh\" , action = refresh , shortcut = \"cmd+shift+r\" ) nib . MenuItem ( \"Toggle\" , action = toggle , shortcut = \"opt+t\" ) Supported modifiers: cmd , shift , opt (or alt ), ctrl .","title":"Keyboard Shortcuts"},{"location":"guides/context-menu/#badges","text":"Badges display a small label on the right side of the menu item. They are useful for showing counts or status. nib . MenuItem ( \"Updates\" , action = check_updates , badge = \"3\" ) nib . MenuItem ( \"Messages\" , action = open_messages , badge = \"New\" ) Note Badges require macOS 14 (Sonoma) or later.","title":"Badges"},{"location":"guides/context-menu/#state-indicators","text":"The state parameter shows a checkmark, no mark, or a mixed indicator: nib . MenuItem ( \"Enabled\" , action = toggle_feature , state = \"on\" ) # Checkmark nib . MenuItem ( \"Disabled\" , action = toggle_feature , state = \"off\" ) # No mark nib . MenuItem ( \"Partial\" , action = toggle_feature , state = \"mixed\" ) # Dash mark A common pattern is to toggle the state dynamically: feature_on = False def toggle_feature (): global feature_on feature_on = not feature_on rebuild_menu () def rebuild_menu (): app . menu = [ nib . MenuItem ( \"Feature\" , action = toggle_feature , state = \"on\" if feature_on else \"off\" , icon = \"checkmark.circle\" , ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit ), ]","title":"State Indicators"},{"location":"guides/context-menu/#disabled-items","text":"Set enabled=False to gray out an item and prevent clicks: nib . MenuItem ( \"Unavailable\" , enabled = False ) nib . MenuItem ( \"Premium Only\" , action = upgrade , enabled = is_premium )","title":"Disabled Items"},{"location":"guides/context-menu/#menu-dividers","text":"MenuDivider draws a horizontal separator line between items: app . menu = [ nib . MenuItem ( \"Action 1\" , action = handler1 ), nib . MenuItem ( \"Action 2\" , action = handler2 ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit ), ]","title":"Menu Dividers"},{"location":"guides/context-menu/#submenus","text":"Nest menus by passing a menu list to a MenuItem : nib . MenuItem ( \"Export\" , icon = \"square.and.arrow.up\" , menu = [ nib . MenuItem ( \"Export as PDF\" , action = export_pdf , icon = \"doc\" ), nib . MenuItem ( \"Export as PNG\" , action = export_png , icon = \"photo\" ), nib . MenuItem ( \"Export as CSV\" , action = export_csv , icon = \"tablecells\" ), ], ) Submenus can be nested to any depth: nib . MenuItem ( \"More\" , icon = \"ellipsis.circle\" , menu = [ nib . MenuItem ( \"Level 1\" , menu = [ nib . MenuItem ( \"Level 2 - A\" , action = handler_a ), nib . MenuItem ( \"Level 2 - B\" , action = handler_b ), ]), ], )","title":"Submenus"},{"location":"guides/context-menu/#custom-view-content","text":"For rich menu items, use the content parameter with any Nib view. When using content , the title and icon parameters are ignored. nib . MenuItem ( content = nib . HStack ( controls = [ nib . SFSymbol ( \"star.fill\" , foreground_color = nib . Color . YELLOW ), nib . VStack ( controls = [ nib . Text ( \"Premium\" , font = nib . Font . HEADLINE ), nib . Text ( \"Upgrade now\" , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), ], spacing = 8 , ), action = upgrade , height = 50 , ) Tip Set the height parameter when using content to ensure the menu item has enough vertical space for your custom view.","title":"Custom View Content"},{"location":"guides/context-menu/#full-example","text":"A complete menu demonstrating all features: import nib def main ( app : nib . App ): app . title = \"Menu Demo\" app . icon = nib . SFSymbol ( \"menucard\" ) app . width = 300 app . height = 200 notifications_on = True dark_mode = False def toggle_notifications (): nonlocal notifications_on notifications_on = not notifications_on update_menu () def toggle_dark_mode (): nonlocal dark_mode dark_mode = not dark_mode update_menu () def update_menu (): app . menu = [ # Custom view item nib . MenuItem ( content = nib . HStack ( controls = [ nib . SFSymbol ( \"person.circle.fill\" , foreground_color = nib . Color . BLUE , font = nib . Font . TITLE ), nib . VStack ( controls = [ nib . Text ( \"John Doe\" , font = nib . Font . HEADLINE ), nib . Text ( \"john@example.com\" , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), ], spacing = 10 , ), height = 50 , ), nib . MenuDivider (), # State toggle items nib . MenuItem ( \"Notifications\" , action = toggle_notifications , icon = \"bell.fill\" , state = \"on\" if notifications_on else \"off\" , ), nib . MenuItem ( \"Dark Mode\" , action = toggle_dark_mode , icon = \"moon.fill\" , state = \"on\" if dark_mode else \"off\" , ), nib . MenuDivider (), # Badge item nib . MenuItem ( \"Updates Available\" , icon = \"arrow.down.circle\" , badge = \"2\" ), # Disabled item nib . MenuItem ( \"Premium Feature\" , icon = \"lock.fill\" , enabled = False ), # Submenu nib . MenuItem ( \"Export\" , icon = \"square.and.arrow.up\" , menu = [ nib . MenuItem ( \"PDF\" , action = lambda : print ( \"PDF\" ), shortcut = \"cmd+p\" ), nib . MenuItem ( \"PNG\" , action = lambda : print ( \"PNG\" )), nib . MenuItem ( \"CSV\" , action = lambda : print ( \"CSV\" )), ], ), nib . MenuDivider (), # Quit with shortcut nib . MenuItem ( \"Quit\" , action = app . quit , icon = \"power\" , shortcut = \"cmd+q\" ), ] update_menu () app . build ( nib . Text ( \"Right-click the menu bar icon to see the menu.\" , padding = 24 )) nib . run ( main )","title":"Full Example"},{"location":"guides/custom-fonts/","text":"Nib supports loading custom font files for use in your views. Fonts can be auto-detected from the assets directory, registered manually by path, or loaded from a URL. Auto-detection from assets \u00b6 The simplest approach is to place font files in your assets/ directory. Nib scans for font files automatically before the first render: myapp/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main.py \u2502 \u2514\u2500\u2500 assets/ \u2502 \u251c\u2500\u2500 Geist-Regular.ttf \u2502 \u251c\u2500\u2500 Geist-Bold.ttf \u2502 \u2514\u2500\u2500 FiraCode-Regular.otf Font files are detected by extension. Supported formats: Extension Format .ttf TrueType .otf OpenType .ttc TrueType Collection .woff Web Open Font Format .woff2 Web Open Font Format 2 Font naming \u00b6 The font name is derived from the filename without its extension. For example: Filename Font name Geist-Regular.ttf Geist-Regular FiraCode-Medium.otf FiraCode-Medium Inter-Bold.ttf Inter-Bold Subdirectory scanning \u00b6 Nib scans the assets directory recursively, so you can organize fonts in subdirectories: assets/ \u251c\u2500\u2500 fonts/ \u2502 \u251c\u2500\u2500 Geist-Regular.ttf \u2502 \u2514\u2500\u2500 Geist-Bold.ttf \u2514\u2500\u2500 images/ \u2514\u2500\u2500 logo.png Both fonts will be detected and available by their filename-based names. Manual registration \u00b6 For fonts outside the assets directory, register them explicitly with app.fonts : app . fonts = { \"MyCustomFont\" : \"/absolute/path/to/MyCustomFont.ttf\" , \"AnotherFont\" : \"/Users/me/Library/Fonts/AnotherFont.otf\" , } The dictionary maps font names (used in code) to absolute file paths. URL-based fonts \u00b6 You can also load fonts from a URL: app . fonts = { \"WebFont\" : \"https://example.com/fonts/WebFont.ttf\" , } The Swift runtime downloads and caches the font at startup. Combining auto-detection and manual registration \u00b6 Manual registrations are merged with auto-detected fonts. If there is a name conflict, the manual registration takes precedence: # Auto-detected fonts from assets/ are available automatically. # These manual entries are added on top: app . fonts = { \"Geist-Regular\" : \"/path/to/override/Geist-Regular.ttf\" , # overrides auto-detected \"ExternalFont\" : \"/other/path/ExternalFont.otf\" , # new font } Using custom fonts \u00b6 Once registered (automatically or manually), use nib.Font.custom() to reference a custom font: nib . Text ( \"Hello, World!\" , font = nib . Font . custom ( \"Geist-Regular\" , size = 16 )) The first argument is the font name (matching the registered name), and size is the point size. In different views \u00b6 Custom fonts work anywhere a font parameter is accepted: # Text nib . Text ( \"Custom styled text\" , font = nib . Font . custom ( \"FiraCode-Regular\" , size = 14 )) # TextField nib . TextField ( value = \"\" , placeholder = \"Type here\" , font = nib . Font . custom ( \"Inter-Bold\" , size = 14 )) # Button nib . Button ( content = nib . Text ( \"Click Me\" , font = nib . Font . custom ( \"Geist-Bold\" , size = 16 )), action = on_click , ) On Canvas \u00b6 Custom fonts work with the nib.draw.Text command as well: canvas . draw ([ nib . draw . Text ( \"Canvas text\" , x = 10 , y = 50 , font = nib . Font . custom ( \"Geist-Regular\" , size = 20 ), fill = \"#ffffff\" , ), ]) Font loading order \u00b6 Font discovery and registration happens in this order: Nib auto-detects font files in the assets/ directory (recursively). Manually registered fonts via app.fonts are merged in, overriding any auto-detected fonts with the same name. The combined font dictionary is sent to the Swift runtime on the first render. Swift loads and registers all fonts before displaying the UI. Note Font loading happens once, before the first render. If you update app.fonts after the app is running, the new fonts will be sent on the next re-render. Complete example \u00b6 import nib def main ( app : nib . App ): app . title = \"Fonts\" app . icon = nib . SFSymbol ( \"textformat\" ) app . width = 350 app . height = 350 # Manual registration (auto-detection from assets/ also works) app . fonts = { \"Geist-Regular\" : \"/Users/me/fonts/Geist-Regular.ttf\" , \"Geist-Bold\" : \"/Users/me/fonts/Geist-Bold.ttf\" , } app . build ( nib . VStack ( controls = [ nib . Text ( \"System Font\" , font = nib . Font . TITLE ), nib . Divider (), nib . Text ( \"Custom Regular\" , font = nib . Font . custom ( \"Geist-Regular\" , size = 18 ), ), nib . Text ( \"Custom Bold\" , font = nib . Font . custom ( \"Geist-Bold\" , size = 18 ), ), nib . Divider (), nib . Text ( \"Small custom font\" , font = nib . Font . custom ( \"Geist-Regular\" , size = 12 ), foreground_color = nib . Color . GRAY , ), nib . Text ( \"Large custom font\" , font = nib . Font . custom ( \"Geist-Bold\" , size = 28 ), ), ], spacing = 12 , padding = 24 , ) ) nib . run ( main ) Tip For the best developer experience, place font files in assets/ and let auto-detection handle everything. You only need manual registration for fonts stored outside your project directory or loaded from URLs.","title":"Custom Fonts"},{"location":"guides/custom-fonts/#auto-detection-from-assets","text":"The simplest approach is to place font files in your assets/ directory. Nib scans for font files automatically before the first render: myapp/ \u251c\u2500\u2500 src/ \u2502 \u251c\u2500\u2500 main.py \u2502 \u2514\u2500\u2500 assets/ \u2502 \u251c\u2500\u2500 Geist-Regular.ttf \u2502 \u251c\u2500\u2500 Geist-Bold.ttf \u2502 \u2514\u2500\u2500 FiraCode-Regular.otf Font files are detected by extension. Supported formats: Extension Format .ttf TrueType .otf OpenType .ttc TrueType Collection .woff Web Open Font Format .woff2 Web Open Font Format 2","title":"Auto-detection from assets"},{"location":"guides/custom-fonts/#font-naming","text":"The font name is derived from the filename without its extension. For example: Filename Font name Geist-Regular.ttf Geist-Regular FiraCode-Medium.otf FiraCode-Medium Inter-Bold.ttf Inter-Bold","title":"Font naming"},{"location":"guides/custom-fonts/#subdirectory-scanning","text":"Nib scans the assets directory recursively, so you can organize fonts in subdirectories: assets/ \u251c\u2500\u2500 fonts/ \u2502 \u251c\u2500\u2500 Geist-Regular.ttf \u2502 \u2514\u2500\u2500 Geist-Bold.ttf \u2514\u2500\u2500 images/ \u2514\u2500\u2500 logo.png Both fonts will be detected and available by their filename-based names.","title":"Subdirectory scanning"},{"location":"guides/custom-fonts/#manual-registration","text":"For fonts outside the assets directory, register them explicitly with app.fonts : app . fonts = { \"MyCustomFont\" : \"/absolute/path/to/MyCustomFont.ttf\" , \"AnotherFont\" : \"/Users/me/Library/Fonts/AnotherFont.otf\" , } The dictionary maps font names (used in code) to absolute file paths.","title":"Manual registration"},{"location":"guides/custom-fonts/#url-based-fonts","text":"You can also load fonts from a URL: app . fonts = { \"WebFont\" : \"https://example.com/fonts/WebFont.ttf\" , } The Swift runtime downloads and caches the font at startup.","title":"URL-based fonts"},{"location":"guides/custom-fonts/#combining-auto-detection-and-manual-registration","text":"Manual registrations are merged with auto-detected fonts. If there is a name conflict, the manual registration takes precedence: # Auto-detected fonts from assets/ are available automatically. # These manual entries are added on top: app . fonts = { \"Geist-Regular\" : \"/path/to/override/Geist-Regular.ttf\" , # overrides auto-detected \"ExternalFont\" : \"/other/path/ExternalFont.otf\" , # new font }","title":"Combining auto-detection and manual registration"},{"location":"guides/custom-fonts/#using-custom-fonts","text":"Once registered (automatically or manually), use nib.Font.custom() to reference a custom font: nib . Text ( \"Hello, World!\" , font = nib . Font . custom ( \"Geist-Regular\" , size = 16 )) The first argument is the font name (matching the registered name), and size is the point size.","title":"Using custom fonts"},{"location":"guides/custom-fonts/#in-different-views","text":"Custom fonts work anywhere a font parameter is accepted: # Text nib . Text ( \"Custom styled text\" , font = nib . Font . custom ( \"FiraCode-Regular\" , size = 14 )) # TextField nib . TextField ( value = \"\" , placeholder = \"Type here\" , font = nib . Font . custom ( \"Inter-Bold\" , size = 14 )) # Button nib . Button ( content = nib . Text ( \"Click Me\" , font = nib . Font . custom ( \"Geist-Bold\" , size = 16 )), action = on_click , )","title":"In different views"},{"location":"guides/custom-fonts/#on-canvas","text":"Custom fonts work with the nib.draw.Text command as well: canvas . draw ([ nib . draw . Text ( \"Canvas text\" , x = 10 , y = 50 , font = nib . Font . custom ( \"Geist-Regular\" , size = 20 ), fill = \"#ffffff\" , ), ])","title":"On Canvas"},{"location":"guides/custom-fonts/#font-loading-order","text":"Font discovery and registration happens in this order: Nib auto-detects font files in the assets/ directory (recursively). Manually registered fonts via app.fonts are merged in, overriding any auto-detected fonts with the same name. The combined font dictionary is sent to the Swift runtime on the first render. Swift loads and registers all fonts before displaying the UI. Note Font loading happens once, before the first render. If you update app.fonts after the app is running, the new fonts will be sent on the next re-render.","title":"Font loading order"},{"location":"guides/custom-fonts/#complete-example","text":"import nib def main ( app : nib . App ): app . title = \"Fonts\" app . icon = nib . SFSymbol ( \"textformat\" ) app . width = 350 app . height = 350 # Manual registration (auto-detection from assets/ also works) app . fonts = { \"Geist-Regular\" : \"/Users/me/fonts/Geist-Regular.ttf\" , \"Geist-Bold\" : \"/Users/me/fonts/Geist-Bold.ttf\" , } app . build ( nib . VStack ( controls = [ nib . Text ( \"System Font\" , font = nib . Font . TITLE ), nib . Divider (), nib . Text ( \"Custom Regular\" , font = nib . Font . custom ( \"Geist-Regular\" , size = 18 ), ), nib . Text ( \"Custom Bold\" , font = nib . Font . custom ( \"Geist-Bold\" , size = 18 ), ), nib . Divider (), nib . Text ( \"Small custom font\" , font = nib . Font . custom ( \"Geist-Regular\" , size = 12 ), foreground_color = nib . Color . GRAY , ), nib . Text ( \"Large custom font\" , font = nib . Font . custom ( \"Geist-Bold\" , size = 28 ), ), ], spacing = 12 , padding = 24 , ) ) nib . run ( main ) Tip For the best developer experience, place font files in assets/ and let auto-detection handle everything. You only need manual registration for fonts stored outside your project directory or loaded from URLs.","title":"Complete example"},{"location":"guides/drag-drop/","text":"Any container view in Nib supports drag-and-drop file handling through the on_drop parameter. When a user drags files or directories from Finder onto your view, Nib invokes your callback with a list of absolute file paths. Basic usage \u00b6 Pass an on_drop callback to any container view: import nib def main ( app : nib . App ): app . title = \"Drop Zone\" app . icon = nib . SFSymbol ( \"arrow.down.doc\" ) app . width = 300 app . height = 250 status = nib . Text ( \"Drop files here\" , foreground_color = nib . Color . GRAY ) def handle_drop ( paths : list [ str ]): status . content = f \"Received { len ( paths ) } file(s)\" for path in paths : print ( f \"Dropped: { path } \" ) app . build ( nib . VStack ( controls = [ nib . SFSymbol ( \"arrow.down.circle\" , font = nib . Font . system ( 48 )), status , ], spacing = 16 , padding = 32 , on_drop = handle_drop , border_color = \"gray\" , border_width = 1 , corner_radius = 12 , ) ) nib . run ( main ) Callback signature \u00b6 The on_drop callback receives a single argument -- a list of absolute file system path strings: def handle_drop ( paths : list [ str ]): for path in paths : print ( path ) # e.g., \"/Users/me/Desktop/report.pdf\" The paths are absolute and can point to either files or directories. Supported container views \u00b6 The on_drop parameter is available on all views that inherit from the base View class. Common choices for drop zones include: VStack , HStack , ZStack ScrollView List Group Form nib . HStack ( controls = [ nib . Text ( \"Drop here\" )], on_drop = handle_drop , padding = 24 , ) Working with dropped files \u00b6 Reading file contents \u00b6 def handle_drop ( paths : list [ str ]): for path in paths : if path . endswith ( \".txt\" ): with open ( path , \"r\" ) as f : content = f . read () text_view . content = content Checking file types \u00b6 import os def handle_drop ( paths : list [ str ]): images = [ p for p in paths if p . lower () . endswith (( \".png\" , \".jpg\" , \".jpeg\" , \".gif\" ))] if images : status . content = f \"Received { len ( images ) } image(s)\" else : status . content = \"No images found\" Handling directories \u00b6 import os def handle_drop ( paths : list [ str ]): for path in paths : if os . path . isdir ( path ): files = os . listdir ( path ) status . content = f \"Folder with { len ( files ) } items\" else : size = os . path . getsize ( path ) status . content = f \" { os . path . basename ( path ) } ( { size : , } bytes)\" Complete example \u00b6 A file drop zone that displays information about dropped files: import nib import os def main ( app : nib . App ): app . title = \"File Info\" app . icon = nib . SFSymbol ( \"doc.badge.plus\" ) app . width = 350 app . height = 400 file_list = nib . VStack ( controls = [], spacing = 4 ) status = nib . Text ( \"Drag files here to inspect\" , foreground_color = nib . Color . GRAY , font = nib . Font . CAPTION , ) def handle_drop ( paths : list [ str ]): items = [] for path in paths : name = os . path . basename ( path ) if os . path . isdir ( path ): count = len ( os . listdir ( path )) items . append ( nib . HStack ( controls = [ nib . SFSymbol ( \"folder.fill\" , foreground_color = \"#F59E0B\" ), nib . VStack ( controls = [ nib . Text ( name , font = nib . Font . HEADLINE ), nib . Text ( f \" { count } items\" , font = nib . Font . CAPTION , foreground_color = nib . Color . GRAY , ), ], spacing = 2 , ), ], spacing = 8 , ) ) else : size = os . path . getsize ( path ) ext = os . path . splitext ( name )[ 1 ] . upper () or \"FILE\" items . append ( nib . HStack ( controls = [ nib . SFSymbol ( \"doc.fill\" , foreground_color = \"#3B82F6\" ), nib . VStack ( controls = [ nib . Text ( name , font = nib . Font . HEADLINE ), nib . Text ( f \" { ext } - { size : , } bytes\" , font = nib . Font . CAPTION , foreground_color = nib . Color . GRAY , ), ], spacing = 2 , ), ], spacing = 8 , ) ) status . content = f \" { len ( paths ) } item(s) dropped\" file_list . _children = items app . update () app . build ( nib . VStack ( controls = [ nib . Text ( \"File Inspector\" , font = nib . Font . TITLE ), nib . ScrollView ( controls = [ file_list ], ), nib . Divider (), status , ], spacing = 8 , padding = 16 , on_drop = handle_drop , ) ) nib . run ( main ) Tip The on_drop handler runs on the Python side, so you have full access to the file system. You can read files, compute checksums, parse data -- anything Python can do.","title":"Drag & Drop"},{"location":"guides/drag-drop/#basic-usage","text":"Pass an on_drop callback to any container view: import nib def main ( app : nib . App ): app . title = \"Drop Zone\" app . icon = nib . SFSymbol ( \"arrow.down.doc\" ) app . width = 300 app . height = 250 status = nib . Text ( \"Drop files here\" , foreground_color = nib . Color . GRAY ) def handle_drop ( paths : list [ str ]): status . content = f \"Received { len ( paths ) } file(s)\" for path in paths : print ( f \"Dropped: { path } \" ) app . build ( nib . VStack ( controls = [ nib . SFSymbol ( \"arrow.down.circle\" , font = nib . Font . system ( 48 )), status , ], spacing = 16 , padding = 32 , on_drop = handle_drop , border_color = \"gray\" , border_width = 1 , corner_radius = 12 , ) ) nib . run ( main )","title":"Basic usage"},{"location":"guides/drag-drop/#callback-signature","text":"The on_drop callback receives a single argument -- a list of absolute file system path strings: def handle_drop ( paths : list [ str ]): for path in paths : print ( path ) # e.g., \"/Users/me/Desktop/report.pdf\" The paths are absolute and can point to either files or directories.","title":"Callback signature"},{"location":"guides/drag-drop/#supported-container-views","text":"The on_drop parameter is available on all views that inherit from the base View class. Common choices for drop zones include: VStack , HStack , ZStack ScrollView List Group Form nib . HStack ( controls = [ nib . Text ( \"Drop here\" )], on_drop = handle_drop , padding = 24 , )","title":"Supported container views"},{"location":"guides/drag-drop/#working-with-dropped-files","text":"","title":"Working with dropped files"},{"location":"guides/drag-drop/#reading-file-contents","text":"def handle_drop ( paths : list [ str ]): for path in paths : if path . endswith ( \".txt\" ): with open ( path , \"r\" ) as f : content = f . read () text_view . content = content","title":"Reading file contents"},{"location":"guides/drag-drop/#checking-file-types","text":"import os def handle_drop ( paths : list [ str ]): images = [ p for p in paths if p . lower () . endswith (( \".png\" , \".jpg\" , \".jpeg\" , \".gif\" ))] if images : status . content = f \"Received { len ( images ) } image(s)\" else : status . content = \"No images found\"","title":"Checking file types"},{"location":"guides/drag-drop/#handling-directories","text":"import os def handle_drop ( paths : list [ str ]): for path in paths : if os . path . isdir ( path ): files = os . listdir ( path ) status . content = f \"Folder with { len ( files ) } items\" else : size = os . path . getsize ( path ) status . content = f \" { os . path . basename ( path ) } ( { size : , } bytes)\"","title":"Handling directories"},{"location":"guides/drag-drop/#complete-example","text":"A file drop zone that displays information about dropped files: import nib import os def main ( app : nib . App ): app . title = \"File Info\" app . icon = nib . SFSymbol ( \"doc.badge.plus\" ) app . width = 350 app . height = 400 file_list = nib . VStack ( controls = [], spacing = 4 ) status = nib . Text ( \"Drag files here to inspect\" , foreground_color = nib . Color . GRAY , font = nib . Font . CAPTION , ) def handle_drop ( paths : list [ str ]): items = [] for path in paths : name = os . path . basename ( path ) if os . path . isdir ( path ): count = len ( os . listdir ( path )) items . append ( nib . HStack ( controls = [ nib . SFSymbol ( \"folder.fill\" , foreground_color = \"#F59E0B\" ), nib . VStack ( controls = [ nib . Text ( name , font = nib . Font . HEADLINE ), nib . Text ( f \" { count } items\" , font = nib . Font . CAPTION , foreground_color = nib . Color . GRAY , ), ], spacing = 2 , ), ], spacing = 8 , ) ) else : size = os . path . getsize ( path ) ext = os . path . splitext ( name )[ 1 ] . upper () or \"FILE\" items . append ( nib . HStack ( controls = [ nib . SFSymbol ( \"doc.fill\" , foreground_color = \"#3B82F6\" ), nib . VStack ( controls = [ nib . Text ( name , font = nib . Font . HEADLINE ), nib . Text ( f \" { ext } - { size : , } bytes\" , font = nib . Font . CAPTION , foreground_color = nib . Color . GRAY , ), ], spacing = 2 , ), ], spacing = 8 , ) ) status . content = f \" { len ( paths ) } item(s) dropped\" file_list . _children = items app . update () app . build ( nib . VStack ( controls = [ nib . Text ( \"File Inspector\" , font = nib . Font . TITLE ), nib . ScrollView ( controls = [ file_list ], ), nib . Divider (), status , ], spacing = 8 , padding = 16 , on_drop = handle_drop , ) ) nib . run ( main ) Tip The on_drop handler runs on the Python side, so you have full access to the file system. You can read files, compute checksums, parse data -- anything Python can do.","title":"Complete example"},{"location":"guides/file-dialogs/","text":"Nib provides native macOS file dialogs (NSOpenPanel and NSSavePanel) through the FilePicker class. You can pick files, pick directories, and save files -- all with full access to dialog options like file type filtering, hidden file visibility, and Finder tag support. Creating a FilePicker \u00b6 import nib picker = nib . FilePicker () The FilePicker automatically uses the current running app instance. You can also pass an explicit App reference: picker = nib . FilePicker ( app ) Note All FilePicker methods are blocking -- they pause execution until the user selects a file or cancels the dialog, then return the result directly. No callbacks needed. Picking files \u00b6 Use pick_files() to open a file selection dialog: files = picker . pick_files ( extensions = [ \"txt\" , \"md\" ], title = \"Select Text Files\" , ) if files : for f in files : print ( f \"Name: { f . name } \" ) print ( f \"Path: { f . path } \" ) print ( f \"Size: { f . size } bytes\" ) The method returns a list of PickedFile objects, or None if the user cancelled. Selecting multiple files \u00b6 files = picker . pick_files ( extensions = [ \"png\" , \"jpg\" , \"gif\" ], multiple = True , title = \"Select Images\" , ) if files : print ( f \"Selected { len ( files ) } file(s)\" ) Full parameter list \u00b6 Parameter Type Default Description multiple bool False Allow selecting multiple files extensions list[str] None Allowed file extensions (e.g., [\"png\", \"jpg\"] ) uttypes list[str] None Allowed Uniform Type Identifiers (e.g., [\"public.image\"] ) directory str None Initial directory path title str \"Select Files\" Dialog window title message str None Prompt text shown below the title button_label str \"Open\" Text for the OK button shows_hidden_files bool False Show hidden files in the dialog resolves_aliases bool True Follow alias files to their targets allows_other_file_types bool False Allow files outside the allowed types treats_packages_as_directories bool False Treat .app bundles as folders validator Callable None Validation function (see below) PickedFile dataclass \u00b6 Each selected file is returned as a PickedFile with these fields: Field Type Description name str Filename (e.g., \"document.txt\" ) path str Absolute file path size int File size in bytes uti str or None Uniform Type Identifier (e.g., \"public.plain-text\" ) tags list[str] macOS Finder tags Picking a directory \u00b6 Use pick_directory() to let the user choose a folder: dirs = picker . pick_directory ( title = \"Select Output Folder\" ) if dirs : output_dir = dirs [ 0 ] print ( f \"Selected: { output_dir } \" ) The method returns a list of directory path strings, or None if cancelled. Multiple directories \u00b6 dirs = picker . pick_directory ( multiple = True , title = \"Select Folders to Scan\" , ) Full parameter list \u00b6 Parameter Type Default Description multiple bool False Allow selecting multiple directories directory str None Initial directory path title str \"Select Folder\" Dialog window title message str None Prompt text shown below the title button_label str \"Select\" Text for the OK button shows_hidden_files bool False Show hidden files resolves_aliases bool True Follow aliases to targets can_create_directories bool True Allow creating new folders validator Callable None Validation function Saving a file \u00b6 Use save_file() to show a save dialog: result = picker . save_file ( filename = \"output.txt\" , extensions = [ \"txt\" ], title = \"Save Report\" , ) if result : print ( f \"Save to: { result . path } \" ) print ( f \"Tags: { result . tags } \" ) The method returns a SaveResult object, or None if cancelled. Full parameter list \u00b6 Parameter Type Default Description filename str None Suggested filename extensions list[str] None Allowed file extensions uttypes list[str] None Allowed Uniform Type Identifiers directory str None Initial directory path title str \"Save File\" Dialog window title message str None Prompt text shown below the title button_label str \"Save\" Text for the Save button name_field_label str \"Save As:\" Label for the filename field shows_hidden_files bool False Show hidden files can_create_directories bool True Allow creating new folders allows_other_file_types bool False Allow extensions outside the allowed list shows_tag_field bool True Show the Finder tags selector validator Callable None Validation function SaveResult dataclass \u00b6 Field Type Description path str The chosen save path tags list[str] User-selected Finder tags Validation \u00b6 All three methods accept a validator parameter. The validator is a function that receives the selected path(s) and returns None if valid, or an error message string if invalid: def validate_size ( paths : list [ str ]) -> str | None : import os for path in paths : if os . path . getsize ( path ) > 10_000_000 : return \"File must be under 10 MB\" return None files = picker . pick_files ( extensions = [ \"csv\" ], validator = validate_size , ) For save_file() , the validator receives a single path string instead of a list: def validate_save ( path : str ) -> str | None : if path . endswith ( \".system\" ): return \"Cannot overwrite system files\" return None result = picker . save_file ( validator = validate_save ) App-level shortcuts \u00b6 The App class also provides shortcut methods for file dialogs that use a callback-based pattern: def main ( app : nib . App ): def handle_file ( path ): print ( f \"Selected: { path } \" ) def handle_save ( path ): print ( f \"Save to: { path } \" ) app . build ( nib . VStack ( controls = [ nib . Button ( \"Open File\" , action = lambda : app . open_file_dialog ( callback = handle_file , types = [ \"txt\" , \"md\" ], )), nib . Button ( \"Save File\" , action = lambda : app . save_file_dialog ( callback = handle_save , )), ], spacing = 8 , padding = 16 , ) ) Tip Prefer the FilePicker class for new code. It provides a more complete API with blocking semantics that are easier to work with. Complete example \u00b6 A file viewer app that lets you open text files and display their contents: import nib def main ( app : nib . App ): app . title = \"File Viewer\" app . icon = nib . SFSymbol ( \"doc.text\" ) app . width = 400 app . height = 500 picker = nib . FilePicker () file_name = nib . Text ( \"No file selected\" , font = nib . Font . HEADLINE ) file_content = nib . Text ( \"\" , font = nib . Font . system ( 12 )) file_size = nib . Text ( \"\" , foreground_color = nib . Color . GRAY ) def open_file (): files = picker . pick_files ( extensions = [ \"txt\" , \"md\" , \"py\" , \"json\" ], title = \"Open Text File\" , message = \"Choose a file to view\" , ) if files : f = files [ 0 ] file_name . content = f . name file_size . content = f \" { f . size : , } bytes\" try : with open ( f . path , \"r\" ) as fh : file_content . content = fh . read () except Exception as e : file_content . content = f \"Error reading file: { e } \" def save_file (): if not file_content . content : return result = picker . save_file ( filename = \"copy.txt\" , extensions = [ \"txt\" ], title = \"Save Copy\" , ) if result : with open ( result . path , \"w\" ) as fh : fh . write ( file_content . content ) app . notify ( \"Saved\" , f \"File saved to { result . path } \" ) app . build ( nib . VStack ( controls = [ nib . HStack ( controls = [ file_name , nib . Spacer (), file_size , ], ), nib . Divider (), nib . ScrollView ( controls = [ file_content ], ), nib . HStack ( controls = [ nib . Button ( \"Open\" , action = open_file ), nib . Button ( \"Save Copy\" , action = save_file ), ], spacing = 8 , ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"File Dialogs"},{"location":"guides/file-dialogs/#creating-a-filepicker","text":"import nib picker = nib . FilePicker () The FilePicker automatically uses the current running app instance. You can also pass an explicit App reference: picker = nib . FilePicker ( app ) Note All FilePicker methods are blocking -- they pause execution until the user selects a file or cancels the dialog, then return the result directly. No callbacks needed.","title":"Creating a FilePicker"},{"location":"guides/file-dialogs/#picking-files","text":"Use pick_files() to open a file selection dialog: files = picker . pick_files ( extensions = [ \"txt\" , \"md\" ], title = \"Select Text Files\" , ) if files : for f in files : print ( f \"Name: { f . name } \" ) print ( f \"Path: { f . path } \" ) print ( f \"Size: { f . size } bytes\" ) The method returns a list of PickedFile objects, or None if the user cancelled.","title":"Picking files"},{"location":"guides/file-dialogs/#selecting-multiple-files","text":"files = picker . pick_files ( extensions = [ \"png\" , \"jpg\" , \"gif\" ], multiple = True , title = \"Select Images\" , ) if files : print ( f \"Selected { len ( files ) } file(s)\" )","title":"Selecting multiple files"},{"location":"guides/file-dialogs/#full-parameter-list","text":"Parameter Type Default Description multiple bool False Allow selecting multiple files extensions list[str] None Allowed file extensions (e.g., [\"png\", \"jpg\"] ) uttypes list[str] None Allowed Uniform Type Identifiers (e.g., [\"public.image\"] ) directory str None Initial directory path title str \"Select Files\" Dialog window title message str None Prompt text shown below the title button_label str \"Open\" Text for the OK button shows_hidden_files bool False Show hidden files in the dialog resolves_aliases bool True Follow alias files to their targets allows_other_file_types bool False Allow files outside the allowed types treats_packages_as_directories bool False Treat .app bundles as folders validator Callable None Validation function (see below)","title":"Full parameter list"},{"location":"guides/file-dialogs/#pickedfile-dataclass","text":"Each selected file is returned as a PickedFile with these fields: Field Type Description name str Filename (e.g., \"document.txt\" ) path str Absolute file path size int File size in bytes uti str or None Uniform Type Identifier (e.g., \"public.plain-text\" ) tags list[str] macOS Finder tags","title":"PickedFile dataclass"},{"location":"guides/file-dialogs/#picking-a-directory","text":"Use pick_directory() to let the user choose a folder: dirs = picker . pick_directory ( title = \"Select Output Folder\" ) if dirs : output_dir = dirs [ 0 ] print ( f \"Selected: { output_dir } \" ) The method returns a list of directory path strings, or None if cancelled.","title":"Picking a directory"},{"location":"guides/file-dialogs/#multiple-directories","text":"dirs = picker . pick_directory ( multiple = True , title = \"Select Folders to Scan\" , )","title":"Multiple directories"},{"location":"guides/file-dialogs/#full-parameter-list_1","text":"Parameter Type Default Description multiple bool False Allow selecting multiple directories directory str None Initial directory path title str \"Select Folder\" Dialog window title message str None Prompt text shown below the title button_label str \"Select\" Text for the OK button shows_hidden_files bool False Show hidden files resolves_aliases bool True Follow aliases to targets can_create_directories bool True Allow creating new folders validator Callable None Validation function","title":"Full parameter list"},{"location":"guides/file-dialogs/#saving-a-file","text":"Use save_file() to show a save dialog: result = picker . save_file ( filename = \"output.txt\" , extensions = [ \"txt\" ], title = \"Save Report\" , ) if result : print ( f \"Save to: { result . path } \" ) print ( f \"Tags: { result . tags } \" ) The method returns a SaveResult object, or None if cancelled.","title":"Saving a file"},{"location":"guides/file-dialogs/#full-parameter-list_2","text":"Parameter Type Default Description filename str None Suggested filename extensions list[str] None Allowed file extensions uttypes list[str] None Allowed Uniform Type Identifiers directory str None Initial directory path title str \"Save File\" Dialog window title message str None Prompt text shown below the title button_label str \"Save\" Text for the Save button name_field_label str \"Save As:\" Label for the filename field shows_hidden_files bool False Show hidden files can_create_directories bool True Allow creating new folders allows_other_file_types bool False Allow extensions outside the allowed list shows_tag_field bool True Show the Finder tags selector validator Callable None Validation function","title":"Full parameter list"},{"location":"guides/file-dialogs/#saveresult-dataclass","text":"Field Type Description path str The chosen save path tags list[str] User-selected Finder tags","title":"SaveResult dataclass"},{"location":"guides/file-dialogs/#validation","text":"All three methods accept a validator parameter. The validator is a function that receives the selected path(s) and returns None if valid, or an error message string if invalid: def validate_size ( paths : list [ str ]) -> str | None : import os for path in paths : if os . path . getsize ( path ) > 10_000_000 : return \"File must be under 10 MB\" return None files = picker . pick_files ( extensions = [ \"csv\" ], validator = validate_size , ) For save_file() , the validator receives a single path string instead of a list: def validate_save ( path : str ) -> str | None : if path . endswith ( \".system\" ): return \"Cannot overwrite system files\" return None result = picker . save_file ( validator = validate_save )","title":"Validation"},{"location":"guides/file-dialogs/#app-level-shortcuts","text":"The App class also provides shortcut methods for file dialogs that use a callback-based pattern: def main ( app : nib . App ): def handle_file ( path ): print ( f \"Selected: { path } \" ) def handle_save ( path ): print ( f \"Save to: { path } \" ) app . build ( nib . VStack ( controls = [ nib . Button ( \"Open File\" , action = lambda : app . open_file_dialog ( callback = handle_file , types = [ \"txt\" , \"md\" ], )), nib . Button ( \"Save File\" , action = lambda : app . save_file_dialog ( callback = handle_save , )), ], spacing = 8 , padding = 16 , ) ) Tip Prefer the FilePicker class for new code. It provides a more complete API with blocking semantics that are easier to work with.","title":"App-level shortcuts"},{"location":"guides/file-dialogs/#complete-example","text":"A file viewer app that lets you open text files and display their contents: import nib def main ( app : nib . App ): app . title = \"File Viewer\" app . icon = nib . SFSymbol ( \"doc.text\" ) app . width = 400 app . height = 500 picker = nib . FilePicker () file_name = nib . Text ( \"No file selected\" , font = nib . Font . HEADLINE ) file_content = nib . Text ( \"\" , font = nib . Font . system ( 12 )) file_size = nib . Text ( \"\" , foreground_color = nib . Color . GRAY ) def open_file (): files = picker . pick_files ( extensions = [ \"txt\" , \"md\" , \"py\" , \"json\" ], title = \"Open Text File\" , message = \"Choose a file to view\" , ) if files : f = files [ 0 ] file_name . content = f . name file_size . content = f \" { f . size : , } bytes\" try : with open ( f . path , \"r\" ) as fh : file_content . content = fh . read () except Exception as e : file_content . content = f \"Error reading file: { e } \" def save_file (): if not file_content . content : return result = picker . save_file ( filename = \"copy.txt\" , extensions = [ \"txt\" ], title = \"Save Copy\" , ) if result : with open ( result . path , \"w\" ) as fh : fh . write ( file_content . content ) app . notify ( \"Saved\" , f \"File saved to { result . path } \" ) app . build ( nib . VStack ( controls = [ nib . HStack ( controls = [ file_name , nib . Spacer (), file_size , ], ), nib . Divider (), nib . ScrollView ( controls = [ file_content ], ), nib . HStack ( controls = [ nib . Button ( \"Open\" , action = open_file ), nib . Button ( \"Save Copy\" , action = save_file ), ], spacing = 8 , ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Complete example"},{"location":"guides/hotkeys-clipboard/","text":"Nib provides global keyboard shortcuts (hotkeys) and clipboard access for integrating your menu bar app with system-wide workflows. Global hotkeys \u00b6 Register a global keyboard shortcut that works even when your app's popover is not visible: import nib def main ( app : nib . App ): app . title = \"Hotkey Demo\" app . icon = nib . SFSymbol ( \"keyboard\" ) app . width = 300 app . height = 200 status = nib . Text ( \"Press Cmd+Shift+N\" , font = nib . Font . HEADLINE ) def on_shortcut (): status . content = \"Hotkey pressed!\" app . on_hotkey ( \"cmd+shift+n\" , on_shortcut ) app . build ( nib . VStack ( controls = [ status ], padding = 24 , ) ) nib . run ( main ) Modifier keys \u00b6 Combine modifier keys with + : Modifier Key name Command cmd Shift shift Control ctrl Option/Alt opt or alt Examples of valid shortcut strings: app . on_hotkey ( \"cmd+k\" , callback ) app . on_hotkey ( \"cmd+shift+n\" , callback ) app . on_hotkey ( \"ctrl+opt+p\" , callback ) app . on_hotkey ( \"cmd+shift+ctrl+r\" , callback ) Note Hotkey strings are case-insensitive. \"cmd+shift+N\" and \"cmd+shift+n\" are equivalent. Decorator syntax \u00b6 Use the @app.hotkey() decorator as an alternative to app.on_hotkey() : @app . hotkey ( \"cmd+shift+n\" ) def create_new (): print ( \"Creating new item...\" ) @app . hotkey ( \"cmd+k\" ) def toggle_search (): print ( \"Toggle search...\" ) The decorator returns the original function, so you can still call it directly if needed. Multiple hotkeys \u00b6 Register as many hotkeys as you need: app . on_hotkey ( \"cmd+1\" , lambda : switch_tab ( 0 )) app . on_hotkey ( \"cmd+2\" , lambda : switch_tab ( 1 )) app . on_hotkey ( \"cmd+3\" , lambda : switch_tab ( 2 )) app . on_hotkey ( \"cmd+shift+c\" , copy_selection ) app . on_hotkey ( \"cmd+shift+v\" , paste_special ) Clipboard \u00b6 Writing to clipboard \u00b6 Set the clipboard content directly with a string assignment: app . clipboard = \"Hello, World!\" Or use the method form: app . set_clipboard ( \"Hello, World!\" ) Both are equivalent. The content is sent to the system clipboard immediately. Reading from clipboard \u00b6 Clipboard reads are asynchronous because they require a round trip to the Swift runtime. Use get_clipboard() with a callback: def on_clipboard ( content : str ): print ( f \"Clipboard contains: { content } \" ) app . get_clipboard ( on_clipboard ) The callback receives the current clipboard text as a string. Complete example \u00b6 A clipboard manager app with hotkey integration: import nib def main ( app : nib . App ): app . title = \"Clippy\" app . icon = nib . SFSymbol ( \"doc.on.clipboard\" ) app . width = 320 app . height = 400 history = [] history_list = nib . VStack ( controls = [], spacing = 4 ) status = nib . Text ( \"Ready\" , foreground_color = nib . Color . GRAY , font = nib . Font . CAPTION ) def update_list (): items = [] for i , text in enumerate ( history [ - 10 :]): preview = text [: 50 ] + ( \"...\" if len ( text ) > 50 else \"\" ) def make_copy ( t = text ): app . clipboard = t status . content = \"Copied to clipboard\" items . append ( nib . Button ( content = nib . HStack ( controls = [ nib . Text ( preview , font = nib . Font . system ( 12 ), ), nib . Spacer (), ], spacing = 4 , ), action = make_copy , ) ) history_list . _children = items app . update () def capture_clipboard (): def on_read ( content : str ): if content and ( not history or history [ - 1 ] != content ): history . append ( content ) status . content = f \"Captured: { len ( history ) } items\" update_list () app . get_clipboard ( on_read ) def clear_history (): history . clear () history_list . _children = [] status . content = \"History cleared\" app . update () # Global hotkey to capture current clipboard app . on_hotkey ( \"cmd+shift+c\" , capture_clipboard ) app . menu = [ nib . MenuItem ( \"Capture Clipboard\" , action = capture_clipboard , shortcut = \"cmd+shift+c\" ), nib . MenuItem ( \"Clear History\" , action = clear_history ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit ), ] app . build ( nib . VStack ( controls = [ nib . HStack ( controls = [ nib . Text ( \"Clipboard History\" , font = nib . Font . HEADLINE ), nib . Spacer (), nib . Button ( \"Capture\" , action = capture_clipboard ), ], ), nib . Divider (), nib . ScrollView ( controls = [ history_list ], ), nib . Divider (), status , ], spacing = 8 , padding = 12 , ) ) nib . run ( main ) Press Cmd+Shift+C from anywhere to capture the current clipboard content into the history. Click any entry to copy it back to the clipboard. Tip Global hotkeys work even when the popover is closed. This makes them useful for system-wide actions like toggling visibility, capturing clipboard contents, or triggering background tasks.","title":"Hotkeys & Clipboard"},{"location":"guides/hotkeys-clipboard/#global-hotkeys","text":"Register a global keyboard shortcut that works even when your app's popover is not visible: import nib def main ( app : nib . App ): app . title = \"Hotkey Demo\" app . icon = nib . SFSymbol ( \"keyboard\" ) app . width = 300 app . height = 200 status = nib . Text ( \"Press Cmd+Shift+N\" , font = nib . Font . HEADLINE ) def on_shortcut (): status . content = \"Hotkey pressed!\" app . on_hotkey ( \"cmd+shift+n\" , on_shortcut ) app . build ( nib . VStack ( controls = [ status ], padding = 24 , ) ) nib . run ( main )","title":"Global hotkeys"},{"location":"guides/hotkeys-clipboard/#modifier-keys","text":"Combine modifier keys with + : Modifier Key name Command cmd Shift shift Control ctrl Option/Alt opt or alt Examples of valid shortcut strings: app . on_hotkey ( \"cmd+k\" , callback ) app . on_hotkey ( \"cmd+shift+n\" , callback ) app . on_hotkey ( \"ctrl+opt+p\" , callback ) app . on_hotkey ( \"cmd+shift+ctrl+r\" , callback ) Note Hotkey strings are case-insensitive. \"cmd+shift+N\" and \"cmd+shift+n\" are equivalent.","title":"Modifier keys"},{"location":"guides/hotkeys-clipboard/#decorator-syntax","text":"Use the @app.hotkey() decorator as an alternative to app.on_hotkey() : @app . hotkey ( \"cmd+shift+n\" ) def create_new (): print ( \"Creating new item...\" ) @app . hotkey ( \"cmd+k\" ) def toggle_search (): print ( \"Toggle search...\" ) The decorator returns the original function, so you can still call it directly if needed.","title":"Decorator syntax"},{"location":"guides/hotkeys-clipboard/#multiple-hotkeys","text":"Register as many hotkeys as you need: app . on_hotkey ( \"cmd+1\" , lambda : switch_tab ( 0 )) app . on_hotkey ( \"cmd+2\" , lambda : switch_tab ( 1 )) app . on_hotkey ( \"cmd+3\" , lambda : switch_tab ( 2 )) app . on_hotkey ( \"cmd+shift+c\" , copy_selection ) app . on_hotkey ( \"cmd+shift+v\" , paste_special )","title":"Multiple hotkeys"},{"location":"guides/hotkeys-clipboard/#clipboard","text":"","title":"Clipboard"},{"location":"guides/hotkeys-clipboard/#writing-to-clipboard","text":"Set the clipboard content directly with a string assignment: app . clipboard = \"Hello, World!\" Or use the method form: app . set_clipboard ( \"Hello, World!\" ) Both are equivalent. The content is sent to the system clipboard immediately.","title":"Writing to clipboard"},{"location":"guides/hotkeys-clipboard/#reading-from-clipboard","text":"Clipboard reads are asynchronous because they require a round trip to the Swift runtime. Use get_clipboard() with a callback: def on_clipboard ( content : str ): print ( f \"Clipboard contains: { content } \" ) app . get_clipboard ( on_clipboard ) The callback receives the current clipboard text as a string.","title":"Reading from clipboard"},{"location":"guides/hotkeys-clipboard/#complete-example","text":"A clipboard manager app with hotkey integration: import nib def main ( app : nib . App ): app . title = \"Clippy\" app . icon = nib . SFSymbol ( \"doc.on.clipboard\" ) app . width = 320 app . height = 400 history = [] history_list = nib . VStack ( controls = [], spacing = 4 ) status = nib . Text ( \"Ready\" , foreground_color = nib . Color . GRAY , font = nib . Font . CAPTION ) def update_list (): items = [] for i , text in enumerate ( history [ - 10 :]): preview = text [: 50 ] + ( \"...\" if len ( text ) > 50 else \"\" ) def make_copy ( t = text ): app . clipboard = t status . content = \"Copied to clipboard\" items . append ( nib . Button ( content = nib . HStack ( controls = [ nib . Text ( preview , font = nib . Font . system ( 12 ), ), nib . Spacer (), ], spacing = 4 , ), action = make_copy , ) ) history_list . _children = items app . update () def capture_clipboard (): def on_read ( content : str ): if content and ( not history or history [ - 1 ] != content ): history . append ( content ) status . content = f \"Captured: { len ( history ) } items\" update_list () app . get_clipboard ( on_read ) def clear_history (): history . clear () history_list . _children = [] status . content = \"History cleared\" app . update () # Global hotkey to capture current clipboard app . on_hotkey ( \"cmd+shift+c\" , capture_clipboard ) app . menu = [ nib . MenuItem ( \"Capture Clipboard\" , action = capture_clipboard , shortcut = \"cmd+shift+c\" ), nib . MenuItem ( \"Clear History\" , action = clear_history ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit ), ] app . build ( nib . VStack ( controls = [ nib . HStack ( controls = [ nib . Text ( \"Clipboard History\" , font = nib . Font . HEADLINE ), nib . Spacer (), nib . Button ( \"Capture\" , action = capture_clipboard ), ], ), nib . Divider (), nib . ScrollView ( controls = [ history_list ], ), nib . Divider (), status , ], spacing = 8 , padding = 12 , ) ) nib . run ( main ) Press Cmd+Shift+C from anywhere to capture the current clipboard content into the history. Click any entry to copy it back to the clipboard. Tip Global hotkeys work even when the popover is closed. This makes them useful for system-wide actions like toggling visibility, capturing clipboard contents, or triggering background tasks.","title":"Complete example"},{"location":"guides/layouts/","text":"Nib provides a set of layout containers that mirror SwiftUI's layout system. Every container takes a controls list of child views and arranges them according to its rules. VStack -- Vertical Stacking \u00b6 VStack arranges children from top to bottom. Use spacing to control the gap between children and alignment to control horizontal positioning. import nib nib . VStack ( controls = [ nib . Text ( \"First\" ), nib . Text ( \"Second\" ), nib . Text ( \"Third\" ), ], spacing = 8 , alignment = nib . HorizontalAlignment . CENTER , ) Alignment options for VStack: Value Effect HorizontalAlignment.LEADING Align children to the left HorizontalAlignment.CENTER Center children (default) HorizontalAlignment.TRAILING Align children to the right A left-aligned card: nib . VStack ( controls = [ nib . Text ( \"Account\" , font = nib . Font . HEADLINE ), nib . Text ( \"user@example.com\" , foreground_color = nib . Color . SECONDARY ), ], spacing = 4 , alignment = nib . HorizontalAlignment . LEADING , padding = 16 , ) HStack -- Horizontal Stacking \u00b6 HStack arranges children from left to right. Use alignment to control vertical positioning within the row. nib . HStack ( controls = [ nib . SFSymbol ( \"star.fill\" , foreground_color = nib . Color . YELLOW ), nib . Text ( \"Favorites\" ), ], spacing = 8 , alignment = nib . VerticalAlignment . CENTER , ) Alignment options for HStack: Value Effect VerticalAlignment.TOP Align children to the top VerticalAlignment.CENTER Center children vertically (default) VerticalAlignment.BOTTOM Align children to the bottom A toolbar-style row with a centered title: nib . HStack ( controls = [ nib . Button ( \"Back\" , action = go_back ), nib . Spacer (), nib . Text ( \"Title\" , font = nib . Font . HEADLINE ), nib . Spacer (), nib . Button ( \"Done\" , action = finish ), ], spacing = 8 , padding = { \"horizontal\" : 16 , \"vertical\" : 8 }, ) ZStack -- Overlays \u00b6 ZStack layers children on top of each other. The first child is at the back, and each subsequent child is drawn on top. Use alignment to position children within the stack. nib . ZStack ( controls = [ nib . Rectangle ( corner_radius = 12 , fill = nib . Color . BLUE ), nib . Text ( \"Overlay Text\" , foreground_color = nib . Color . WHITE ), ], alignment = nib . Alignment . CENTER , ) Alignment options for ZStack: Value Position Alignment.TOP_LEADING Top-left corner Alignment.TOP Top center Alignment.TOP_TRAILING Top-right corner Alignment.LEADING Center-left Alignment.CENTER Dead center (default) Alignment.TRAILING Center-right Alignment.BOTTOM_LEADING Bottom-left corner Alignment.BOTTOM Bottom center Alignment.BOTTOM_TRAILING Bottom-right corner A notification badge over an icon: nib . ZStack ( controls = [ nib . SFSymbol ( \"bell.fill\" , font = nib . Font . TITLE ), nib . Text ( \"3\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE , background = nib . Circle ( fill = nib . Color . RED ), padding = 4 , ), ], alignment = nib . Alignment . TOP_TRAILING , ) Nesting Stacks \u00b6 Combine stacks to build complex layouts. This is the primary way to compose UI in Nib. import nib def main ( app : nib . App ): app . title = \"Contacts\" app . icon = nib . SFSymbol ( \"person.2\" ) app . width = 300 app . height = 400 app . build ( nib . VStack ( controls = [ # Header row nib . HStack ( controls = [ nib . Text ( \"Contacts\" , font = nib . Font . TITLE ), nib . Spacer (), nib . Button ( \"Add\" , action = lambda : None ), ], padding = { \"horizontal\" : 16 , \"top\" : 16 }, ), # Contact cards nib . VStack ( controls = [ _contact_row ( \"Alice\" , \"alice@example.com\" ), _contact_row ( \"Bob\" , \"bob@example.com\" ), _contact_row ( \"Charlie\" , \"charlie@example.com\" ), ], spacing = 8 , padding = 16 , ), ], ) ) def _contact_row ( name , email ): return nib . HStack ( controls = [ nib . SFSymbol ( \"person.circle.fill\" , foreground_color = nib . Color . BLUE ), nib . VStack ( controls = [ nib . Text ( name , font = nib . Font . HEADLINE ), nib . Text ( email , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), ], spacing = 10 , alignment = nib . VerticalAlignment . CENTER , ) nib . run ( main ) ScrollView \u00b6 ScrollView wraps content in a scrollable region. Set the axes parameter to control direction. nib . ScrollView ( controls = [ nib . VStack ( controls = [ nib . Text ( f \"Item { i } \" ) for i in range ( 50 )], spacing = 4 , ), ], axes = \"vertical\" , # \"vertical\" (default), \"horizontal\", or \"both\" shows_indicators = True , height = 300 , ) A horizontal image gallery: nib . ScrollView ( controls = [ nib . HStack ( controls = [ nib . Rectangle ( corner_radius = 8 , fill = nib . Color . BLUE , width = 120 , height = 80 ), nib . Rectangle ( corner_radius = 8 , fill = nib . Color . GREEN , width = 120 , height = 80 ), nib . Rectangle ( corner_radius = 8 , fill = nib . Color . ORANGE , width = 120 , height = 80 ), nib . Rectangle ( corner_radius = 8 , fill = nib . Color . PURPLE , width = 120 , height = 80 ), ], spacing = 8 , ), ], axes = \"horizontal\" , shows_indicators = False , ) Tip Wrap your scroll content inside a single VStack or HStack. ScrollView determines its scrollable area from the combined size of its children. List \u00b6 List displays rows in a native scrollable column with platform-standard styling (row separators, insets). Use it for settings screens, data tables, and any list-based UI. nib . List ( controls = [ nib . Text ( \"Apple\" ), nib . Text ( \"Banana\" ), nib . Text ( \"Cherry\" ), ], ) Each child is rendered as a separate row. You can use any view as a row: nib . List ( controls = [ nib . HStack ( controls = [ nib . SFSymbol ( \"person.circle\" ), nib . Text ( \"Alice\" ), nib . Spacer (), nib . Text ( \"Online\" , foreground_color = nib . Color . GREEN ), ], spacing = 8 , ), nib . HStack ( controls = [ nib . SFSymbol ( \"person.circle\" ), nib . Text ( \"Bob\" ), nib . Spacer (), nib . Text ( \"Offline\" , foreground_color = nib . Color . GRAY ), ], spacing = 8 , ), ], height = 200 , ) Section \u00b6 Section groups content within a List or Form , providing optional header and footer text. nib . List ( controls = [ nib . Section ( controls = [ nib . Text ( \"Apple\" ), nib . Text ( \"Banana\" ), ], header = \"Fruits\" , ), nib . Section ( controls = [ nib . Text ( \"Carrot\" ), nib . Text ( \"Broccoli\" ), ], header = \"Vegetables\" , footer = \"Eat your greens!\" , ), ], ) Note Section is designed for use inside List or Form. Outside these containers, it may not render with the expected visual grouping. Form \u00b6 Form is a container for data-entry controls. On macOS it defaults to a two-column layout with labels on the left and controls on the right. nib . Form ( controls = [ nib . Toggle ( \"Dark Mode\" , is_on = False ), nib . Picker ( \"Language\" , selection = \"English\" , options = [ \"English\" , \"Spanish\" , \"French\" ]), nib . TextField ( value = \"\" , placeholder = \"Username\" ), ], style = nib . FormStyle . COLUMNS , ) Form styles: Style Effect FormStyle.AUTOMATIC Platform default FormStyle.COLUMNS Two-column label/control layout (macOS default) FormStyle.GROUPED Grouped sections with visual separation A settings form with sections: nib . Form ( controls = [ nib . Section ( controls = [ nib . Toggle ( \"Push Notifications\" , is_on = True ), nib . Toggle ( \"Email Notifications\" , is_on = False ), ], header = \"Notifications\" , footer = \"Choose how you want to be notified.\" , ), nib . Section ( controls = [ nib . Picker ( \"Theme\" , selection = \"System\" , options = [ \"Light\" , \"Dark\" , \"System\" ]), nib . Slider ( \"Font Size\" , value = 14 , min_value = 10 , max_value = 24 ), ], header = \"Appearance\" , ), ], style = nib . FormStyle . GROUPED , ) Spacer \u00b6 Spacer is a flexible view that expands to fill available space in a stack. It is one of the most useful layout primitives. # Push \"Right\" to the trailing edge nib . HStack ( controls = [ nib . Text ( \"Left\" ), nib . Spacer (), nib . Text ( \"Right\" ), ], ) Use min_length to guarantee a minimum gap: nib . HStack ( controls = [ nib . Text ( \"A\" ), nib . Spacer ( min_length = 20 ), nib . Text ( \"B\" ), nib . Spacer ( min_length = 20 ), nib . Text ( \"C\" ), ], ) In a VStack, Spacer expands vertically. This pushes content to the top and bottom: nib . VStack ( controls = [ nib . Text ( \"Header\" , font = nib . Font . HEADLINE ), nib . Spacer (), nib . Text ( \"Footer\" , font = nib . Font . CAPTION ), ], height = 400 , ) Divider \u00b6 Divider draws a thin horizontal (in VStack) or vertical (in HStack) line to visually separate content. nib . VStack ( controls = [ nib . Text ( \"Section 1\" ), nib . Divider (), nib . Text ( \"Section 2\" ), ], spacing = 8 , ) Grid and GridRow \u00b6 Grid arranges views in a fixed two-dimensional grid with explicit rows. Each GridRow defines one row of cells. nib . Grid ( controls = [ nib . GridRow ( controls = [ nib . Text ( \"Name\" ), nib . Text ( \"Score\" )]), nib . GridRow ( controls = [ nib . Text ( \"Alice\" ), nib . Text ( \"95\" )]), nib . GridRow ( controls = [ nib . Text ( \"Bob\" ), nib . Text ( \"87\" )]), ], horizontal_spacing = 20 , vertical_spacing = 8 , ) Info Grid sizes all its children eagerly. For large data sets, use LazyVGrid or LazyHGrid instead. LazyVGrid \u00b6 LazyVGrid creates a vertically-scrolling grid. You define the column layout with GridItem specifications, and Nib fills columns left to right, wrapping into new rows. from nib import GridItem , GridItemSize nib . LazyVGrid ( columns = [ GridItem ( GridItemSize . FLEXIBLE ), GridItem ( GridItemSize . FLEXIBLE ), GridItem ( GridItemSize . FLEXIBLE ), ], controls = [ nib . Rectangle ( corner_radius = 8 , fill = nib . Color . BLUE , height = 60 ) for _ in range ( 9 ) ], spacing = 10 , ) GridItem sizing strategies \u00b6 Strategy Constructor Behavior Fixed GridItem(GridItemSize.FIXED, 100) Exactly 100 points wide Flexible GridItem(GridItemSize.FLEXIBLE, 50) At least 50pt, expands to fill Adaptive GridItem(GridItemSize.ADAPTIVE, 80) Fits as many 80pt+ columns as possible Convenience constructors are also available: from nib import fixed , flexible , adaptive # Three fixed 100pt columns nib . LazyVGrid ( columns = [ fixed ( 100 ), fixed ( 100 ), fixed ( 100 )], controls = [ ... ]) # As many columns as fit, each at least 80pt nib . LazyVGrid ( columns = [ adaptive ( 80 )], controls = [ ... ]) # Two flexible columns, minimum 50pt each nib . LazyVGrid ( columns = [ flexible ( 50 ), flexible ( 50 )], controls = [ ... ]) LazyHGrid \u00b6 LazyHGrid is the horizontal counterpart: you define rows and children flow horizontally, wrapping into new columns. nib . ScrollView ( controls = [ nib . LazyHGrid ( rows = [ GridItem ( GridItemSize . FIXED , 50 ), GridItem ( GridItemSize . FIXED , 50 ), ], controls = [ nib . Rectangle ( corner_radius = 4 , fill = nib . Color . GREEN , width = 80 ) for _ in range ( 12 ) ], spacing = 10 , ), ], axes = \"horizontal\" , ) Tip Wrap a LazyHGrid in a horizontal ScrollView so the content can scroll when it exceeds the visible width. Full Example \u00b6 A complete app demonstrating multiple layout techniques: import nib def main ( app : nib . App ): app . title = \"Layout Demo\" app . icon = nib . SFSymbol ( \"rectangle.3.group\" ) app . width = 320 app . height = 480 app . build ( nib . ScrollView ( controls = [ nib . VStack ( controls = [ # Header nib . HStack ( controls = [ nib . Text ( \"Dashboard\" , font = nib . Font . TITLE ), nib . Spacer (), nib . SFSymbol ( \"gear\" , foreground_color = nib . Color . SECONDARY ), ], ), nib . Divider (), # Stats grid nib . LazyVGrid ( columns = [ nib . GridItem ( nib . GridItemSize . FLEXIBLE ), nib . GridItem ( nib . GridItemSize . FLEXIBLE )], controls = [ _stat_card ( \"Downloads\" , \"1,234\" , nib . Color . BLUE ), _stat_card ( \"Users\" , \"567\" , nib . Color . GREEN ), _stat_card ( \"Revenue\" , \"$8.9k\" , nib . Color . ORANGE ), _stat_card ( \"Rating\" , \"4.8\" , nib . Color . PURPLE ), ], spacing = 8 , ), # Recent items nib . List ( controls = [ nib . Section ( controls = [ nib . Text ( \"v2.1 released\" ), nib . Text ( \"Bug fix deployed\" ), nib . Text ( \"New feature added\" ), ], header = \"Recent Activity\" , ), ], height = 200 , ), ], spacing = 12 , padding = 16 , ), ], ) ) def _stat_card ( title , value , color ): return nib . VStack ( controls = [ nib . Text ( value , font = nib . Font . TITLE , foreground_color = color ), nib . Text ( title , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], spacing = 4 , padding = 12 , background = nib . Rectangle ( corner_radius = 8 , fill = nib . Color ( hex = \"#1a1a1a\" )), ) nib . run ( main )","title":"Building Layouts"},{"location":"guides/layouts/#vstack-vertical-stacking","text":"VStack arranges children from top to bottom. Use spacing to control the gap between children and alignment to control horizontal positioning. import nib nib . VStack ( controls = [ nib . Text ( \"First\" ), nib . Text ( \"Second\" ), nib . Text ( \"Third\" ), ], spacing = 8 , alignment = nib . HorizontalAlignment . CENTER , ) Alignment options for VStack: Value Effect HorizontalAlignment.LEADING Align children to the left HorizontalAlignment.CENTER Center children (default) HorizontalAlignment.TRAILING Align children to the right A left-aligned card: nib . VStack ( controls = [ nib . Text ( \"Account\" , font = nib . Font . HEADLINE ), nib . Text ( \"user@example.com\" , foreground_color = nib . Color . SECONDARY ), ], spacing = 4 , alignment = nib . HorizontalAlignment . LEADING , padding = 16 , )","title":"VStack -- Vertical Stacking"},{"location":"guides/layouts/#hstack-horizontal-stacking","text":"HStack arranges children from left to right. Use alignment to control vertical positioning within the row. nib . HStack ( controls = [ nib . SFSymbol ( \"star.fill\" , foreground_color = nib . Color . YELLOW ), nib . Text ( \"Favorites\" ), ], spacing = 8 , alignment = nib . VerticalAlignment . CENTER , ) Alignment options for HStack: Value Effect VerticalAlignment.TOP Align children to the top VerticalAlignment.CENTER Center children vertically (default) VerticalAlignment.BOTTOM Align children to the bottom A toolbar-style row with a centered title: nib . HStack ( controls = [ nib . Button ( \"Back\" , action = go_back ), nib . Spacer (), nib . Text ( \"Title\" , font = nib . Font . HEADLINE ), nib . Spacer (), nib . Button ( \"Done\" , action = finish ), ], spacing = 8 , padding = { \"horizontal\" : 16 , \"vertical\" : 8 }, )","title":"HStack -- Horizontal Stacking"},{"location":"guides/layouts/#zstack-overlays","text":"ZStack layers children on top of each other. The first child is at the back, and each subsequent child is drawn on top. Use alignment to position children within the stack. nib . ZStack ( controls = [ nib . Rectangle ( corner_radius = 12 , fill = nib . Color . BLUE ), nib . Text ( \"Overlay Text\" , foreground_color = nib . Color . WHITE ), ], alignment = nib . Alignment . CENTER , ) Alignment options for ZStack: Value Position Alignment.TOP_LEADING Top-left corner Alignment.TOP Top center Alignment.TOP_TRAILING Top-right corner Alignment.LEADING Center-left Alignment.CENTER Dead center (default) Alignment.TRAILING Center-right Alignment.BOTTOM_LEADING Bottom-left corner Alignment.BOTTOM Bottom center Alignment.BOTTOM_TRAILING Bottom-right corner A notification badge over an icon: nib . ZStack ( controls = [ nib . SFSymbol ( \"bell.fill\" , font = nib . Font . TITLE ), nib . Text ( \"3\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE , background = nib . Circle ( fill = nib . Color . RED ), padding = 4 , ), ], alignment = nib . Alignment . TOP_TRAILING , )","title":"ZStack -- Overlays"},{"location":"guides/layouts/#nesting-stacks","text":"Combine stacks to build complex layouts. This is the primary way to compose UI in Nib. import nib def main ( app : nib . App ): app . title = \"Contacts\" app . icon = nib . SFSymbol ( \"person.2\" ) app . width = 300 app . height = 400 app . build ( nib . VStack ( controls = [ # Header row nib . HStack ( controls = [ nib . Text ( \"Contacts\" , font = nib . Font . TITLE ), nib . Spacer (), nib . Button ( \"Add\" , action = lambda : None ), ], padding = { \"horizontal\" : 16 , \"top\" : 16 }, ), # Contact cards nib . VStack ( controls = [ _contact_row ( \"Alice\" , \"alice@example.com\" ), _contact_row ( \"Bob\" , \"bob@example.com\" ), _contact_row ( \"Charlie\" , \"charlie@example.com\" ), ], spacing = 8 , padding = 16 , ), ], ) ) def _contact_row ( name , email ): return nib . HStack ( controls = [ nib . SFSymbol ( \"person.circle.fill\" , foreground_color = nib . Color . BLUE ), nib . VStack ( controls = [ nib . Text ( name , font = nib . Font . HEADLINE ), nib . Text ( email , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), ], spacing = 10 , alignment = nib . VerticalAlignment . CENTER , ) nib . run ( main )","title":"Nesting Stacks"},{"location":"guides/layouts/#scrollview","text":"ScrollView wraps content in a scrollable region. Set the axes parameter to control direction. nib . ScrollView ( controls = [ nib . VStack ( controls = [ nib . Text ( f \"Item { i } \" ) for i in range ( 50 )], spacing = 4 , ), ], axes = \"vertical\" , # \"vertical\" (default), \"horizontal\", or \"both\" shows_indicators = True , height = 300 , ) A horizontal image gallery: nib . ScrollView ( controls = [ nib . HStack ( controls = [ nib . Rectangle ( corner_radius = 8 , fill = nib . Color . BLUE , width = 120 , height = 80 ), nib . Rectangle ( corner_radius = 8 , fill = nib . Color . GREEN , width = 120 , height = 80 ), nib . Rectangle ( corner_radius = 8 , fill = nib . Color . ORANGE , width = 120 , height = 80 ), nib . Rectangle ( corner_radius = 8 , fill = nib . Color . PURPLE , width = 120 , height = 80 ), ], spacing = 8 , ), ], axes = \"horizontal\" , shows_indicators = False , ) Tip Wrap your scroll content inside a single VStack or HStack. ScrollView determines its scrollable area from the combined size of its children.","title":"ScrollView"},{"location":"guides/layouts/#list","text":"List displays rows in a native scrollable column with platform-standard styling (row separators, insets). Use it for settings screens, data tables, and any list-based UI. nib . List ( controls = [ nib . Text ( \"Apple\" ), nib . Text ( \"Banana\" ), nib . Text ( \"Cherry\" ), ], ) Each child is rendered as a separate row. You can use any view as a row: nib . List ( controls = [ nib . HStack ( controls = [ nib . SFSymbol ( \"person.circle\" ), nib . Text ( \"Alice\" ), nib . Spacer (), nib . Text ( \"Online\" , foreground_color = nib . Color . GREEN ), ], spacing = 8 , ), nib . HStack ( controls = [ nib . SFSymbol ( \"person.circle\" ), nib . Text ( \"Bob\" ), nib . Spacer (), nib . Text ( \"Offline\" , foreground_color = nib . Color . GRAY ), ], spacing = 8 , ), ], height = 200 , )","title":"List"},{"location":"guides/layouts/#section","text":"Section groups content within a List or Form , providing optional header and footer text. nib . List ( controls = [ nib . Section ( controls = [ nib . Text ( \"Apple\" ), nib . Text ( \"Banana\" ), ], header = \"Fruits\" , ), nib . Section ( controls = [ nib . Text ( \"Carrot\" ), nib . Text ( \"Broccoli\" ), ], header = \"Vegetables\" , footer = \"Eat your greens!\" , ), ], ) Note Section is designed for use inside List or Form. Outside these containers, it may not render with the expected visual grouping.","title":"Section"},{"location":"guides/layouts/#form","text":"Form is a container for data-entry controls. On macOS it defaults to a two-column layout with labels on the left and controls on the right. nib . Form ( controls = [ nib . Toggle ( \"Dark Mode\" , is_on = False ), nib . Picker ( \"Language\" , selection = \"English\" , options = [ \"English\" , \"Spanish\" , \"French\" ]), nib . TextField ( value = \"\" , placeholder = \"Username\" ), ], style = nib . FormStyle . COLUMNS , ) Form styles: Style Effect FormStyle.AUTOMATIC Platform default FormStyle.COLUMNS Two-column label/control layout (macOS default) FormStyle.GROUPED Grouped sections with visual separation A settings form with sections: nib . Form ( controls = [ nib . Section ( controls = [ nib . Toggle ( \"Push Notifications\" , is_on = True ), nib . Toggle ( \"Email Notifications\" , is_on = False ), ], header = \"Notifications\" , footer = \"Choose how you want to be notified.\" , ), nib . Section ( controls = [ nib . Picker ( \"Theme\" , selection = \"System\" , options = [ \"Light\" , \"Dark\" , \"System\" ]), nib . Slider ( \"Font Size\" , value = 14 , min_value = 10 , max_value = 24 ), ], header = \"Appearance\" , ), ], style = nib . FormStyle . GROUPED , )","title":"Form"},{"location":"guides/layouts/#spacer","text":"Spacer is a flexible view that expands to fill available space in a stack. It is one of the most useful layout primitives. # Push \"Right\" to the trailing edge nib . HStack ( controls = [ nib . Text ( \"Left\" ), nib . Spacer (), nib . Text ( \"Right\" ), ], ) Use min_length to guarantee a minimum gap: nib . HStack ( controls = [ nib . Text ( \"A\" ), nib . Spacer ( min_length = 20 ), nib . Text ( \"B\" ), nib . Spacer ( min_length = 20 ), nib . Text ( \"C\" ), ], ) In a VStack, Spacer expands vertically. This pushes content to the top and bottom: nib . VStack ( controls = [ nib . Text ( \"Header\" , font = nib . Font . HEADLINE ), nib . Spacer (), nib . Text ( \"Footer\" , font = nib . Font . CAPTION ), ], height = 400 , )","title":"Spacer"},{"location":"guides/layouts/#divider","text":"Divider draws a thin horizontal (in VStack) or vertical (in HStack) line to visually separate content. nib . VStack ( controls = [ nib . Text ( \"Section 1\" ), nib . Divider (), nib . Text ( \"Section 2\" ), ], spacing = 8 , )","title":"Divider"},{"location":"guides/layouts/#grid-and-gridrow","text":"Grid arranges views in a fixed two-dimensional grid with explicit rows. Each GridRow defines one row of cells. nib . Grid ( controls = [ nib . GridRow ( controls = [ nib . Text ( \"Name\" ), nib . Text ( \"Score\" )]), nib . GridRow ( controls = [ nib . Text ( \"Alice\" ), nib . Text ( \"95\" )]), nib . GridRow ( controls = [ nib . Text ( \"Bob\" ), nib . Text ( \"87\" )]), ], horizontal_spacing = 20 , vertical_spacing = 8 , ) Info Grid sizes all its children eagerly. For large data sets, use LazyVGrid or LazyHGrid instead.","title":"Grid and GridRow"},{"location":"guides/layouts/#lazyvgrid","text":"LazyVGrid creates a vertically-scrolling grid. You define the column layout with GridItem specifications, and Nib fills columns left to right, wrapping into new rows. from nib import GridItem , GridItemSize nib . LazyVGrid ( columns = [ GridItem ( GridItemSize . FLEXIBLE ), GridItem ( GridItemSize . FLEXIBLE ), GridItem ( GridItemSize . FLEXIBLE ), ], controls = [ nib . Rectangle ( corner_radius = 8 , fill = nib . Color . BLUE , height = 60 ) for _ in range ( 9 ) ], spacing = 10 , )","title":"LazyVGrid"},{"location":"guides/layouts/#griditem-sizing-strategies","text":"Strategy Constructor Behavior Fixed GridItem(GridItemSize.FIXED, 100) Exactly 100 points wide Flexible GridItem(GridItemSize.FLEXIBLE, 50) At least 50pt, expands to fill Adaptive GridItem(GridItemSize.ADAPTIVE, 80) Fits as many 80pt+ columns as possible Convenience constructors are also available: from nib import fixed , flexible , adaptive # Three fixed 100pt columns nib . LazyVGrid ( columns = [ fixed ( 100 ), fixed ( 100 ), fixed ( 100 )], controls = [ ... ]) # As many columns as fit, each at least 80pt nib . LazyVGrid ( columns = [ adaptive ( 80 )], controls = [ ... ]) # Two flexible columns, minimum 50pt each nib . LazyVGrid ( columns = [ flexible ( 50 ), flexible ( 50 )], controls = [ ... ])","title":"GridItem sizing strategies"},{"location":"guides/layouts/#lazyhgrid","text":"LazyHGrid is the horizontal counterpart: you define rows and children flow horizontally, wrapping into new columns. nib . ScrollView ( controls = [ nib . LazyHGrid ( rows = [ GridItem ( GridItemSize . FIXED , 50 ), GridItem ( GridItemSize . FIXED , 50 ), ], controls = [ nib . Rectangle ( corner_radius = 4 , fill = nib . Color . GREEN , width = 80 ) for _ in range ( 12 ) ], spacing = 10 , ), ], axes = \"horizontal\" , ) Tip Wrap a LazyHGrid in a horizontal ScrollView so the content can scroll when it exceeds the visible width.","title":"LazyHGrid"},{"location":"guides/layouts/#full-example","text":"A complete app demonstrating multiple layout techniques: import nib def main ( app : nib . App ): app . title = \"Layout Demo\" app . icon = nib . SFSymbol ( \"rectangle.3.group\" ) app . width = 320 app . height = 480 app . build ( nib . ScrollView ( controls = [ nib . VStack ( controls = [ # Header nib . HStack ( controls = [ nib . Text ( \"Dashboard\" , font = nib . Font . TITLE ), nib . Spacer (), nib . SFSymbol ( \"gear\" , foreground_color = nib . Color . SECONDARY ), ], ), nib . Divider (), # Stats grid nib . LazyVGrid ( columns = [ nib . GridItem ( nib . GridItemSize . FLEXIBLE ), nib . GridItem ( nib . GridItemSize . FLEXIBLE )], controls = [ _stat_card ( \"Downloads\" , \"1,234\" , nib . Color . BLUE ), _stat_card ( \"Users\" , \"567\" , nib . Color . GREEN ), _stat_card ( \"Revenue\" , \"$8.9k\" , nib . Color . ORANGE ), _stat_card ( \"Rating\" , \"4.8\" , nib . Color . PURPLE ), ], spacing = 8 , ), # Recent items nib . List ( controls = [ nib . Section ( controls = [ nib . Text ( \"v2.1 released\" ), nib . Text ( \"Bug fix deployed\" ), nib . Text ( \"New feature added\" ), ], header = \"Recent Activity\" , ), ], height = 200 , ), ], spacing = 12 , padding = 16 , ), ], ) ) def _stat_card ( title , value , color ): return nib . VStack ( controls = [ nib . Text ( value , font = nib . Font . TITLE , foreground_color = color ), nib . Text ( title , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], spacing = 4 , padding = 12 , background = nib . Rectangle ( corner_radius = 8 , fill = nib . Color ( hex = \"#1a1a1a\" )), ) nib . run ( main )","title":"Full Example"},{"location":"guides/navigation/","text":"Nib provides SwiftUI-style navigation components for building hierarchical, drill-down interfaces. Use NavigationStack as the container, NavigationLink for push navigation, and DisclosureGroup for collapsible sections. NavigationStack \u00b6 NavigationStack is a container that manages a stack of views. It provides the context needed for NavigationLink to push destination views: import nib nib . NavigationStack ( controls = [ nib . Text ( \"Root View\" ), nib . NavigationLink ( \"Go to Details\" , destination = [ nib . Text ( \"Detail View\" ), ]), ], ) When a user taps a NavigationLink , the destination views replace the current content with an animated transition. A back button appears automatically to return to the previous view. Parameter Type Description controls list[View] Root content views displayed initially Standard view modifiers are also supported. NavigationLink \u00b6 NavigationLink creates a tappable row that navigates to a destination view when tapped. It automatically displays a disclosure chevron: nib . NavigationLink ( label = \"Profile Settings\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Profile\" , font = nib . Font . TITLE ), nib . TextField ( value = \"\" , placeholder = \"Display Name\" ), nib . Toggle ( \"Show Online Status\" , is_on = True ), ], spacing = 12 , padding = 16 , ), ], ) Parameter Type Description label str Text displayed as the tappable element destination list[View] Views to display when navigated to Note NavigationLink must be placed inside a NavigationStack for navigation to work. Without the surrounding stack, tapping the link has no effect. Building a settings-style navigation \u00b6 The most common pattern is a NavigationStack containing a List of NavigationLink elements, similar to the macOS System Settings app: import nib def main ( app : nib . App ): app . title = \"Preferences\" app . icon = nib . SFSymbol ( \"gear\" ) app . width = 350 app . height = 400 app . build ( nib . NavigationStack ( controls = [ nib . List ( controls = [ nib . Section ( header = \"Account\" , controls = [ nib . NavigationLink ( label = \"Profile\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Profile\" , font = nib . Font . TITLE ), nib . TextField ( value = \"\" , placeholder = \"Username\" , ), nib . TextField ( value = \"\" , placeholder = \"Email\" , ), ], spacing = 12 , padding = 16 , ), ], ), nib . NavigationLink ( label = \"Security\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Security\" , font = nib . Font . TITLE ), nib . Toggle ( \"Two-Factor Auth\" , is_on = False ), nib . Toggle ( \"Biometric Login\" , is_on = True ), ], spacing = 12 , padding = 16 , ), ], ), ], ), nib . Section ( header = \"Appearance\" , controls = [ nib . NavigationLink ( label = \"Theme\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Theme\" , font = nib . Font . TITLE ), nib . Picker ( items = [ \"System\" , \"Light\" , \"Dark\" ], selected = \"System\" , ), nib . Slider ( value = 14 , min_value = 10 , max_value = 24 , label = \"Font Size\" , ), ], spacing = 12 , padding = 16 , ), ], ), ], ), ], ), ], ) ) nib . run ( main ) DisclosureGroup \u00b6 DisclosureGroup creates a collapsible section that the user can expand or collapse by clicking the header. This is useful for progressive disclosure of optional or advanced content: nib . DisclosureGroup ( label = \"Advanced Options\" , controls = [ nib . Toggle ( \"Enable Logging\" , is_on = False ), nib . Toggle ( \"Developer Mode\" , is_on = False ), nib . Slider ( value = 50 , min_value = 0 , max_value = 100 , label = \"Cache Size\" ), ], ) Parameter Type Default Description label str -- Text label for the header controls list[View] [] Child views shown when expanded is_expanded bool False Initial expansion state on_expand Callable[[bool], None] None Callback when state changes Initially expanded \u00b6 nib . DisclosureGroup ( label = \"Quick Settings\" , controls = [ nib . Toggle ( \"Wi-Fi\" , is_on = True ), nib . Toggle ( \"Bluetooth\" , is_on = True ), ], is_expanded = True , ) Tracking expansion state \u00b6 def on_expand ( expanded : bool ): print ( f \"Section is now { 'open' if expanded else 'closed' } \" ) nib . DisclosureGroup ( label = \"Details\" , controls = [ nib . Text ( \"Hidden content\" )], on_expand = on_expand , ) Combining navigation and disclosure \u00b6 You can nest DisclosureGroup inside a NavigationStack to create interfaces with both drill-down navigation and collapsible sections: import nib def main ( app : nib . App ): app . title = \"Config\" app . icon = nib . SFSymbol ( \"slider.horizontal.3\" ) app . width = 350 app . height = 450 app . build ( nib . NavigationStack ( controls = [ nib . ScrollView ( controls = [ nib . VStack ( controls = [ nib . NavigationLink ( label = \"Network\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Network\" , font = nib . Font . TITLE ), nib . Toggle ( \"Auto Connect\" , is_on = True ), nib . DisclosureGroup ( label = \"Proxy Settings\" , controls = [ nib . TextField ( value = \"\" , placeholder = \"Host\" , ), nib . TextField ( value = \"\" , placeholder = \"Port\" , ), ], ), nib . DisclosureGroup ( label = \"DNS Settings\" , controls = [ nib . TextField ( value = \"\" , placeholder = \"Primary DNS\" , ), nib . TextField ( value = \"\" , placeholder = \"Secondary DNS\" , ), ], ), ], spacing = 12 , padding = 16 , ), ], ), nib . NavigationLink ( label = \"Storage\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Storage\" , font = nib . Font . TITLE ), nib . ProgressView ( value = 0.65 , label = \"Disk Usage\" , ), nib . Button ( \"Clear Cache\" ), ], spacing = 12 , padding = 16 , ), ], ), ], spacing = 4 , padding = 8 , ), ], ), ], ) ) nib . run ( main ) Tip DisclosureGroup is a good alternative to NavigationLink when the content is short and does not warrant a full screen transition. Use navigation for complex sub-pages and disclosure groups for inline expandable sections.","title":"Navigation"},{"location":"guides/navigation/#navigationstack","text":"NavigationStack is a container that manages a stack of views. It provides the context needed for NavigationLink to push destination views: import nib nib . NavigationStack ( controls = [ nib . Text ( \"Root View\" ), nib . NavigationLink ( \"Go to Details\" , destination = [ nib . Text ( \"Detail View\" ), ]), ], ) When a user taps a NavigationLink , the destination views replace the current content with an animated transition. A back button appears automatically to return to the previous view. Parameter Type Description controls list[View] Root content views displayed initially Standard view modifiers are also supported.","title":"NavigationStack"},{"location":"guides/navigation/#navigationlink","text":"NavigationLink creates a tappable row that navigates to a destination view when tapped. It automatically displays a disclosure chevron: nib . NavigationLink ( label = \"Profile Settings\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Profile\" , font = nib . Font . TITLE ), nib . TextField ( value = \"\" , placeholder = \"Display Name\" ), nib . Toggle ( \"Show Online Status\" , is_on = True ), ], spacing = 12 , padding = 16 , ), ], ) Parameter Type Description label str Text displayed as the tappable element destination list[View] Views to display when navigated to Note NavigationLink must be placed inside a NavigationStack for navigation to work. Without the surrounding stack, tapping the link has no effect.","title":"NavigationLink"},{"location":"guides/navigation/#building-a-settings-style-navigation","text":"The most common pattern is a NavigationStack containing a List of NavigationLink elements, similar to the macOS System Settings app: import nib def main ( app : nib . App ): app . title = \"Preferences\" app . icon = nib . SFSymbol ( \"gear\" ) app . width = 350 app . height = 400 app . build ( nib . NavigationStack ( controls = [ nib . List ( controls = [ nib . Section ( header = \"Account\" , controls = [ nib . NavigationLink ( label = \"Profile\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Profile\" , font = nib . Font . TITLE ), nib . TextField ( value = \"\" , placeholder = \"Username\" , ), nib . TextField ( value = \"\" , placeholder = \"Email\" , ), ], spacing = 12 , padding = 16 , ), ], ), nib . NavigationLink ( label = \"Security\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Security\" , font = nib . Font . TITLE ), nib . Toggle ( \"Two-Factor Auth\" , is_on = False ), nib . Toggle ( \"Biometric Login\" , is_on = True ), ], spacing = 12 , padding = 16 , ), ], ), ], ), nib . Section ( header = \"Appearance\" , controls = [ nib . NavigationLink ( label = \"Theme\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Theme\" , font = nib . Font . TITLE ), nib . Picker ( items = [ \"System\" , \"Light\" , \"Dark\" ], selected = \"System\" , ), nib . Slider ( value = 14 , min_value = 10 , max_value = 24 , label = \"Font Size\" , ), ], spacing = 12 , padding = 16 , ), ], ), ], ), ], ), ], ) ) nib . run ( main )","title":"Building a settings-style navigation"},{"location":"guides/navigation/#disclosuregroup","text":"DisclosureGroup creates a collapsible section that the user can expand or collapse by clicking the header. This is useful for progressive disclosure of optional or advanced content: nib . DisclosureGroup ( label = \"Advanced Options\" , controls = [ nib . Toggle ( \"Enable Logging\" , is_on = False ), nib . Toggle ( \"Developer Mode\" , is_on = False ), nib . Slider ( value = 50 , min_value = 0 , max_value = 100 , label = \"Cache Size\" ), ], ) Parameter Type Default Description label str -- Text label for the header controls list[View] [] Child views shown when expanded is_expanded bool False Initial expansion state on_expand Callable[[bool], None] None Callback when state changes","title":"DisclosureGroup"},{"location":"guides/navigation/#initially-expanded","text":"nib . DisclosureGroup ( label = \"Quick Settings\" , controls = [ nib . Toggle ( \"Wi-Fi\" , is_on = True ), nib . Toggle ( \"Bluetooth\" , is_on = True ), ], is_expanded = True , )","title":"Initially expanded"},{"location":"guides/navigation/#tracking-expansion-state","text":"def on_expand ( expanded : bool ): print ( f \"Section is now { 'open' if expanded else 'closed' } \" ) nib . DisclosureGroup ( label = \"Details\" , controls = [ nib . Text ( \"Hidden content\" )], on_expand = on_expand , )","title":"Tracking expansion state"},{"location":"guides/navigation/#combining-navigation-and-disclosure","text":"You can nest DisclosureGroup inside a NavigationStack to create interfaces with both drill-down navigation and collapsible sections: import nib def main ( app : nib . App ): app . title = \"Config\" app . icon = nib . SFSymbol ( \"slider.horizontal.3\" ) app . width = 350 app . height = 450 app . build ( nib . NavigationStack ( controls = [ nib . ScrollView ( controls = [ nib . VStack ( controls = [ nib . NavigationLink ( label = \"Network\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Network\" , font = nib . Font . TITLE ), nib . Toggle ( \"Auto Connect\" , is_on = True ), nib . DisclosureGroup ( label = \"Proxy Settings\" , controls = [ nib . TextField ( value = \"\" , placeholder = \"Host\" , ), nib . TextField ( value = \"\" , placeholder = \"Port\" , ), ], ), nib . DisclosureGroup ( label = \"DNS Settings\" , controls = [ nib . TextField ( value = \"\" , placeholder = \"Primary DNS\" , ), nib . TextField ( value = \"\" , placeholder = \"Secondary DNS\" , ), ], ), ], spacing = 12 , padding = 16 , ), ], ), nib . NavigationLink ( label = \"Storage\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Storage\" , font = nib . Font . TITLE ), nib . ProgressView ( value = 0.65 , label = \"Disk Usage\" , ), nib . Button ( \"Clear Cache\" ), ], spacing = 12 , padding = 16 , ), ], ), ], spacing = 4 , padding = 8 , ), ], ), ], ) ) nib . run ( main ) Tip DisclosureGroup is a good alternative to NavigationLink when the content is short and does not warrant a full screen transition. Use navigation for complex sub-pages and disclosure groups for inline expandable sections.","title":"Combining navigation and disclosure"},{"location":"guides/notifications/","text":"Nib provides full access to macOS system notifications, including instant push, scheduled delivery, custom sounds, action buttons, and text input. Quick Notification \u00b6 The simplest way to send a notification is app.notify() : import nib def main ( app : nib . App ): app . title = \"Notify\" app . icon = nib . SFSymbol ( \"bell\" ) app . width = 200 app . height = 100 app . build ( nib . Button ( \"Send Notification\" , action = lambda : app . notify ( \"Hello!\" , \"World\" )) ) nib . run ( main ) app.notify() parameters \u00b6 Parameter Type Default Description title str required Main notification title body str None Body text subtitle str None Secondary line below the title sound bool True Play the default notification sound identifier str None Unique ID (for updating or canceling) app . notify ( \"Download Complete\" , body = \"report.pdf has been saved to Downloads\" , subtitle = \"File Manager\" , sound = True , ) Requesting Permission \u00b6 macOS requires user permission before delivering notifications. Request it early: def on_permission ( granted ): if granted : print ( \"Notifications enabled\" ) else : print ( \"Notifications denied\" ) app . notifications . request_permission ( callback = on_permission ) Note The first call shows the system permission dialog. Subsequent calls return the cached result. If the user denied permission, they must re-enable it in System Settings. Notification Objects \u00b6 For full control, create Notification objects and push them through the notification manager: from nib import Notification notification = Notification ( title = \"New Message\" , body = \"You have a new message from Alice\" , subtitle = \"Messages\" , ) app . notifications . push ( notification ) Custom sounds \u00b6 Use NotificationSound to configure the notification sound: from nib import Notification , NotificationSound , NotificationSoundName # Default sound notification = Notification ( title = \"Alert\" , body = \"Something happened\" , sound = NotificationSound ( name = NotificationSoundName . DEFAULT ), ) # Built-in macOS sound by name notification = Notification ( title = \"Alert\" , body = \"Something happened\" , sound = NotificationSound ( name = NotificationSoundName . custom ( \"Glass\" )), ) # Other built-in sounds: \"Frog\", \"Ping\", \"Pop\", \"Purr\", \"Sosumi\", \"Tink\" Scheduling Notifications \u00b6 Schedule at a specific time \u00b6 from datetime import datetime , timedelta from nib import Notification reminder = Notification ( title = \"Break Time\" , body = \"You have been working for 2 hours. Take a break!\" , ) # Schedule for 1 hour from now notification_id = app . notifications . schedule ( reminder , at = datetime . now () + timedelta ( hours = 1 ), ) Schedule daily recurring \u00b6 from nib import Notification daily_reminder = Notification ( title = \"Daily Standup\" , body = \"Time for the morning standup meeting\" , ) # Every day at 9:00 AM app . notifications . schedule_daily ( daily_reminder , from_time = \"09:00\" , ) # Multiple times per day between 8 AM and 6 PM app . notifications . schedule_daily ( daily_reminder , from_time = \"08:00\" , to_time = \"18:00\" , count = 3 , ) # Daily for one week from datetime import date , timedelta app . notifications . schedule_daily ( daily_reminder , from_time = \"09:00\" , from_date = date . today (), to_date = date . today () + timedelta ( days = 7 ), ) Reschedule \u00b6 Cancel and reschedule an existing notification: app . notifications . reschedule ( reminder , at = datetime . now () + timedelta ( hours = 2 ), ) Notification Actions \u00b6 Actions appear as buttons on the notification. Users can tap them to trigger callbacks without opening the app. from nib import Notification , NotificationAction , TextInputNotificationAction notification = Notification ( title = \"New Message\" , body = \"Alice: Hey, are you free for lunch?\" , actions = [ NotificationAction ( id = \"reply\" , title = \"Reply\" , text_input = TextInputNotificationAction ( button_title = \"Send\" , placeholder = \"Type your reply...\" , ), ), NotificationAction ( id = \"mark_read\" , title = \"Mark as Read\" , ), ], ) app . notifications . push ( notification ) Handling action callbacks \u00b6 Register a handler to receive action events: def handle_action ( notification_id , action_id , user_text ): if action_id == \"reply\" and user_text : print ( f \"User replied: { user_text } \" ) elif action_id == \"mark_read\" : print ( \"Marked as read\" ) unsubscribe = app . notifications . on_action ( handle_action ) # Later, to stop receiving callbacks: # unsubscribe() The callback receives three arguments: Argument Type Description notification_id str ID of the notification that was acted on action_id str ID of the action button that was tapped user_text str or None Text entered if the action has text_input Action options \u00b6 from nib import NotificationAction , NotificationActionOption NotificationAction ( id = \"delete\" , title = \"Delete\" , options = [ NotificationActionOption . DESTRUCTIVE , # Red button NotificationActionOption . AUTHENTICATION_REQUIRED , # Requires unlock ], ) NotificationAction ( id = \"open\" , title = \"Open App\" , options = [ NotificationActionOption . FOREGROUND ], # Brings app to front ) Canceling Notifications \u00b6 # Cancel a specific notification by ID app . notifications . cancel_notification ( notification_id ) # Cancel all scheduled and delivered notifications app . notifications . cancel_all_notifications () Querying Notifications \u00b6 Retrieve notifications that are currently scheduled or displayed in Notification Center: # Get all scheduled (pending) notifications def on_scheduled ( notifications ): for n in notifications : print ( f \"Scheduled: { n . title } (id: { n . id } )\" ) app . notifications . get_all_scheduled_notifications ( on_scheduled ) # Get all delivered (visible in Notification Center) notifications def on_delivered ( notifications ): print ( f \" { len ( notifications ) } notifications showing\" ) app . notifications . get_all_delivered_notifications ( on_delivered ) # Get a specific notification by ID app . notifications . get_scheduled_notification ( \"some-id\" , callback = lambda n : print ( f \"Found: { n . title } \" ) if n else print ( \"Not found\" ), ) Full Example \u00b6 A complete notification demo app: import nib from datetime import datetime , timedelta from nib import Notification , NotificationAction , NotificationSound , NotificationSoundName , TextInputNotificationAction def main ( app : nib . App ): app . title = \"Notifications\" app . icon = nib . SFSymbol ( \"bell.badge\" ) app . width = 300 app . height = 350 # Request permission on startup app . notifications . request_permission () # Handle action callbacks response_label = nib . Text ( \"No response yet\" , foreground_color = nib . Color . SECONDARY , font = nib . Font . CAPTION ) def on_action ( notif_id , action_id , user_text ): if action_id == \"reply\" and user_text : response_label . content = f \"Reply: { user_text } \" elif action_id == \"dismiss\" : response_label . content = \"Dismissed\" app . notifications . on_action ( on_action ) def send_simple (): app . notify ( \"Hello!\" , body = \"This is a simple notification.\" ) def send_with_actions (): notification = Notification ( title = \"Message from Alice\" , body = \"Want to grab coffee?\" , sound = NotificationSound ( name = NotificationSoundName . custom ( \"Glass\" )), actions = [ NotificationAction ( id = \"reply\" , title = \"Reply\" , text_input = TextInputNotificationAction ( button_title = \"Send\" , placeholder = \"Type reply...\" , ), ), NotificationAction ( id = \"dismiss\" , title = \"Dismiss\" ), ], ) app . notifications . push ( notification ) def schedule_reminder (): reminder = Notification ( title = \"Reminder\" , body = \"This was scheduled 10 seconds ago.\" , ) app . notifications . schedule ( reminder , at = datetime . now () + timedelta ( seconds = 10 )) response_label . content = \"Reminder scheduled in 10s\" def cancel_all (): app . notifications . cancel_all_notifications () response_label . content = \"All notifications canceled\" app . build ( nib . VStack ( controls = [ nib . Text ( \"Notification Demo\" , font = nib . Font . HEADLINE ), nib . Divider (), nib . Button ( \"Simple Notification\" , action = send_simple ), nib . Button ( \"With Actions\" , action = send_with_actions ), nib . Button ( \"Schedule (10s)\" , action = schedule_reminder ), nib . Button ( \"Cancel All\" , action = cancel_all ), nib . Divider (), nib . Text ( \"Last response:\" , font = nib . Font . CAPTION ), response_label , ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Notifications"},{"location":"guides/notifications/#quick-notification","text":"The simplest way to send a notification is app.notify() : import nib def main ( app : nib . App ): app . title = \"Notify\" app . icon = nib . SFSymbol ( \"bell\" ) app . width = 200 app . height = 100 app . build ( nib . Button ( \"Send Notification\" , action = lambda : app . notify ( \"Hello!\" , \"World\" )) ) nib . run ( main )","title":"Quick Notification"},{"location":"guides/notifications/#appnotify-parameters","text":"Parameter Type Default Description title str required Main notification title body str None Body text subtitle str None Secondary line below the title sound bool True Play the default notification sound identifier str None Unique ID (for updating or canceling) app . notify ( \"Download Complete\" , body = \"report.pdf has been saved to Downloads\" , subtitle = \"File Manager\" , sound = True , )","title":"app.notify() parameters"},{"location":"guides/notifications/#requesting-permission","text":"macOS requires user permission before delivering notifications. Request it early: def on_permission ( granted ): if granted : print ( \"Notifications enabled\" ) else : print ( \"Notifications denied\" ) app . notifications . request_permission ( callback = on_permission ) Note The first call shows the system permission dialog. Subsequent calls return the cached result. If the user denied permission, they must re-enable it in System Settings.","title":"Requesting Permission"},{"location":"guides/notifications/#notification-objects","text":"For full control, create Notification objects and push them through the notification manager: from nib import Notification notification = Notification ( title = \"New Message\" , body = \"You have a new message from Alice\" , subtitle = \"Messages\" , ) app . notifications . push ( notification )","title":"Notification Objects"},{"location":"guides/notifications/#custom-sounds","text":"Use NotificationSound to configure the notification sound: from nib import Notification , NotificationSound , NotificationSoundName # Default sound notification = Notification ( title = \"Alert\" , body = \"Something happened\" , sound = NotificationSound ( name = NotificationSoundName . DEFAULT ), ) # Built-in macOS sound by name notification = Notification ( title = \"Alert\" , body = \"Something happened\" , sound = NotificationSound ( name = NotificationSoundName . custom ( \"Glass\" )), ) # Other built-in sounds: \"Frog\", \"Ping\", \"Pop\", \"Purr\", \"Sosumi\", \"Tink\"","title":"Custom sounds"},{"location":"guides/notifications/#scheduling-notifications","text":"","title":"Scheduling Notifications"},{"location":"guides/notifications/#schedule-at-a-specific-time","text":"from datetime import datetime , timedelta from nib import Notification reminder = Notification ( title = \"Break Time\" , body = \"You have been working for 2 hours. Take a break!\" , ) # Schedule for 1 hour from now notification_id = app . notifications . schedule ( reminder , at = datetime . now () + timedelta ( hours = 1 ), )","title":"Schedule at a specific time"},{"location":"guides/notifications/#schedule-daily-recurring","text":"from nib import Notification daily_reminder = Notification ( title = \"Daily Standup\" , body = \"Time for the morning standup meeting\" , ) # Every day at 9:00 AM app . notifications . schedule_daily ( daily_reminder , from_time = \"09:00\" , ) # Multiple times per day between 8 AM and 6 PM app . notifications . schedule_daily ( daily_reminder , from_time = \"08:00\" , to_time = \"18:00\" , count = 3 , ) # Daily for one week from datetime import date , timedelta app . notifications . schedule_daily ( daily_reminder , from_time = \"09:00\" , from_date = date . today (), to_date = date . today () + timedelta ( days = 7 ), )","title":"Schedule daily recurring"},{"location":"guides/notifications/#reschedule","text":"Cancel and reschedule an existing notification: app . notifications . reschedule ( reminder , at = datetime . now () + timedelta ( hours = 2 ), )","title":"Reschedule"},{"location":"guides/notifications/#notification-actions","text":"Actions appear as buttons on the notification. Users can tap them to trigger callbacks without opening the app. from nib import Notification , NotificationAction , TextInputNotificationAction notification = Notification ( title = \"New Message\" , body = \"Alice: Hey, are you free for lunch?\" , actions = [ NotificationAction ( id = \"reply\" , title = \"Reply\" , text_input = TextInputNotificationAction ( button_title = \"Send\" , placeholder = \"Type your reply...\" , ), ), NotificationAction ( id = \"mark_read\" , title = \"Mark as Read\" , ), ], ) app . notifications . push ( notification )","title":"Notification Actions"},{"location":"guides/notifications/#handling-action-callbacks","text":"Register a handler to receive action events: def handle_action ( notification_id , action_id , user_text ): if action_id == \"reply\" and user_text : print ( f \"User replied: { user_text } \" ) elif action_id == \"mark_read\" : print ( \"Marked as read\" ) unsubscribe = app . notifications . on_action ( handle_action ) # Later, to stop receiving callbacks: # unsubscribe() The callback receives three arguments: Argument Type Description notification_id str ID of the notification that was acted on action_id str ID of the action button that was tapped user_text str or None Text entered if the action has text_input","title":"Handling action callbacks"},{"location":"guides/notifications/#action-options","text":"from nib import NotificationAction , NotificationActionOption NotificationAction ( id = \"delete\" , title = \"Delete\" , options = [ NotificationActionOption . DESTRUCTIVE , # Red button NotificationActionOption . AUTHENTICATION_REQUIRED , # Requires unlock ], ) NotificationAction ( id = \"open\" , title = \"Open App\" , options = [ NotificationActionOption . FOREGROUND ], # Brings app to front )","title":"Action options"},{"location":"guides/notifications/#canceling-notifications","text":"# Cancel a specific notification by ID app . notifications . cancel_notification ( notification_id ) # Cancel all scheduled and delivered notifications app . notifications . cancel_all_notifications ()","title":"Canceling Notifications"},{"location":"guides/notifications/#querying-notifications","text":"Retrieve notifications that are currently scheduled or displayed in Notification Center: # Get all scheduled (pending) notifications def on_scheduled ( notifications ): for n in notifications : print ( f \"Scheduled: { n . title } (id: { n . id } )\" ) app . notifications . get_all_scheduled_notifications ( on_scheduled ) # Get all delivered (visible in Notification Center) notifications def on_delivered ( notifications ): print ( f \" { len ( notifications ) } notifications showing\" ) app . notifications . get_all_delivered_notifications ( on_delivered ) # Get a specific notification by ID app . notifications . get_scheduled_notification ( \"some-id\" , callback = lambda n : print ( f \"Found: { n . title } \" ) if n else print ( \"Not found\" ), )","title":"Querying Notifications"},{"location":"guides/notifications/#full-example","text":"A complete notification demo app: import nib from datetime import datetime , timedelta from nib import Notification , NotificationAction , NotificationSound , NotificationSoundName , TextInputNotificationAction def main ( app : nib . App ): app . title = \"Notifications\" app . icon = nib . SFSymbol ( \"bell.badge\" ) app . width = 300 app . height = 350 # Request permission on startup app . notifications . request_permission () # Handle action callbacks response_label = nib . Text ( \"No response yet\" , foreground_color = nib . Color . SECONDARY , font = nib . Font . CAPTION ) def on_action ( notif_id , action_id , user_text ): if action_id == \"reply\" and user_text : response_label . content = f \"Reply: { user_text } \" elif action_id == \"dismiss\" : response_label . content = \"Dismissed\" app . notifications . on_action ( on_action ) def send_simple (): app . notify ( \"Hello!\" , body = \"This is a simple notification.\" ) def send_with_actions (): notification = Notification ( title = \"Message from Alice\" , body = \"Want to grab coffee?\" , sound = NotificationSound ( name = NotificationSoundName . custom ( \"Glass\" )), actions = [ NotificationAction ( id = \"reply\" , title = \"Reply\" , text_input = TextInputNotificationAction ( button_title = \"Send\" , placeholder = \"Type reply...\" , ), ), NotificationAction ( id = \"dismiss\" , title = \"Dismiss\" ), ], ) app . notifications . push ( notification ) def schedule_reminder (): reminder = Notification ( title = \"Reminder\" , body = \"This was scheduled 10 seconds ago.\" , ) app . notifications . schedule ( reminder , at = datetime . now () + timedelta ( seconds = 10 )) response_label . content = \"Reminder scheduled in 10s\" def cancel_all (): app . notifications . cancel_all_notifications () response_label . content = \"All notifications canceled\" app . build ( nib . VStack ( controls = [ nib . Text ( \"Notification Demo\" , font = nib . Font . HEADLINE ), nib . Divider (), nib . Button ( \"Simple Notification\" , action = send_simple ), nib . Button ( \"With Actions\" , action = send_with_actions ), nib . Button ( \"Schedule (10s)\" , action = schedule_reminder ), nib . Button ( \"Cancel All\" , action = cancel_all ), nib . Divider (), nib . Text ( \"Last response:\" , font = nib . Font . CAPTION ), response_label , ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Full Example"},{"location":"guides/services/","text":"Nib exposes native macOS services through lazy-loaded properties on the app object. Each service communicates with the Swift runtime via a blocking request/response pattern. Battery \u00b6 Access battery level, charging state, health metrics, and thermal information. import nib def main ( app : nib . App ): app . title = \"Battery\" app . icon = nib . SFSymbol ( \"battery.100\" ) app . width = 300 app . height = 250 status = app . battery . get_status () level_text = f \" { status . level : .0f } %\" if status . level else \"N/A\" state_text = status . state . value charging_text = \"Yes\" if status . is_charging else \"No\" app . build ( nib . VStack ( controls = [ nib . Text ( \"Battery Status\" , font = nib . Font . HEADLINE ), nib . Divider (), _row ( \"Level\" , level_text ), _row ( \"State\" , state_text ), _row ( \"Charging\" , charging_text ), _row ( \"Plugged In\" , \"Yes\" if status . is_plugged_in else \"No\" ), _row ( \"Low Power\" , \"Yes\" if status . is_low_power_mode else \"No\" ), ], spacing = 6 , alignment = nib . HorizontalAlignment . LEADING , padding = 16 , ) ) def _row ( label , value ): return nib . HStack ( controls = [ nib . Text ( label , foreground_color = nib . Color . SECONDARY ), nib . Spacer (), nib . Text ( value ), ], ) nib . run ( main ) BatteryInfo fields \u00b6 Field Type Description level float or None Battery percentage (0--100) is_charging bool Currently charging state BatteryState Detailed state (charging, discharging, full, etc.) is_low_power_mode bool Low Power Mode enabled has_battery bool Device has a battery time_remaining int or None Minutes until empty time_to_full int or None Minutes until fully charged is_plugged_in bool or None Connected to power thermal_state str or None Current thermal state wattage float or None Power draw in watts Battery health \u00b6 health = app . battery . get_health () print ( f \"Cycle count: { health . cycle_count } \" ) print ( f \"Health: { health . health_percent : .1f } %\" ) print ( f \"Condition: { health . condition } \" ) print ( f \"Temperature: { health . temperature_celsius : .1f } C\" ) Prevent sleep \u00b6 from nib.services.battery import SleepType # Prevent idle sleep during a long task assertion = app . battery . prevent_sleep ( reason = \"Processing data\" , sleep_type = SleepType . IDLE , ) # ... do work ... # Allow sleep again app . battery . allow_sleep ( assertion ) Connectivity \u00b6 Check network status, connection type, and WiFi information. status = app . connectivity . get_status () print ( f \"Connected: { status . is_connected } \" ) print ( f \"Type: { status . type . value } \" ) # \"wifi\", \"ethernet\", \"cellular\", \"none\" print ( f \"WiFi SSID: { status . ssid } \" ) print ( f \"Expensive: { status . is_expensive } \" ) # True for cellular print ( f \"Constrained: { status . is_constrained } \" ) # Low Data Mode ConnectivityInfo fields \u00b6 Field Type Description is_connected bool Active network connection type ConnectionType WIFI , ETHERNET , CELLULAR , NONE , OTHER is_expensive bool Metered connection (cellular) is_constrained bool Low Data Mode active ssid str or None WiFi network name interface_name str or None Network interface name Example: connectivity indicator \u00b6 status = app . connectivity . get_status () if status . is_connected : icon = \"wifi\" if status . type . value == \"wifi\" else \"network\" color = nib . Color . GREEN else : icon = \"wifi.slash\" color = nib . Color . RED nib . HStack ( controls = [ nib . SFSymbol ( icon , foreground_color = color ), nib . Text ( \"Online\" if status . is_connected else \"Offline\" ), ], spacing = 6 , ) Screen \u00b6 Get display information, control brightness, check dark mode, and take screenshots. Get screen info \u00b6 info = app . screen . get_info () print ( f \"Display: { info . name } \" ) print ( f \"Resolution: { info . width } x { info . height } @ { info . scale } x\" ) print ( f \"Brightness: { info . brightness * 100 : .0f } %\" ) print ( f \"Refresh rate: { info . refresh_rate } Hz\" ) print ( f \"Native: { info . native_width } x { info . native_height } \" ) Set brightness \u00b6 app . screen . set_brightness ( 0.5 ) # 50% brightness Note Brightness control only works on the built-in display. Dark mode \u00b6 # Check dark mode dark_info = app . screen . get_dark_mode () print ( f \"Dark mode: { dark_info . is_dark_mode } \" ) # Toggle dark mode (requires Accessibility permission for System Events) app . screen . set_dark_mode ( True ) app . screen . set_dark_mode ( False ) List displays \u00b6 displays = app . screen . list_displays () for d in displays : print ( f \" { d [ 'name' ] } : { d [ 'width' ] } x { d [ 'height' ] } @ { d [ 'scale' ] } x\" ) Take a screenshot \u00b6 result = app . screen . screenshot () if result . success : result . save ( \"/tmp/screenshot.png\" ) print ( f \"Saved { result . width } x { result . height } screenshot\" ) # Capture a specific region result = app . screen . screenshot ( x = 0 , y = 0 , width = 500 , height = 500 ) Warning Screenshots require the Screen Recording permission. macOS will prompt the user on first use. Keychain \u00b6 Store and retrieve sensitive data (passwords, API tokens) securely in the macOS Keychain. # Store a credential app . keychain . set ( \"MyApp\" , \"user@example.com\" , \"secret-password\" ) # Retrieve a credential password = app . keychain . get ( \"MyApp\" , \"user@example.com\" ) if password : print ( f \"Password: { password } \" ) # Check if an entry exists if app . keychain . exists ( \"MyApp\" , \"user@example.com\" ): print ( \"Credential found\" ) # Delete a credential app . keychain . delete ( \"MyApp\" , \"user@example.com\" ) Method reference \u00b6 Method Parameters Returns Description set service, account, password bool Store or update a credential get service, account str or None Retrieve a credential delete service, account bool Delete a credential exists service, account bool Check if a credential exists Tip Use the app name as the service parameter and a username or identifier as the account parameter. Camera \u00b6 List camera devices, capture photos, and stream video frames. List devices \u00b6 devices = app . camera . list_devices () for device in devices : print ( f \" { device . name } (id= { device . id } , position= { device . position . value } )\" ) Capture a photo \u00b6 # Capture with the default camera frame = app . camera . capture_photo () frame . save ( \"/tmp/photo.jpg\" ) print ( f \"Captured { frame . width } x { frame . height } { frame . format } \" ) # Capture with a specific device frame = app . camera . capture_photo ( device_id = \"some-device-id\" , format = \"png\" ) Stream video frames \u00b6 from nib.services.camera import CameraFrame def on_frame ( frame : CameraFrame ): # Process frame (e.g., for ML inference) print ( f \"Frame: { frame . width } x { frame . height } \" ) # Start streaming at 15 FPS app . camera . start_stream ( on_frame , fps = 15 ) # Later, stop streaming app . camera . stop_stream () Warning Camera access requires the Camera permission. Use app.permissions.request(nib.Permission.CAMERA) to request it. Launch at Login \u00b6 Enable or disable automatic app launch when the user logs in. Uses SMAppService on macOS 13+. # Check current state if app . launch_at_login . is_enabled : print ( \"App launches at login\" ) # Enable (always in response to user action) app . launch_at_login . set ( True ) # Disable app . launch_at_login . set ( False ) Toggle with a control \u00b6 nib . Toggle ( \"Launch at Login\" , is_on = app . launch_at_login . is_enabled , on_change = lambda is_on : app . launch_at_login . set ( is_on ), ) Warning Per Mac App Store guidelines, Launch at Login should only be enabled in direct response to a user action (e.g., a toggle or button click). Do not enable it silently. Permissions \u00b6 Check and request Camera, Microphone, and Notification permissions through a unified API. Check a permission \u00b6 from nib.services.permissions import Permission , PermissionStatus status = app . permissions . check ( Permission . CAMERA ) if status == PermissionStatus . AUTHORIZED : print ( \"Camera access granted\" ) elif status == PermissionStatus . NOT_DETERMINED : print ( \"Permission not yet requested\" ) elif status == PermissionStatus . DENIED : print ( \"Camera access denied\" ) elif status == PermissionStatus . RESTRICTED : print ( \"Camera access restricted by policy\" ) Request a permission \u00b6 granted = app . permissions . request ( Permission . CAMERA ) if granted : print ( \"Camera access granted\" ) else : print ( \"Camera access denied\" ) Available permissions \u00b6 Permission Constant Camera Permission.CAMERA Microphone Permission.MICROPHONE Notifications Permission.NOTIFICATIONS Permission flow example \u00b6 import nib from nib.services.permissions import Permission , PermissionStatus def main ( app : nib . App ): app . title = \"Permissions\" app . icon = nib . SFSymbol ( \"lock.shield\" ) app . width = 280 app . height = 200 status_label = nib . Text ( \"Checking...\" , foreground_color = nib . Color . SECONDARY ) def check_camera (): status = app . permissions . check ( Permission . CAMERA ) if status == PermissionStatus . AUTHORIZED : status_label . content = \"Camera: Authorized\" elif status == PermissionStatus . NOT_DETERMINED : granted = app . permissions . request ( Permission . CAMERA ) status_label . content = f \"Camera: { 'Authorized' if granted else 'Denied' } \" else : status_label . content = f \"Camera: { status . value } \" app . build ( nib . VStack ( controls = [ nib . Text ( \"Permission Check\" , font = nib . Font . HEADLINE ), nib . Button ( \"Check Camera\" , action = check_camera ), status_label , ], spacing = 12 , padding = 24 , ) ) nib . run ( main )","title":"System Services"},{"location":"guides/services/#battery","text":"Access battery level, charging state, health metrics, and thermal information. import nib def main ( app : nib . App ): app . title = \"Battery\" app . icon = nib . SFSymbol ( \"battery.100\" ) app . width = 300 app . height = 250 status = app . battery . get_status () level_text = f \" { status . level : .0f } %\" if status . level else \"N/A\" state_text = status . state . value charging_text = \"Yes\" if status . is_charging else \"No\" app . build ( nib . VStack ( controls = [ nib . Text ( \"Battery Status\" , font = nib . Font . HEADLINE ), nib . Divider (), _row ( \"Level\" , level_text ), _row ( \"State\" , state_text ), _row ( \"Charging\" , charging_text ), _row ( \"Plugged In\" , \"Yes\" if status . is_plugged_in else \"No\" ), _row ( \"Low Power\" , \"Yes\" if status . is_low_power_mode else \"No\" ), ], spacing = 6 , alignment = nib . HorizontalAlignment . LEADING , padding = 16 , ) ) def _row ( label , value ): return nib . HStack ( controls = [ nib . Text ( label , foreground_color = nib . Color . SECONDARY ), nib . Spacer (), nib . Text ( value ), ], ) nib . run ( main )","title":"Battery"},{"location":"guides/services/#batteryinfo-fields","text":"Field Type Description level float or None Battery percentage (0--100) is_charging bool Currently charging state BatteryState Detailed state (charging, discharging, full, etc.) is_low_power_mode bool Low Power Mode enabled has_battery bool Device has a battery time_remaining int or None Minutes until empty time_to_full int or None Minutes until fully charged is_plugged_in bool or None Connected to power thermal_state str or None Current thermal state wattage float or None Power draw in watts","title":"BatteryInfo fields"},{"location":"guides/services/#battery-health","text":"health = app . battery . get_health () print ( f \"Cycle count: { health . cycle_count } \" ) print ( f \"Health: { health . health_percent : .1f } %\" ) print ( f \"Condition: { health . condition } \" ) print ( f \"Temperature: { health . temperature_celsius : .1f } C\" )","title":"Battery health"},{"location":"guides/services/#prevent-sleep","text":"from nib.services.battery import SleepType # Prevent idle sleep during a long task assertion = app . battery . prevent_sleep ( reason = \"Processing data\" , sleep_type = SleepType . IDLE , ) # ... do work ... # Allow sleep again app . battery . allow_sleep ( assertion )","title":"Prevent sleep"},{"location":"guides/services/#connectivity","text":"Check network status, connection type, and WiFi information. status = app . connectivity . get_status () print ( f \"Connected: { status . is_connected } \" ) print ( f \"Type: { status . type . value } \" ) # \"wifi\", \"ethernet\", \"cellular\", \"none\" print ( f \"WiFi SSID: { status . ssid } \" ) print ( f \"Expensive: { status . is_expensive } \" ) # True for cellular print ( f \"Constrained: { status . is_constrained } \" ) # Low Data Mode","title":"Connectivity"},{"location":"guides/services/#connectivityinfo-fields","text":"Field Type Description is_connected bool Active network connection type ConnectionType WIFI , ETHERNET , CELLULAR , NONE , OTHER is_expensive bool Metered connection (cellular) is_constrained bool Low Data Mode active ssid str or None WiFi network name interface_name str or None Network interface name","title":"ConnectivityInfo fields"},{"location":"guides/services/#example-connectivity-indicator","text":"status = app . connectivity . get_status () if status . is_connected : icon = \"wifi\" if status . type . value == \"wifi\" else \"network\" color = nib . Color . GREEN else : icon = \"wifi.slash\" color = nib . Color . RED nib . HStack ( controls = [ nib . SFSymbol ( icon , foreground_color = color ), nib . Text ( \"Online\" if status . is_connected else \"Offline\" ), ], spacing = 6 , )","title":"Example: connectivity indicator"},{"location":"guides/services/#screen","text":"Get display information, control brightness, check dark mode, and take screenshots.","title":"Screen"},{"location":"guides/services/#get-screen-info","text":"info = app . screen . get_info () print ( f \"Display: { info . name } \" ) print ( f \"Resolution: { info . width } x { info . height } @ { info . scale } x\" ) print ( f \"Brightness: { info . brightness * 100 : .0f } %\" ) print ( f \"Refresh rate: { info . refresh_rate } Hz\" ) print ( f \"Native: { info . native_width } x { info . native_height } \" )","title":"Get screen info"},{"location":"guides/services/#set-brightness","text":"app . screen . set_brightness ( 0.5 ) # 50% brightness Note Brightness control only works on the built-in display.","title":"Set brightness"},{"location":"guides/services/#dark-mode","text":"# Check dark mode dark_info = app . screen . get_dark_mode () print ( f \"Dark mode: { dark_info . is_dark_mode } \" ) # Toggle dark mode (requires Accessibility permission for System Events) app . screen . set_dark_mode ( True ) app . screen . set_dark_mode ( False )","title":"Dark mode"},{"location":"guides/services/#list-displays","text":"displays = app . screen . list_displays () for d in displays : print ( f \" { d [ 'name' ] } : { d [ 'width' ] } x { d [ 'height' ] } @ { d [ 'scale' ] } x\" )","title":"List displays"},{"location":"guides/services/#take-a-screenshot","text":"result = app . screen . screenshot () if result . success : result . save ( \"/tmp/screenshot.png\" ) print ( f \"Saved { result . width } x { result . height } screenshot\" ) # Capture a specific region result = app . screen . screenshot ( x = 0 , y = 0 , width = 500 , height = 500 ) Warning Screenshots require the Screen Recording permission. macOS will prompt the user on first use.","title":"Take a screenshot"},{"location":"guides/services/#keychain","text":"Store and retrieve sensitive data (passwords, API tokens) securely in the macOS Keychain. # Store a credential app . keychain . set ( \"MyApp\" , \"user@example.com\" , \"secret-password\" ) # Retrieve a credential password = app . keychain . get ( \"MyApp\" , \"user@example.com\" ) if password : print ( f \"Password: { password } \" ) # Check if an entry exists if app . keychain . exists ( \"MyApp\" , \"user@example.com\" ): print ( \"Credential found\" ) # Delete a credential app . keychain . delete ( \"MyApp\" , \"user@example.com\" )","title":"Keychain"},{"location":"guides/services/#method-reference","text":"Method Parameters Returns Description set service, account, password bool Store or update a credential get service, account str or None Retrieve a credential delete service, account bool Delete a credential exists service, account bool Check if a credential exists Tip Use the app name as the service parameter and a username or identifier as the account parameter.","title":"Method reference"},{"location":"guides/services/#camera","text":"List camera devices, capture photos, and stream video frames.","title":"Camera"},{"location":"guides/services/#list-devices","text":"devices = app . camera . list_devices () for device in devices : print ( f \" { device . name } (id= { device . id } , position= { device . position . value } )\" )","title":"List devices"},{"location":"guides/services/#capture-a-photo","text":"# Capture with the default camera frame = app . camera . capture_photo () frame . save ( \"/tmp/photo.jpg\" ) print ( f \"Captured { frame . width } x { frame . height } { frame . format } \" ) # Capture with a specific device frame = app . camera . capture_photo ( device_id = \"some-device-id\" , format = \"png\" )","title":"Capture a photo"},{"location":"guides/services/#stream-video-frames","text":"from nib.services.camera import CameraFrame def on_frame ( frame : CameraFrame ): # Process frame (e.g., for ML inference) print ( f \"Frame: { frame . width } x { frame . height } \" ) # Start streaming at 15 FPS app . camera . start_stream ( on_frame , fps = 15 ) # Later, stop streaming app . camera . stop_stream () Warning Camera access requires the Camera permission. Use app.permissions.request(nib.Permission.CAMERA) to request it.","title":"Stream video frames"},{"location":"guides/services/#launch-at-login","text":"Enable or disable automatic app launch when the user logs in. Uses SMAppService on macOS 13+. # Check current state if app . launch_at_login . is_enabled : print ( \"App launches at login\" ) # Enable (always in response to user action) app . launch_at_login . set ( True ) # Disable app . launch_at_login . set ( False )","title":"Launch at Login"},{"location":"guides/services/#toggle-with-a-control","text":"nib . Toggle ( \"Launch at Login\" , is_on = app . launch_at_login . is_enabled , on_change = lambda is_on : app . launch_at_login . set ( is_on ), ) Warning Per Mac App Store guidelines, Launch at Login should only be enabled in direct response to a user action (e.g., a toggle or button click). Do not enable it silently.","title":"Toggle with a control"},{"location":"guides/services/#permissions","text":"Check and request Camera, Microphone, and Notification permissions through a unified API.","title":"Permissions"},{"location":"guides/services/#check-a-permission","text":"from nib.services.permissions import Permission , PermissionStatus status = app . permissions . check ( Permission . CAMERA ) if status == PermissionStatus . AUTHORIZED : print ( \"Camera access granted\" ) elif status == PermissionStatus . NOT_DETERMINED : print ( \"Permission not yet requested\" ) elif status == PermissionStatus . DENIED : print ( \"Camera access denied\" ) elif status == PermissionStatus . RESTRICTED : print ( \"Camera access restricted by policy\" )","title":"Check a permission"},{"location":"guides/services/#request-a-permission","text":"granted = app . permissions . request ( Permission . CAMERA ) if granted : print ( \"Camera access granted\" ) else : print ( \"Camera access denied\" )","title":"Request a permission"},{"location":"guides/services/#available-permissions","text":"Permission Constant Camera Permission.CAMERA Microphone Permission.MICROPHONE Notifications Permission.NOTIFICATIONS","title":"Available permissions"},{"location":"guides/services/#permission-flow-example","text":"import nib from nib.services.permissions import Permission , PermissionStatus def main ( app : nib . App ): app . title = \"Permissions\" app . icon = nib . SFSymbol ( \"lock.shield\" ) app . width = 280 app . height = 200 status_label = nib . Text ( \"Checking...\" , foreground_color = nib . Color . SECONDARY ) def check_camera (): status = app . permissions . check ( Permission . CAMERA ) if status == PermissionStatus . AUTHORIZED : status_label . content = \"Camera: Authorized\" elif status == PermissionStatus . NOT_DETERMINED : granted = app . permissions . request ( Permission . CAMERA ) status_label . content = f \"Camera: { 'Authorized' if granted else 'Denied' } \" else : status_label . content = f \"Camera: { status . value } \" app . build ( nib . VStack ( controls = [ nib . Text ( \"Permission Check\" , font = nib . Font . HEADLINE ), nib . Button ( \"Check Camera\" , action = check_camera ), status_label , ], spacing = 12 , padding = 24 , ) ) nib . run ( main )","title":"Permission flow example"},{"location":"guides/settings/","text":"Nib provides two layers for persisting data across app launches: the high-level Settings class with instant cache + async persistence, and the low-level UserDefaults class for direct key-value access. Settings Class \u00b6 Settings is the recommended way to manage application preferences. It provides instant reads from an in-memory cache and automatic background writes to macOS UserDefaults. Defining settings \u00b6 Create a Settings object with a dictionary of defaults, then register it with the app: import nib def main ( app : nib . App ): settings = nib . Settings ({ \"dark_mode\" : False , \"font_size\" : 14 , \"username\" : \"\" , \"volume\" : 50 , }) app . register_settings ( settings ) # Read immediately -- returns cached value print ( f \"Dark mode: { settings . dark_mode } \" ) print ( f \"Font size: { settings . font_size } \" ) # Write -- updates cache instantly, persists in background settings . dark_mode = True settings . volume = 75 app . build ( nib . Text ( \"Settings loaded\" , padding = 24 )) nib . run ( main ) How it works \u00b6 On register_settings() , Nib loads any previously saved values from UserDefaults into the cache. Reading a setting (e.g., settings.dark_mode ) returns the cached value instantly -- no blocking I/O. Writing a setting (e.g., settings.dark_mode = True ) updates the cache and sends a fire-and-forget write to UserDefaults. Info The first register_settings() call blocks briefly (up to 2 seconds) while loading saved values. After that, all reads and writes are non-blocking. on_load callback \u00b6 If you need to run code after settings have loaded from UserDefaults, use the on_load callback: def on_settings_loaded (): print ( \"Settings loaded from disk\" ) theme_label . content = settings . theme settings = nib . Settings ( { \"theme\" : \"light\" , \"auto_save\" : True }, on_load = on_settings_loaded , ) app . register_settings ( settings ) Reset to defaults \u00b6 # Reset a single setting settings . reset ( \"font_size\" ) # Reset all settings settings . reset () Get all settings as a dict \u00b6 all_settings = settings . to_dict () # {\"dark_mode\": True, \"font_size\": 14, \"username\": \"\", \"volume\": 75} Settings-Driven UI \u00b6 Use settings to drive your UI. When a control changes, update the setting. When the app loads, read the setting to set the initial state. import nib def main ( app : nib . App ): settings = nib . Settings ({ \"dark_mode\" : False , \"font_size\" : 14 , \"notifications\" : True , }) app . register_settings ( settings ) # Build UI driven by settings dark_toggle = nib . Toggle ( \"Dark Mode\" , is_on = settings . dark_mode , on_change = lambda is_on : setattr ( settings , \"dark_mode\" , is_on ), ) font_slider = nib . Slider ( \"Font Size\" , value = settings . font_size , min_value = 10 , max_value = 24 , on_change = lambda val : setattr ( settings , \"font_size\" , int ( val )), ) notify_toggle = nib . Toggle ( \"Notifications\" , is_on = settings . notifications , on_change = lambda is_on : setattr ( settings , \"notifications\" , is_on ), ) app . build ( nib . Form ( controls = [ nib . Section ( controls = [ dark_toggle , font_slider ], header = \"Appearance\" , ), nib . Section ( controls = [ notify_toggle ], header = \"Alerts\" , ), ], style = nib . FormStyle . GROUPED , padding = 16 , ) ) nib . run ( main ) Settings Page with Tabs \u00b6 For a native macOS preferences window, create a SettingsPage with one or more SettingsTab items and assign it to app.settings . import nib def main ( app : nib . App ): app . title = \"Preferences App\" app . icon = nib . SFSymbol ( \"gear\" ) app . width = 300 app . height = 200 settings = nib . Settings ({ \"dark_mode\" : False , \"font_size\" : 14 , \"auto_update\" : True , }) app . register_settings ( settings ) app . settings = nib . SettingsPage ( width = 500 , height = 400 , title = \"Preferences\" , tabs = [ nib . SettingsTab ( \"General\" , icon = \"gear\" , content = nib . Form ( controls = [ nib . Toggle ( \"Dark Mode\" , is_on = settings . dark_mode , on_change = lambda v : setattr ( settings , \"dark_mode\" , v )), nib . Slider ( \"Font Size\" , value = settings . font_size , min_value = 10 , max_value = 24 , on_change = lambda v : setattr ( settings , \"font_size\" , int ( v ))), ], style = nib . FormStyle . GROUPED , ), ), nib . SettingsTab ( \"Updates\" , icon = \"arrow.triangle.2.circlepath\" , content = nib . Form ( controls = [ nib . Toggle ( \"Auto-Update\" , is_on = settings . auto_update , on_change = lambda v : setattr ( settings , \"auto_update\" , v )), ], style = nib . FormStyle . GROUPED , ), ), ], ) # Open settings from a button app . build ( nib . VStack ( controls = [ nib . Text ( \"Preferences App\" , font = nib . Font . HEADLINE ), nib . Button ( \"Open Settings\" , action = app . settings . open ), ], spacing = 12 , padding = 24 , ) ) nib . run ( main ) Opening the settings window \u00b6 Programmatically: call app.settings.open() Keyboard shortcut: Cmd+, (automatically wired when app.settings is set) From a menu item: nib.MenuItem(\"Settings\", action=app.settings.open, icon=\"gear\", shortcut=\"cmd,,\") SettingsTab parameters \u00b6 Parameter Type Description title str Tab title shown in the tab bar icon str SF Symbol name for the tab icon content View The view displayed when the tab is selected SettingsPage parameters \u00b6 Parameter Type Default Description tabs list[SettingsTab] [] List of tabs content View None Single view (creates one \"General\" tab) width float 450 Window width height float 300 Window height title str \"Settings\" Window title UserDefaults -- Low-Level Access \u00b6 For direct key-value persistence without the Settings wrapper, use UserDefaults . All reads are blocking with a configurable timeout. import nib def main ( app : nib . App ): app . title = \"UserDefaults Demo\" app . icon = nib . SFSymbol ( \"cylinder.split.1x2\" ) app . width = 300 app . height = 200 defaults = nib . UserDefaults () # Write values (fire-and-forget) defaults . set ( \"username\" , \"john_doe\" ) defaults . set ( \"login_count\" , 42 ) defaults . set ( \"dark_mode\" , True ) defaults . set ( \"tags\" , [ \"python\" , \"swift\" ]) # Read values (blocking, up to 5s timeout) username = defaults . get ( \"username\" , default = \"guest\" ) count = defaults . get ( \"login_count\" , default = 0 ) # Check existence if defaults . contains_key ( \"api_token\" ): token = defaults . get ( \"api_token\" ) # Get all keys with a prefix settings_keys = defaults . get_keys ( \"settings.\" ) # Remove a key defaults . remove ( \"old_key\" ) # Clear all keys # defaults.clear() app . build ( nib . VStack ( controls = [ nib . Text ( f \"User: { username } \" , font = nib . Font . HEADLINE ), nib . Text ( f \"Logins: { count } \" ), ], spacing = 8 , padding = 24 , ) ) nib . run ( main ) Supported value types \u00b6 Python Type Stored As str String int Integer float Float bool Boolean list JSON array dict JSON dictionary bytes Base64-encoded data Warning UserDefaults.get() is a blocking call that waits for a round trip to the Swift runtime. Use Settings for performance-sensitive reads.","title":"Settings & Persistence"},{"location":"guides/settings/#settings-class","text":"Settings is the recommended way to manage application preferences. It provides instant reads from an in-memory cache and automatic background writes to macOS UserDefaults.","title":"Settings Class"},{"location":"guides/settings/#defining-settings","text":"Create a Settings object with a dictionary of defaults, then register it with the app: import nib def main ( app : nib . App ): settings = nib . Settings ({ \"dark_mode\" : False , \"font_size\" : 14 , \"username\" : \"\" , \"volume\" : 50 , }) app . register_settings ( settings ) # Read immediately -- returns cached value print ( f \"Dark mode: { settings . dark_mode } \" ) print ( f \"Font size: { settings . font_size } \" ) # Write -- updates cache instantly, persists in background settings . dark_mode = True settings . volume = 75 app . build ( nib . Text ( \"Settings loaded\" , padding = 24 )) nib . run ( main )","title":"Defining settings"},{"location":"guides/settings/#how-it-works","text":"On register_settings() , Nib loads any previously saved values from UserDefaults into the cache. Reading a setting (e.g., settings.dark_mode ) returns the cached value instantly -- no blocking I/O. Writing a setting (e.g., settings.dark_mode = True ) updates the cache and sends a fire-and-forget write to UserDefaults. Info The first register_settings() call blocks briefly (up to 2 seconds) while loading saved values. After that, all reads and writes are non-blocking.","title":"How it works"},{"location":"guides/settings/#on_load-callback","text":"If you need to run code after settings have loaded from UserDefaults, use the on_load callback: def on_settings_loaded (): print ( \"Settings loaded from disk\" ) theme_label . content = settings . theme settings = nib . Settings ( { \"theme\" : \"light\" , \"auto_save\" : True }, on_load = on_settings_loaded , ) app . register_settings ( settings )","title":"on_load callback"},{"location":"guides/settings/#reset-to-defaults","text":"# Reset a single setting settings . reset ( \"font_size\" ) # Reset all settings settings . reset ()","title":"Reset to defaults"},{"location":"guides/settings/#get-all-settings-as-a-dict","text":"all_settings = settings . to_dict () # {\"dark_mode\": True, \"font_size\": 14, \"username\": \"\", \"volume\": 75}","title":"Get all settings as a dict"},{"location":"guides/settings/#settings-driven-ui","text":"Use settings to drive your UI. When a control changes, update the setting. When the app loads, read the setting to set the initial state. import nib def main ( app : nib . App ): settings = nib . Settings ({ \"dark_mode\" : False , \"font_size\" : 14 , \"notifications\" : True , }) app . register_settings ( settings ) # Build UI driven by settings dark_toggle = nib . Toggle ( \"Dark Mode\" , is_on = settings . dark_mode , on_change = lambda is_on : setattr ( settings , \"dark_mode\" , is_on ), ) font_slider = nib . Slider ( \"Font Size\" , value = settings . font_size , min_value = 10 , max_value = 24 , on_change = lambda val : setattr ( settings , \"font_size\" , int ( val )), ) notify_toggle = nib . Toggle ( \"Notifications\" , is_on = settings . notifications , on_change = lambda is_on : setattr ( settings , \"notifications\" , is_on ), ) app . build ( nib . Form ( controls = [ nib . Section ( controls = [ dark_toggle , font_slider ], header = \"Appearance\" , ), nib . Section ( controls = [ notify_toggle ], header = \"Alerts\" , ), ], style = nib . FormStyle . GROUPED , padding = 16 , ) ) nib . run ( main )","title":"Settings-Driven UI"},{"location":"guides/settings/#settings-page-with-tabs","text":"For a native macOS preferences window, create a SettingsPage with one or more SettingsTab items and assign it to app.settings . import nib def main ( app : nib . App ): app . title = \"Preferences App\" app . icon = nib . SFSymbol ( \"gear\" ) app . width = 300 app . height = 200 settings = nib . Settings ({ \"dark_mode\" : False , \"font_size\" : 14 , \"auto_update\" : True , }) app . register_settings ( settings ) app . settings = nib . SettingsPage ( width = 500 , height = 400 , title = \"Preferences\" , tabs = [ nib . SettingsTab ( \"General\" , icon = \"gear\" , content = nib . Form ( controls = [ nib . Toggle ( \"Dark Mode\" , is_on = settings . dark_mode , on_change = lambda v : setattr ( settings , \"dark_mode\" , v )), nib . Slider ( \"Font Size\" , value = settings . font_size , min_value = 10 , max_value = 24 , on_change = lambda v : setattr ( settings , \"font_size\" , int ( v ))), ], style = nib . FormStyle . GROUPED , ), ), nib . SettingsTab ( \"Updates\" , icon = \"arrow.triangle.2.circlepath\" , content = nib . Form ( controls = [ nib . Toggle ( \"Auto-Update\" , is_on = settings . auto_update , on_change = lambda v : setattr ( settings , \"auto_update\" , v )), ], style = nib . FormStyle . GROUPED , ), ), ], ) # Open settings from a button app . build ( nib . VStack ( controls = [ nib . Text ( \"Preferences App\" , font = nib . Font . HEADLINE ), nib . Button ( \"Open Settings\" , action = app . settings . open ), ], spacing = 12 , padding = 24 , ) ) nib . run ( main )","title":"Settings Page with Tabs"},{"location":"guides/settings/#opening-the-settings-window","text":"Programmatically: call app.settings.open() Keyboard shortcut: Cmd+, (automatically wired when app.settings is set) From a menu item: nib.MenuItem(\"Settings\", action=app.settings.open, icon=\"gear\", shortcut=\"cmd,,\")","title":"Opening the settings window"},{"location":"guides/settings/#settingstab-parameters","text":"Parameter Type Description title str Tab title shown in the tab bar icon str SF Symbol name for the tab icon content View The view displayed when the tab is selected","title":"SettingsTab parameters"},{"location":"guides/settings/#settingspage-parameters","text":"Parameter Type Default Description tabs list[SettingsTab] [] List of tabs content View None Single view (creates one \"General\" tab) width float 450 Window width height float 300 Window height title str \"Settings\" Window title","title":"SettingsPage parameters"},{"location":"guides/settings/#userdefaults-low-level-access","text":"For direct key-value persistence without the Settings wrapper, use UserDefaults . All reads are blocking with a configurable timeout. import nib def main ( app : nib . App ): app . title = \"UserDefaults Demo\" app . icon = nib . SFSymbol ( \"cylinder.split.1x2\" ) app . width = 300 app . height = 200 defaults = nib . UserDefaults () # Write values (fire-and-forget) defaults . set ( \"username\" , \"john_doe\" ) defaults . set ( \"login_count\" , 42 ) defaults . set ( \"dark_mode\" , True ) defaults . set ( \"tags\" , [ \"python\" , \"swift\" ]) # Read values (blocking, up to 5s timeout) username = defaults . get ( \"username\" , default = \"guest\" ) count = defaults . get ( \"login_count\" , default = 0 ) # Check existence if defaults . contains_key ( \"api_token\" ): token = defaults . get ( \"api_token\" ) # Get all keys with a prefix settings_keys = defaults . get_keys ( \"settings.\" ) # Remove a key defaults . remove ( \"old_key\" ) # Clear all keys # defaults.clear() app . build ( nib . VStack ( controls = [ nib . Text ( f \"User: { username } \" , font = nib . Font . HEADLINE ), nib . Text ( f \"Logins: { count } \" ), ], spacing = 8 , padding = 24 , ) ) nib . run ( main )","title":"UserDefaults -- Low-Level Access"},{"location":"guides/settings/#supported-value-types","text":"Python Type Stored As str String int Integer float Float bool Boolean list JSON array dict JSON dictionary bytes Base64-encoded data Warning UserDefaults.get() is a blocking call that waits for a round trip to the Swift runtime. Use Settings for performance-sensitive reads.","title":"Supported value types"},{"location":"guides/styling/","text":"All styling in Nib is done through constructor parameters. There is no method chaining -- you pass modifiers directly when creating a view. nib . Text ( \"Hello\" , font = nib . Font . TITLE , foreground_color = nib . Color . BLUE , padding = 16 , background = nib . Color . BLACK , ) This guide covers the full set of appearance modifiers available on every view. Background \u00b6 The background parameter accepts a color string, a Color object, or a shape view (like Rectangle ) for richer backgrounds. # Solid named color nib . Text ( \"Hello\" , background = nib . Color . BLUE ) # Hex string nib . Text ( \"Hello\" , background = \"#FF5733\" ) # Shape with fill nib . VStack ( controls = [ nib . Text ( \"Card content\" )], background = nib . Rectangle ( corner_radius = 10 , fill = \"blue\" ), padding = 16 , ) # Shape with fill and stroke nib . VStack ( controls = [ nib . Text ( \"Bordered card\" )], background = nib . Rectangle ( corner_radius = 8 , fill = \"#1a1a1a\" , stroke = \"#383838\" , stroke_width = 1 , ), padding = 16 , ) Tip Use a Rectangle background with corner_radius when you want rounded corners, fill color, and stroke all in one. The padding modifier adds space between the content and the background edge. Foreground Color \u00b6 foreground_color sets the color of text, icons, and other rendered content. nib . Text ( \"Warning\" , foreground_color = nib . Color . RED ) nib . Text ( \"Muted\" , foreground_color = nib . Color . SECONDARY ) nib . SFSymbol ( \"star.fill\" , foreground_color = \"#FFD700\" ) Opacity \u00b6 opacity controls view transparency. Values range from 0.0 (fully transparent) to 1.0 (fully opaque). nib . Text ( \"Ghost text\" , opacity = 0.5 ) nib . Rectangle ( corner_radius = 8 , fill = nib . Color . BLACK , opacity = 0.3 , width = 200 , height = 100 , ) You can also use Color.with_opacity() for per-color transparency: nib . Text ( \"Tinted\" , foreground_color = nib . Color . BLUE . with_opacity ( 0.6 )) Corner Radius \u00b6 corner_radius rounds the corners of any view. Pass a single float for uniform corners or a CornerRadius object for per-corner control. # Uniform corners nib . Rectangle ( fill = nib . Color . BLUE , corner_radius = 10 , width = 100 , height = 60 ) # Per-corner control nib . Rectangle ( fill = nib . Color . GREEN , corner_radius = nib . CornerRadius ( top_left = 20 , top_right = 20 , bottom_left = 0 , bottom_right = 0 , ), width = 100 , height = 60 , ) CornerRadius factory methods for common patterns: # All corners equal nib . CornerRadius . all ( 12 ) # Only specific corners nib . CornerRadius . only ( top_left = 16 , top_right = 16 ) # Top rounded, bottom square nib . CornerRadius . vertical ( top = 16 , bottom = 0 ) # Left rounded, right square nib . CornerRadius . horizontal ( left = 12 , right = 0 ) Border \u00b6 border_color and border_width add a stroke around the view's bounds. nib . Text ( \"Bordered\" , border_color = \"#333333\" , border_width = 1 , padding = 12 , ) nib . VStack ( controls = [ nib . Text ( \"Content\" )], border_color = nib . Color . BLUE , border_width = 2 , corner_radius = 8 , padding = 16 , ) Note For rounded borders, combine border_color and border_width with corner_radius , or use a Rectangle background with corner_radius , stroke , and stroke_width . Shadow \u00b6 Drop shadows are controlled by four parameters: shadow_color , shadow_radius , shadow_x , and shadow_y . nib . VStack ( controls = [ nib . Text ( \"Elevated card\" )], padding = 16 , background = nib . Rectangle ( corner_radius = 10 , fill = \"#ffffff\" ), shadow_color = \"black\" , shadow_radius = 5 , shadow_x = 0 , shadow_y = 2 , ) A subtle shadow: nib . Rectangle ( corner_radius = 12 , fill = \"#1e1e1e\" , width = 200 , height = 120 , shadow_color = \"#000000\" , shadow_radius = 10 , shadow_x = 0 , shadow_y = 4 , ) Clip Shape \u00b6 clip_shape clips a view to a specific shape, hiding anything outside the boundary. # Clip to circle nib . Image ( url = \"https://example.com/avatar.jpg\" , width = 64 , height = 64 , clip_shape = \"circle\" ) # Clip to capsule (pill shape) nib . Text ( \"Tag\" , padding = 8 , background = nib . Color . BLUE , clip_shape = \"capsule\" ) Supported string values: \"circle\" , \"capsule\" . You can also pass a shape view for more control: nib . Image ( url = \"https://example.com/photo.jpg\" , width = 100 , height = 100 , clip_shape = nib . Rectangle ( corner_radius = 16 ), ) Scale \u00b6 scale applies a uniform scale transform. A value of 1.0 is normal size. nib . SFSymbol ( \"star.fill\" , scale = 2.0 ) # Double size nib . Text ( \"Small\" , scale = 0.75 ) # 75% size Blend Mode \u00b6 blend_mode controls how a view composites with views behind it. nib . Rectangle ( fill = nib . Color . RED , width = 100 , height = 100 , blend_mode = nib . BlendMode . MULTIPLY , ) Available blend modes: NORMAL , MULTIPLY , SCREEN , OVERLAY , DARKEN , LIGHTEN , COLOR_DODGE , COLOR_BURN , SOFT_LIGHT , HARD_LIGHT , DIFFERENCE , EXCLUSION , HUE , SATURATION , COLOR , LUMINOSITY . Padding and Margin \u00b6 padding adds space inside the view (between content and background). margin adds space outside (after the background). # Uniform padding on all sides nib . Text ( \"Padded\" , padding = 16 , background = nib . Color . BLUE ) # Per-side padding using a dict nib . Text ( \"Custom padding\" , padding = { \"top\" : 8 , \"bottom\" : 8 , \"leading\" : 16 , \"trailing\" : 16 }, background = nib . Color . BLUE , ) # Shorthand: horizontal and vertical nib . Text ( \"Shorthand\" , padding = { \"horizontal\" : 16 , \"vertical\" : 8 }, background = nib . Color . BLUE , ) Width and Height \u00b6 Fixed dimensions, minimums, and maximums: # Fixed size nib . Rectangle ( fill = nib . Color . RED , width = 100 , height = 50 ) # Minimum and maximum nib . Text ( \"Flexible\" , min_width = 100 , max_width = 300 ) # Fill available width nib . Text ( \"Full width\" , max_width = \"infinity\" ) Full Styled Card Example \u00b6 Combining multiple modifiers to build a polished card component: import nib def main ( app : nib . App ): app . title = \"Styled Card\" app . icon = nib . SFSymbol ( \"rectangle.fill\" ) app . width = 320 app . height = 300 app . build ( nib . VStack ( controls = [ nib . VStack ( controls = [ nib . HStack ( controls = [ nib . SFSymbol ( \"bolt.fill\" , foreground_color = nib . Color . YELLOW , font = nib . Font . TITLE , ), nib . VStack ( controls = [ nib . Text ( \"Performance\" , font = nib . Font . HEADLINE ), nib . Text ( \"System stats\" , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), nib . Spacer (), nib . Text ( \"98%\" , font = nib . Font . TITLE , foreground_color = nib . Color . GREEN ), ], spacing = 12 , alignment = nib . VerticalAlignment . CENTER , ), nib . Divider (), nib . HStack ( controls = [ _metric ( \"CPU\" , \"12%\" ), _metric ( \"RAM\" , \"4.2 GB\" ), _metric ( \"Disk\" , \"128 GB\" ), ], spacing = 16 , ), ], spacing = 12 , padding = 16 , background = nib . Rectangle ( corner_radius = 12 , fill = \"#1c1c1e\" , stroke = \"#2c2c2e\" , stroke_width = 1 , ), shadow_color = \"#000000\" , shadow_radius = 8 , shadow_y = 4 , ), ], padding = 16 , ) ) def _metric ( label , value ): return nib . VStack ( controls = [ nib . Text ( value , font = nib . Font . system ( 14 , nib . FontWeight . SEMIBOLD )), nib . Text ( label , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], spacing = 2 , ) nib . run ( main )","title":"Styling & Theming"},{"location":"guides/styling/#background","text":"The background parameter accepts a color string, a Color object, or a shape view (like Rectangle ) for richer backgrounds. # Solid named color nib . Text ( \"Hello\" , background = nib . Color . BLUE ) # Hex string nib . Text ( \"Hello\" , background = \"#FF5733\" ) # Shape with fill nib . VStack ( controls = [ nib . Text ( \"Card content\" )], background = nib . Rectangle ( corner_radius = 10 , fill = \"blue\" ), padding = 16 , ) # Shape with fill and stroke nib . VStack ( controls = [ nib . Text ( \"Bordered card\" )], background = nib . Rectangle ( corner_radius = 8 , fill = \"#1a1a1a\" , stroke = \"#383838\" , stroke_width = 1 , ), padding = 16 , ) Tip Use a Rectangle background with corner_radius when you want rounded corners, fill color, and stroke all in one. The padding modifier adds space between the content and the background edge.","title":"Background"},{"location":"guides/styling/#foreground-color","text":"foreground_color sets the color of text, icons, and other rendered content. nib . Text ( \"Warning\" , foreground_color = nib . Color . RED ) nib . Text ( \"Muted\" , foreground_color = nib . Color . SECONDARY ) nib . SFSymbol ( \"star.fill\" , foreground_color = \"#FFD700\" )","title":"Foreground Color"},{"location":"guides/styling/#opacity","text":"opacity controls view transparency. Values range from 0.0 (fully transparent) to 1.0 (fully opaque). nib . Text ( \"Ghost text\" , opacity = 0.5 ) nib . Rectangle ( corner_radius = 8 , fill = nib . Color . BLACK , opacity = 0.3 , width = 200 , height = 100 , ) You can also use Color.with_opacity() for per-color transparency: nib . Text ( \"Tinted\" , foreground_color = nib . Color . BLUE . with_opacity ( 0.6 ))","title":"Opacity"},{"location":"guides/styling/#corner-radius","text":"corner_radius rounds the corners of any view. Pass a single float for uniform corners or a CornerRadius object for per-corner control. # Uniform corners nib . Rectangle ( fill = nib . Color . BLUE , corner_radius = 10 , width = 100 , height = 60 ) # Per-corner control nib . Rectangle ( fill = nib . Color . GREEN , corner_radius = nib . CornerRadius ( top_left = 20 , top_right = 20 , bottom_left = 0 , bottom_right = 0 , ), width = 100 , height = 60 , ) CornerRadius factory methods for common patterns: # All corners equal nib . CornerRadius . all ( 12 ) # Only specific corners nib . CornerRadius . only ( top_left = 16 , top_right = 16 ) # Top rounded, bottom square nib . CornerRadius . vertical ( top = 16 , bottom = 0 ) # Left rounded, right square nib . CornerRadius . horizontal ( left = 12 , right = 0 )","title":"Corner Radius"},{"location":"guides/styling/#border","text":"border_color and border_width add a stroke around the view's bounds. nib . Text ( \"Bordered\" , border_color = \"#333333\" , border_width = 1 , padding = 12 , ) nib . VStack ( controls = [ nib . Text ( \"Content\" )], border_color = nib . Color . BLUE , border_width = 2 , corner_radius = 8 , padding = 16 , ) Note For rounded borders, combine border_color and border_width with corner_radius , or use a Rectangle background with corner_radius , stroke , and stroke_width .","title":"Border"},{"location":"guides/styling/#shadow","text":"Drop shadows are controlled by four parameters: shadow_color , shadow_radius , shadow_x , and shadow_y . nib . VStack ( controls = [ nib . Text ( \"Elevated card\" )], padding = 16 , background = nib . Rectangle ( corner_radius = 10 , fill = \"#ffffff\" ), shadow_color = \"black\" , shadow_radius = 5 , shadow_x = 0 , shadow_y = 2 , ) A subtle shadow: nib . Rectangle ( corner_radius = 12 , fill = \"#1e1e1e\" , width = 200 , height = 120 , shadow_color = \"#000000\" , shadow_radius = 10 , shadow_x = 0 , shadow_y = 4 , )","title":"Shadow"},{"location":"guides/styling/#clip-shape","text":"clip_shape clips a view to a specific shape, hiding anything outside the boundary. # Clip to circle nib . Image ( url = \"https://example.com/avatar.jpg\" , width = 64 , height = 64 , clip_shape = \"circle\" ) # Clip to capsule (pill shape) nib . Text ( \"Tag\" , padding = 8 , background = nib . Color . BLUE , clip_shape = \"capsule\" ) Supported string values: \"circle\" , \"capsule\" . You can also pass a shape view for more control: nib . Image ( url = \"https://example.com/photo.jpg\" , width = 100 , height = 100 , clip_shape = nib . Rectangle ( corner_radius = 16 ), )","title":"Clip Shape"},{"location":"guides/styling/#scale","text":"scale applies a uniform scale transform. A value of 1.0 is normal size. nib . SFSymbol ( \"star.fill\" , scale = 2.0 ) # Double size nib . Text ( \"Small\" , scale = 0.75 ) # 75% size","title":"Scale"},{"location":"guides/styling/#blend-mode","text":"blend_mode controls how a view composites with views behind it. nib . Rectangle ( fill = nib . Color . RED , width = 100 , height = 100 , blend_mode = nib . BlendMode . MULTIPLY , ) Available blend modes: NORMAL , MULTIPLY , SCREEN , OVERLAY , DARKEN , LIGHTEN , COLOR_DODGE , COLOR_BURN , SOFT_LIGHT , HARD_LIGHT , DIFFERENCE , EXCLUSION , HUE , SATURATION , COLOR , LUMINOSITY .","title":"Blend Mode"},{"location":"guides/styling/#padding-and-margin","text":"padding adds space inside the view (between content and background). margin adds space outside (after the background). # Uniform padding on all sides nib . Text ( \"Padded\" , padding = 16 , background = nib . Color . BLUE ) # Per-side padding using a dict nib . Text ( \"Custom padding\" , padding = { \"top\" : 8 , \"bottom\" : 8 , \"leading\" : 16 , \"trailing\" : 16 }, background = nib . Color . BLUE , ) # Shorthand: horizontal and vertical nib . Text ( \"Shorthand\" , padding = { \"horizontal\" : 16 , \"vertical\" : 8 }, background = nib . Color . BLUE , )","title":"Padding and Margin"},{"location":"guides/styling/#width-and-height","text":"Fixed dimensions, minimums, and maximums: # Fixed size nib . Rectangle ( fill = nib . Color . RED , width = 100 , height = 50 ) # Minimum and maximum nib . Text ( \"Flexible\" , min_width = 100 , max_width = 300 ) # Fill available width nib . Text ( \"Full width\" , max_width = \"infinity\" )","title":"Width and Height"},{"location":"guides/styling/#full-styled-card-example","text":"Combining multiple modifiers to build a polished card component: import nib def main ( app : nib . App ): app . title = \"Styled Card\" app . icon = nib . SFSymbol ( \"rectangle.fill\" ) app . width = 320 app . height = 300 app . build ( nib . VStack ( controls = [ nib . VStack ( controls = [ nib . HStack ( controls = [ nib . SFSymbol ( \"bolt.fill\" , foreground_color = nib . Color . YELLOW , font = nib . Font . TITLE , ), nib . VStack ( controls = [ nib . Text ( \"Performance\" , font = nib . Font . HEADLINE ), nib . Text ( \"System stats\" , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), nib . Spacer (), nib . Text ( \"98%\" , font = nib . Font . TITLE , foreground_color = nib . Color . GREEN ), ], spacing = 12 , alignment = nib . VerticalAlignment . CENTER , ), nib . Divider (), nib . HStack ( controls = [ _metric ( \"CPU\" , \"12%\" ), _metric ( \"RAM\" , \"4.2 GB\" ), _metric ( \"Disk\" , \"128 GB\" ), ], spacing = 16 , ), ], spacing = 12 , padding = 16 , background = nib . Rectangle ( corner_radius = 12 , fill = \"#1c1c1e\" , stroke = \"#2c2c2e\" , stroke_width = 1 , ), shadow_color = \"#000000\" , shadow_radius = 8 , shadow_y = 4 , ), ], padding = 16 , ) ) def _metric ( label , value ): return nib . VStack ( controls = [ nib . Text ( value , font = nib . Font . system ( 14 , nib . FontWeight . SEMIBOLD )), nib . Text ( label , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], spacing = 2 , ) nib . run ( main )","title":"Full Styled Card Example"},{"location":"guides/typography/","text":"Nib gives you access to the full set of SwiftUI system fonts, custom size and weight control, custom font files, and rich text with attributed strings. System Fonts \u00b6 System fonts are predefined on the Font class and match the macOS Dynamic Type styles: import nib nib . Text ( \"Large Title\" , font = nib . Font . LARGE_TITLE ) nib . Text ( \"Title\" , font = nib . Font . TITLE ) nib . Text ( \"Title 2\" , font = nib . Font . TITLE2 ) nib . Text ( \"Title 3\" , font = nib . Font . TITLE3 ) nib . Text ( \"Headline\" , font = nib . Font . HEADLINE ) nib . Text ( \"Subheadline\" , font = nib . Font . SUBHEADLINE ) nib . Text ( \"Body\" , font = nib . Font . BODY ) nib . Text ( \"Callout\" , font = nib . Font . CALLOUT ) nib . Text ( \"Footnote\" , font = nib . Font . FOOTNOTE ) nib . Text ( \"Caption\" , font = nib . Font . CAPTION ) nib . Text ( \"Caption 2\" , font = nib . Font . CAPTION2 ) Font Typical Use Font.LARGE_TITLE Screen titles, hero text Font.TITLE Section titles Font.TITLE2 Secondary titles Font.TITLE3 Tertiary titles Font.HEADLINE Row titles, bold labels Font.SUBHEADLINE Subtitles, secondary labels Font.BODY Main content text (default) Font.CALLOUT Callout boxes, hints Font.FOOTNOTE Footer text, fine print Font.CAPTION Labels below images Font.CAPTION2 Smallest caption text Custom Size \u00b6 Use Font.system() to create a system font with a specific point size and optional weight: nib . Text ( \"18pt Regular\" , font = nib . Font . system ( 18 )) nib . Text ( \"24pt Bold\" , font = nib . Font . system ( 24 , nib . FontWeight . BOLD )) nib . Text ( \"14pt Light\" , font = nib . Font . system ( 14 , nib . FontWeight . LIGHT )) Font Weight \u00b6 The FontWeight enum provides all standard weights: Weight Constant Ultra Light nib.FontWeight.ULTRA_LIGHT Thin nib.FontWeight.THIN Light nib.FontWeight.LIGHT Regular nib.FontWeight.REGULAR Medium nib.FontWeight.MEDIUM Semibold nib.FontWeight.SEMIBOLD Bold nib.FontWeight.BOLD Heavy nib.FontWeight.HEAVY Black nib.FontWeight.BLACK You can also apply weight as a standalone modifier using font_weight : nib . Text ( \"Bold Body\" , font = nib . Font . BODY , font_weight = nib . FontWeight . BOLD ) Custom Fonts \u00b6 Use Font.custom() to specify a font family by name. The font must be installed on the system or registered with the app. nib . Text ( \"Custom Font\" , font = nib . Font . custom ( \"Inter\" , size = 16 )) nib . Text ( \"Weighted\" , font = nib . Font . custom ( \"Inter\" , size = 16 , weight = nib . FontWeight . SEMIBOLD )) Loading Custom Font Files \u00b6 There are two ways to load custom font files ( .ttf , .otf , .ttc ): 1. Auto-detection from the assets/ directory (recommended) Place font files anywhere inside your project's assets/ folder. Nib scans this directory on startup and registers every .ttf , .otf , .ttc , .woff , and .woff2 file it finds. The font name is derived from the filename without extension. my_project/ main.py assets/ Inter-Regular.ttf Inter-Bold.ttf JetBrainsMono-Regular.ttf # Fonts are auto-detected from assets/ -- no registration needed nib . Text ( \"Hello\" , font = nib . Font . custom ( \"Inter-Regular\" , size = 16 )) nib . Text ( \"Code\" , font = nib . Font . custom ( \"JetBrainsMono-Regular\" , size = 14 )) 2. Manual registration via app.fonts For fonts stored elsewhere, register them by setting app.fonts to a dictionary mapping names to absolute file paths or URLs: def main ( app : nib . App ): app . fonts = { \"CustomFont\" : \"/Users/me/fonts/CustomFont.ttf\" , \"WebFont\" : \"https://example.com/fonts/WebFont.otf\" , } app . build ( nib . Text ( \"Custom\" , font = nib . Font . custom ( \"CustomFont\" , size = 16 )) ) Note Auto-detected fonts and manually registered fonts are merged. If the same name appears in both, the manual registration takes precedence. TextStyle \u00b6 TextStyle groups font, decorations, and spacing into a single reusable object. Use it with the style parameter on Text . nib . Text ( \"Styled\" , style = nib . TextStyle ( bold = True , italic = True , underline = True )) Available TextStyle attributes: Attribute Type Description font Font Font to use color str Text color weight str Font weight bold bool Bold text italic bool Italic text strikethrough bool Strikethrough line strikethrough_color str Color of strikethrough underline bool Underline text underline_color str Color of underline monospaced bool Monospaced font monospaced_digit bool Monospaced digits (for aligned numbers) kerning float Letter spacing tracking float Uniform spacing between characters baseline_offset float Vertical offset from baseline Combining decorations \u00b6 # Bold, italic, and underlined nib . Text ( \"Fancy Text\" , style = nib . TextStyle ( font = nib . Font . system ( 18 ), bold = True , italic = True , underline = True , underline_color = \"blue\" , kerning = 1.5 , ), ) Monospaced digits \u00b6 Use monospaced_digit for numbers that need to align vertically (clocks, counters, tables): nib . Text ( \"12:34:56\" , style = nib . TextStyle ( monospaced_digit = True , font = nib . Font . TITLE )) Predefined text styles \u00b6 TextStyle also has predefined presets that mirror the system font hierarchy: nib . Text ( \"Title\" , style = nib . TextStyle . TITLE ) nib . Text ( \"Headline\" , style = nib . TextStyle . HEADLINE ) nib . Text ( \"Body\" , style = nib . TextStyle . BODY ) nib . Text ( \"Caption\" , style = nib . TextStyle . CAPTION ) AttributedString -- Rich Text \u00b6 AttributedString lets you combine multiple styles within a single Text view. Pass a list of attributed strings to the strings parameter: nib . Text ( strings = [ nib . AttributedString ( \"Bold\" , style = nib . TextStyle ( bold = True )), nib . AttributedString ( \" Normal \" ), nib . AttributedString ( \"Red\" , color = \"red\" ), nib . AttributedString ( \" Italic\" , style = nib . TextStyle ( italic = True )), ], ) Each AttributedString accepts: Parameter Type Description content str The text segment style TextStyle Full style configuration color str or Color Color override font Font Font override Mixing fonts and colors \u00b6 nib . Text ( strings = [ nib . AttributedString ( \"Important: \" , style = nib . TextStyle ( bold = True , color = \"red\" ), ), nib . AttributedString ( \"This is normal body text that follows the warning.\" , font = nib . Font . BODY , ), ], ) Status line example \u00b6 nib . Text ( strings = [ nib . AttributedString ( \"Status: \" , style = nib . TextStyle ( bold = True )), nib . AttributedString ( \"Connected\" , color = \"green\" ), nib . AttributedString ( \" | \" ), nib . AttributedString ( \"3 devices\" , style = nib . TextStyle ( monospaced_digit = True )), ], ) Full Example \u00b6 A complete app showcasing typography features: import nib def main ( app : nib . App ): app . title = \"Typography\" app . icon = nib . SFSymbol ( \"textformat\" ) app . width = 320 app . height = 500 app . build ( nib . ScrollView ( controls = [ nib . VStack ( controls = [ # System font scale nib . Text ( \"System Fonts\" , font = nib . Font . HEADLINE ), nib . Text ( \"Large Title\" , font = nib . Font . LARGE_TITLE ), nib . Text ( \"Title\" , font = nib . Font . TITLE ), nib . Text ( \"Headline\" , font = nib . Font . HEADLINE ), nib . Text ( \"Body (default)\" , font = nib . Font . BODY ), nib . Text ( \"Caption\" , font = nib . Font . CAPTION ), nib . Divider (), # Weights nib . Text ( \"Font Weights\" , font = nib . Font . HEADLINE ), nib . Text ( \"Ultra Light\" , font = nib . Font . system ( 16 , nib . FontWeight . ULTRA_LIGHT )), nib . Text ( \"Light\" , font = nib . Font . system ( 16 , nib . FontWeight . LIGHT )), nib . Text ( \"Regular\" , font = nib . Font . system ( 16 , nib . FontWeight . REGULAR )), nib . Text ( \"Medium\" , font = nib . Font . system ( 16 , nib . FontWeight . MEDIUM )), nib . Text ( \"Bold\" , font = nib . Font . system ( 16 , nib . FontWeight . BOLD )), nib . Text ( \"Black\" , font = nib . Font . system ( 16 , nib . FontWeight . BLACK )), nib . Divider (), # Text decorations nib . Text ( \"Text Styles\" , font = nib . Font . HEADLINE ), nib . Text ( \"Bold\" , style = nib . TextStyle ( bold = True )), nib . Text ( \"Italic\" , style = nib . TextStyle ( italic = True )), nib . Text ( \"Underline\" , style = nib . TextStyle ( underline = True )), nib . Text ( \"Strikethrough\" , style = nib . TextStyle ( strikethrough = True )), nib . Text ( \"Monospaced\" , style = nib . TextStyle ( monospaced = True )), nib . Divider (), # Attributed string nib . Text ( \"Rich Text\" , font = nib . Font . HEADLINE ), nib . Text ( strings = [ nib . AttributedString ( \"Hello \" , color = \"blue\" ), nib . AttributedString ( \"World\" , style = nib . TextStyle ( bold = True , color = \"red\" )), nib . AttributedString ( \"!\" , font = nib . Font . TITLE ), ], ), ], spacing = 6 , alignment = nib . HorizontalAlignment . LEADING , padding = 16 , ), ], ) ) nib . run ( main )","title":"Typography & Fonts"},{"location":"guides/typography/#system-fonts","text":"System fonts are predefined on the Font class and match the macOS Dynamic Type styles: import nib nib . Text ( \"Large Title\" , font = nib . Font . LARGE_TITLE ) nib . Text ( \"Title\" , font = nib . Font . TITLE ) nib . Text ( \"Title 2\" , font = nib . Font . TITLE2 ) nib . Text ( \"Title 3\" , font = nib . Font . TITLE3 ) nib . Text ( \"Headline\" , font = nib . Font . HEADLINE ) nib . Text ( \"Subheadline\" , font = nib . Font . SUBHEADLINE ) nib . Text ( \"Body\" , font = nib . Font . BODY ) nib . Text ( \"Callout\" , font = nib . Font . CALLOUT ) nib . Text ( \"Footnote\" , font = nib . Font . FOOTNOTE ) nib . Text ( \"Caption\" , font = nib . Font . CAPTION ) nib . Text ( \"Caption 2\" , font = nib . Font . CAPTION2 ) Font Typical Use Font.LARGE_TITLE Screen titles, hero text Font.TITLE Section titles Font.TITLE2 Secondary titles Font.TITLE3 Tertiary titles Font.HEADLINE Row titles, bold labels Font.SUBHEADLINE Subtitles, secondary labels Font.BODY Main content text (default) Font.CALLOUT Callout boxes, hints Font.FOOTNOTE Footer text, fine print Font.CAPTION Labels below images Font.CAPTION2 Smallest caption text","title":"System Fonts"},{"location":"guides/typography/#custom-size","text":"Use Font.system() to create a system font with a specific point size and optional weight: nib . Text ( \"18pt Regular\" , font = nib . Font . system ( 18 )) nib . Text ( \"24pt Bold\" , font = nib . Font . system ( 24 , nib . FontWeight . BOLD )) nib . Text ( \"14pt Light\" , font = nib . Font . system ( 14 , nib . FontWeight . LIGHT ))","title":"Custom Size"},{"location":"guides/typography/#font-weight","text":"The FontWeight enum provides all standard weights: Weight Constant Ultra Light nib.FontWeight.ULTRA_LIGHT Thin nib.FontWeight.THIN Light nib.FontWeight.LIGHT Regular nib.FontWeight.REGULAR Medium nib.FontWeight.MEDIUM Semibold nib.FontWeight.SEMIBOLD Bold nib.FontWeight.BOLD Heavy nib.FontWeight.HEAVY Black nib.FontWeight.BLACK You can also apply weight as a standalone modifier using font_weight : nib . Text ( \"Bold Body\" , font = nib . Font . BODY , font_weight = nib . FontWeight . BOLD )","title":"Font Weight"},{"location":"guides/typography/#custom-fonts","text":"Use Font.custom() to specify a font family by name. The font must be installed on the system or registered with the app. nib . Text ( \"Custom Font\" , font = nib . Font . custom ( \"Inter\" , size = 16 )) nib . Text ( \"Weighted\" , font = nib . Font . custom ( \"Inter\" , size = 16 , weight = nib . FontWeight . SEMIBOLD ))","title":"Custom Fonts"},{"location":"guides/typography/#loading-custom-font-files","text":"There are two ways to load custom font files ( .ttf , .otf , .ttc ): 1. Auto-detection from the assets/ directory (recommended) Place font files anywhere inside your project's assets/ folder. Nib scans this directory on startup and registers every .ttf , .otf , .ttc , .woff , and .woff2 file it finds. The font name is derived from the filename without extension. my_project/ main.py assets/ Inter-Regular.ttf Inter-Bold.ttf JetBrainsMono-Regular.ttf # Fonts are auto-detected from assets/ -- no registration needed nib . Text ( \"Hello\" , font = nib . Font . custom ( \"Inter-Regular\" , size = 16 )) nib . Text ( \"Code\" , font = nib . Font . custom ( \"JetBrainsMono-Regular\" , size = 14 )) 2. Manual registration via app.fonts For fonts stored elsewhere, register them by setting app.fonts to a dictionary mapping names to absolute file paths or URLs: def main ( app : nib . App ): app . fonts = { \"CustomFont\" : \"/Users/me/fonts/CustomFont.ttf\" , \"WebFont\" : \"https://example.com/fonts/WebFont.otf\" , } app . build ( nib . Text ( \"Custom\" , font = nib . Font . custom ( \"CustomFont\" , size = 16 )) ) Note Auto-detected fonts and manually registered fonts are merged. If the same name appears in both, the manual registration takes precedence.","title":"Loading Custom Font Files"},{"location":"guides/typography/#textstyle","text":"TextStyle groups font, decorations, and spacing into a single reusable object. Use it with the style parameter on Text . nib . Text ( \"Styled\" , style = nib . TextStyle ( bold = True , italic = True , underline = True )) Available TextStyle attributes: Attribute Type Description font Font Font to use color str Text color weight str Font weight bold bool Bold text italic bool Italic text strikethrough bool Strikethrough line strikethrough_color str Color of strikethrough underline bool Underline text underline_color str Color of underline monospaced bool Monospaced font monospaced_digit bool Monospaced digits (for aligned numbers) kerning float Letter spacing tracking float Uniform spacing between characters baseline_offset float Vertical offset from baseline","title":"TextStyle"},{"location":"guides/typography/#combining-decorations","text":"# Bold, italic, and underlined nib . Text ( \"Fancy Text\" , style = nib . TextStyle ( font = nib . Font . system ( 18 ), bold = True , italic = True , underline = True , underline_color = \"blue\" , kerning = 1.5 , ), )","title":"Combining decorations"},{"location":"guides/typography/#monospaced-digits","text":"Use monospaced_digit for numbers that need to align vertically (clocks, counters, tables): nib . Text ( \"12:34:56\" , style = nib . TextStyle ( monospaced_digit = True , font = nib . Font . TITLE ))","title":"Monospaced digits"},{"location":"guides/typography/#predefined-text-styles","text":"TextStyle also has predefined presets that mirror the system font hierarchy: nib . Text ( \"Title\" , style = nib . TextStyle . TITLE ) nib . Text ( \"Headline\" , style = nib . TextStyle . HEADLINE ) nib . Text ( \"Body\" , style = nib . TextStyle . BODY ) nib . Text ( \"Caption\" , style = nib . TextStyle . CAPTION )","title":"Predefined text styles"},{"location":"guides/typography/#attributedstring-rich-text","text":"AttributedString lets you combine multiple styles within a single Text view. Pass a list of attributed strings to the strings parameter: nib . Text ( strings = [ nib . AttributedString ( \"Bold\" , style = nib . TextStyle ( bold = True )), nib . AttributedString ( \" Normal \" ), nib . AttributedString ( \"Red\" , color = \"red\" ), nib . AttributedString ( \" Italic\" , style = nib . TextStyle ( italic = True )), ], ) Each AttributedString accepts: Parameter Type Description content str The text segment style TextStyle Full style configuration color str or Color Color override font Font Font override","title":"AttributedString -- Rich Text"},{"location":"guides/typography/#mixing-fonts-and-colors","text":"nib . Text ( strings = [ nib . AttributedString ( \"Important: \" , style = nib . TextStyle ( bold = True , color = \"red\" ), ), nib . AttributedString ( \"This is normal body text that follows the warning.\" , font = nib . Font . BODY , ), ], )","title":"Mixing fonts and colors"},{"location":"guides/typography/#status-line-example","text":"nib . Text ( strings = [ nib . AttributedString ( \"Status: \" , style = nib . TextStyle ( bold = True )), nib . AttributedString ( \"Connected\" , color = \"green\" ), nib . AttributedString ( \" | \" ), nib . AttributedString ( \"3 devices\" , style = nib . TextStyle ( monospaced_digit = True )), ], )","title":"Status line example"},{"location":"guides/typography/#full-example","text":"A complete app showcasing typography features: import nib def main ( app : nib . App ): app . title = \"Typography\" app . icon = nib . SFSymbol ( \"textformat\" ) app . width = 320 app . height = 500 app . build ( nib . ScrollView ( controls = [ nib . VStack ( controls = [ # System font scale nib . Text ( \"System Fonts\" , font = nib . Font . HEADLINE ), nib . Text ( \"Large Title\" , font = nib . Font . LARGE_TITLE ), nib . Text ( \"Title\" , font = nib . Font . TITLE ), nib . Text ( \"Headline\" , font = nib . Font . HEADLINE ), nib . Text ( \"Body (default)\" , font = nib . Font . BODY ), nib . Text ( \"Caption\" , font = nib . Font . CAPTION ), nib . Divider (), # Weights nib . Text ( \"Font Weights\" , font = nib . Font . HEADLINE ), nib . Text ( \"Ultra Light\" , font = nib . Font . system ( 16 , nib . FontWeight . ULTRA_LIGHT )), nib . Text ( \"Light\" , font = nib . Font . system ( 16 , nib . FontWeight . LIGHT )), nib . Text ( \"Regular\" , font = nib . Font . system ( 16 , nib . FontWeight . REGULAR )), nib . Text ( \"Medium\" , font = nib . Font . system ( 16 , nib . FontWeight . MEDIUM )), nib . Text ( \"Bold\" , font = nib . Font . system ( 16 , nib . FontWeight . BOLD )), nib . Text ( \"Black\" , font = nib . Font . system ( 16 , nib . FontWeight . BLACK )), nib . Divider (), # Text decorations nib . Text ( \"Text Styles\" , font = nib . Font . HEADLINE ), nib . Text ( \"Bold\" , style = nib . TextStyle ( bold = True )), nib . Text ( \"Italic\" , style = nib . TextStyle ( italic = True )), nib . Text ( \"Underline\" , style = nib . TextStyle ( underline = True )), nib . Text ( \"Strikethrough\" , style = nib . TextStyle ( strikethrough = True )), nib . Text ( \"Monospaced\" , style = nib . TextStyle ( monospaced = True )), nib . Divider (), # Attributed string nib . Text ( \"Rich Text\" , font = nib . Font . HEADLINE ), nib . Text ( strings = [ nib . AttributedString ( \"Hello \" , color = \"blue\" ), nib . AttributedString ( \"World\" , style = nib . TextStyle ( bold = True , color = \"red\" )), nib . AttributedString ( \"!\" , font = nib . Font . TITLE ), ], ), ], spacing = 6 , alignment = nib . HorizontalAlignment . LEADING , padding = 16 , ), ], ) ) nib . run ( main )","title":"Full Example"},{"location":"reference/","text":"Complete reference for every class, function, and parameter in the Nib Python SDK. Each page documents the constructor, properties, methods, and includes working code examples. Sections \u00b6 Section Description Core Entry points, app lifecycle, menus, state management, settings, and file dialogs Views -- Controls Interactive and display controls: Text, Button, TextField, Toggle, Slider, Image, and more Views -- Layout Layout containers: VStack, HStack, ZStack, ScrollView, List, Grid, NavigationStack Views -- Shapes Shape primitives: Rectangle, Circle, Ellipse, Capsule, Path, and Gradients Views -- Charts Swift Charts integration: Chart, LineMark, BarMark, AreaMark, SectorMark, and more Views -- Effects Visual effects: VisualEffectBlur, Canvas Draw Module Canvas drawing primitives, paint, gradients, path elements, and image/text rendering Types & Enums Color, Font, Animation, Transition, TextStyle, alignment and style enums Services System services: Battery, Connectivity, Screen, Keychain, Camera, LaunchAtLogin, Permissions Notifications macOS notification system: Notification, NotificationManager, sounds, and actions Modifiers View modifiers for layout, appearance, typography, and effects Quick Example \u00b6 import nib def main ( app : nib . App ): app . title = \"My App\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . width = 300 app . height = 200 counter = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) app . build ( nib . VStack ( controls = [ counter , nib . Button ( \"Add\" , action = increment )], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Index"},{"location":"reference/#sections","text":"Section Description Core Entry points, app lifecycle, menus, state management, settings, and file dialogs Views -- Controls Interactive and display controls: Text, Button, TextField, Toggle, Slider, Image, and more Views -- Layout Layout containers: VStack, HStack, ZStack, ScrollView, List, Grid, NavigationStack Views -- Shapes Shape primitives: Rectangle, Circle, Ellipse, Capsule, Path, and Gradients Views -- Charts Swift Charts integration: Chart, LineMark, BarMark, AreaMark, SectorMark, and more Views -- Effects Visual effects: VisualEffectBlur, Canvas Draw Module Canvas drawing primitives, paint, gradients, path elements, and image/text rendering Types & Enums Color, Font, Animation, Transition, TextStyle, alignment and style enums Services System services: Battery, Connectivity, Screen, Keychain, Camera, LaunchAtLogin, Permissions Notifications macOS notification system: Notification, NotificationManager, sounds, and actions Modifiers View modifiers for layout, appearance, typography, and effects","title":"Sections"},{"location":"reference/#quick-example","text":"import nib def main ( app : nib . App ): app . title = \"My App\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . width = 300 app . height = 200 counter = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) app . build ( nib . VStack ( controls = [ counter , nib . Button ( \"Add\" , action = increment )], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Quick Example"},{"location":"reference/core/","text":"The core module contains the foundational classes and functions for building Nib menu bar applications. Entry Point \u00b6 Class / Function Description App Main application class that manages the lifecycle of a menu bar app run() Recommended entry point for function-based apps UI Primitives \u00b6 Class / Function Description SFSymbol Displays Apple SF Symbol icons in the menu bar or views MenuItem & MenuDivider Items for the right-click context menu on the status bar icon State Management \u00b6 Class / Function Description State & Binding Reactive state descriptor and two-way data binding for class-based apps Settings Persistent settings with sync cache and async UserDefaults persistence UserDefaults Low-level persistent key-value storage using macOS UserDefaults UI Configuration \u00b6 Class / Function Description SettingsPage & SettingsTab Tabbed preferences window following macOS conventions FilePicker Native macOS open/save file dialogs Quick Example \u00b6 import nib def main ( app : nib . App ): app . title = \"My App\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . width = 300 app . height = 200 counter = nib . Text ( \"0\" ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) app . build ( nib . VStack ( controls = [ counter , nib . Button ( \"Add\" , action = increment )], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Index"},{"location":"reference/core/#entry-point","text":"Class / Function Description App Main application class that manages the lifecycle of a menu bar app run() Recommended entry point for function-based apps","title":"Entry Point"},{"location":"reference/core/#ui-primitives","text":"Class / Function Description SFSymbol Displays Apple SF Symbol icons in the menu bar or views MenuItem & MenuDivider Items for the right-click context menu on the status bar icon","title":"UI Primitives"},{"location":"reference/core/#state-management","text":"Class / Function Description State & Binding Reactive state descriptor and two-way data binding for class-based apps Settings Persistent settings with sync cache and async UserDefaults persistence UserDefaults Low-level persistent key-value storage using macOS UserDefaults","title":"State Management"},{"location":"reference/core/#ui-configuration","text":"Class / Function Description SettingsPage & SettingsTab Tabbed preferences window following macOS conventions FilePicker Native macOS open/save file dialogs","title":"UI Configuration"},{"location":"reference/core/#quick-example","text":"import nib def main ( app : nib . App ): app . title = \"My App\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . width = 300 app . height = 200 counter = nib . Text ( \"0\" ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) app . build ( nib . VStack ( controls = [ counter , nib . Button ( \"Add\" , action = increment )], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Quick Example"},{"location":"reference/core/app/","text":"The main application class for Nib menu bar applications. App manages the entire lifecycle of a Nib application, including window configuration, view rendering, event handling, system integration, and communication with the Swift runtime. Constructor \u00b6 nib . App ( title = None , icon = None , identifier = None ) Parameters \u00b6 Parameter Type Default Description title str \\| None None Text displayed in the menu bar next to the icon icon str \\| SFSymbol \\| None None Menu bar icon. Pass an SF Symbol name string or an SFSymbol instance identifier str \\| None None Bundle identifier used for UserDefaults storage. Defaults to \"com.nib.<title>\" Properties \u00b6 Window and Appearance \u00b6 Property Type Description title str Text displayed in the menu bar. Readable and writable icon str \\| SFSymbol \\| View Menu bar icon. Accepts an SF Symbol name, SFSymbol instance, or any View identifier str Bundle identifier. If not set, derives from title as \"com.nib.<normalized_title>\" width float Popover window width in points height float Popover window height in points show_quit_item bool When True , appends a styled \"Quit\" button at the bottom of the app UI Menu and Fonts \u00b6 Property Type Description menu list[MenuItem] Right-click context menu items for the status bar icon fonts dict[str, str] Custom fonts registered for the app. Maps font names to file paths or URLs. Fonts placed in assets/fonts/ are auto-detected Lifecycle Callbacks \u00b6 Property Type Description on_appear Callable[[], None] Called every time the popover opens on_disappear Callable[[], None] Called every time the popover closes on_quit Callable[[], None] Called once when the app shuts down, before cleanup Settings \u00b6 Property Type Description settings SettingsPage Settings page configuration. When set, the preferences window is accessible via Cmd+, clipboard str Write-only setter for clipboard content. Use get_clipboard() for reading Service Properties (read-only) \u00b6 Property Type Description notifications NotificationManager Push, schedule, and manage macOS notifications battery Battery Read battery level and charging state connectivity Connectivity Check network connectivity status screen Screen Get display info and control brightness keychain Keychain Secure storage for passwords and tokens camera Camera List devices, capture photos, access video frames launch_at_login LaunchAtLogin Control whether the app starts on login permissions Permissions Check and request Camera, Microphone, and Notification permissions Methods \u00b6 View Management \u00b6 build(view) \u00b6 Set the root view of the application. If the app is already running, triggers an immediate re-render. app . build ( view : View ) -> None Parameter Type Description view View The root view to display in the popover body() \u00b6 Override this method in a subclass to define the UI. Returns the root view. Only used in the class-based approach. app . body () -> View update() \u00b6 Manually trigger a UI re-render. Use this to force an update when the automatic reactivity system might not detect a change, or to batch multiple changes into a single render pass. app . update () -> None Application Lifecycle \u00b6 run() \u00b6 Start the application. Connects to the Swift runtime, performs the initial render, and enters the main event loop. Blocks until the app quits. app . run () -> None quit() \u00b6 Quit the application and clean up resources. app . quit () -> None Notifications \u00b6 notify(title, body, subtitle, sound, identifier) \u00b6 Send a macOS system notification. app . notify ( title : str , body : str | None = None , subtitle : str | None = None , sound : bool = True , identifier : str | None = None , ) -> None Parameter Type Default Description title str -- Notification title (required) body str \\| None None Notification body text subtitle str \\| None None Subtitle shown below the title sound bool True Play the default notification sound identifier str \\| None None Unique ID for updating or removing the notification later Clipboard \u00b6 get_clipboard(callback) \u00b6 Read clipboard content asynchronously. The callback receives the clipboard string. app . get_clipboard ( callback : Callable [[ str ], None ]) -> None set_clipboard(content) \u00b6 Set clipboard content. Equivalent to app.clipboard = content . app . set_clipboard ( content : str ) -> None Hotkeys \u00b6 on_hotkey(shortcut, callback) \u00b6 Register a global keyboard shortcut. app . on_hotkey ( shortcut : str , callback : Callable [[], None ]) -> None Parameter Type Description shortcut str Key combination, e.g. \"cmd+shift+n\" , \"cmd+k\" callback Callable Function called when the hotkey is pressed hotkey(shortcut) \u00b6 Decorator form of on_hotkey . @app . hotkey ( \"cmd+shift+n\" ) def show_window (): pass Settings \u00b6 register_settings(settings) \u00b6 Register a Settings object for persistence. Connects the settings to UserDefaults and waits for initial values to load. app . register_settings ( settings : Settings ) -> None open_settings() \u00b6 Open the settings window programmatically. app . open_settings () -> None close_settings() \u00b6 Close the settings window programmatically. app . close_settings () -> None Class Methods \u00b6 set_assets_dir(path) \u00b6 Set the assets directory for the application. Relative paths are resolved from the main script directory. App . set_assets_dir ( path : str | Path | None ) -> None resolve_asset(relative_path) \u00b6 Resolve a relative asset path to an absolute path. Returns the input unchanged for absolute paths and URLs. Returns an empty string if the asset is not found. App . resolve_asset ( relative_path : str ) -> str Examples \u00b6 Function-based app (recommended) \u00b6 import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number.circle\" ) app . width = 280 app . height = 150 label = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): label . content = str ( int ( label . content ) + 1 ) app . build ( nib . VStack ( controls = [ label , nib . Button ( \"Increment\" , action = increment ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Class-based app \u00b6 import nib class CounterApp ( nib . App ): count = nib . State ( 0 ) def body ( self ): return nib . VStack ( controls = [ nib . Text ( f \"Count: { self . count } \" , font = nib . Font . TITLE ), nib . Button ( \"Increment\" , action = self . increment ), ], spacing = 12 , padding = 20 , ) def increment ( self ): self . count += 1 CounterApp ( title = \"Counter\" , icon = \"number.circle\" ) . run () Full-featured app with menu, hotkeys, and settings \u00b6 import nib def main ( app : nib . App ): app . title = \"Notes\" app . icon = nib . SFSymbol ( \"note.text\" ) app . width = 400 app . height = 300 settings = nib . Settings ({ \"dark_mode\" : False , \"font_size\" : 14 }) app . register_settings ( settings ) editor = nib . TextEditor ( text = \"\" , placeholder = \"Start typing...\" ) app . menu = [ nib . MenuItem ( \"Preferences\" , action = app . open_settings , icon = \"gear\" , shortcut = \"cmd+,\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] @app . hotkey ( \"cmd+shift+n\" ) def new_note (): editor . text = \"\" app . on_appear = lambda : print ( \"Popover opened\" ) app . build ( nib . VStack ( controls = [ editor ], padding = 16 , ) ) nib . run ( main ) Related \u00b6 run() -- Recommended entry point for function-based apps SFSymbol -- Menu bar icons MenuItem & MenuDivider -- Context menu items Settings -- Persistent settings SettingsPage -- Preferences window","title":"App"},{"location":"reference/core/app/#constructor","text":"nib . App ( title = None , icon = None , identifier = None )","title":"Constructor"},{"location":"reference/core/app/#parameters","text":"Parameter Type Default Description title str \\| None None Text displayed in the menu bar next to the icon icon str \\| SFSymbol \\| None None Menu bar icon. Pass an SF Symbol name string or an SFSymbol instance identifier str \\| None None Bundle identifier used for UserDefaults storage. Defaults to \"com.nib.<title>\"","title":"Parameters"},{"location":"reference/core/app/#properties","text":"","title":"Properties"},{"location":"reference/core/app/#window-and-appearance","text":"Property Type Description title str Text displayed in the menu bar. Readable and writable icon str \\| SFSymbol \\| View Menu bar icon. Accepts an SF Symbol name, SFSymbol instance, or any View identifier str Bundle identifier. If not set, derives from title as \"com.nib.<normalized_title>\" width float Popover window width in points height float Popover window height in points show_quit_item bool When True , appends a styled \"Quit\" button at the bottom of the app UI","title":"Window and Appearance"},{"location":"reference/core/app/#menu-and-fonts","text":"Property Type Description menu list[MenuItem] Right-click context menu items for the status bar icon fonts dict[str, str] Custom fonts registered for the app. Maps font names to file paths or URLs. Fonts placed in assets/fonts/ are auto-detected","title":"Menu and Fonts"},{"location":"reference/core/app/#lifecycle-callbacks","text":"Property Type Description on_appear Callable[[], None] Called every time the popover opens on_disappear Callable[[], None] Called every time the popover closes on_quit Callable[[], None] Called once when the app shuts down, before cleanup","title":"Lifecycle Callbacks"},{"location":"reference/core/app/#settings","text":"Property Type Description settings SettingsPage Settings page configuration. When set, the preferences window is accessible via Cmd+, clipboard str Write-only setter for clipboard content. Use get_clipboard() for reading","title":"Settings"},{"location":"reference/core/app/#service-properties-read-only","text":"Property Type Description notifications NotificationManager Push, schedule, and manage macOS notifications battery Battery Read battery level and charging state connectivity Connectivity Check network connectivity status screen Screen Get display info and control brightness keychain Keychain Secure storage for passwords and tokens camera Camera List devices, capture photos, access video frames launch_at_login LaunchAtLogin Control whether the app starts on login permissions Permissions Check and request Camera, Microphone, and Notification permissions","title":"Service Properties (read-only)"},{"location":"reference/core/app/#methods","text":"","title":"Methods"},{"location":"reference/core/app/#view-management","text":"","title":"View Management"},{"location":"reference/core/app/#buildview","text":"Set the root view of the application. If the app is already running, triggers an immediate re-render. app . build ( view : View ) -> None Parameter Type Description view View The root view to display in the popover","title":"build(view)"},{"location":"reference/core/app/#body","text":"Override this method in a subclass to define the UI. Returns the root view. Only used in the class-based approach. app . body () -> View","title":"body()"},{"location":"reference/core/app/#update","text":"Manually trigger a UI re-render. Use this to force an update when the automatic reactivity system might not detect a change, or to batch multiple changes into a single render pass. app . update () -> None","title":"update()"},{"location":"reference/core/app/#application-lifecycle","text":"","title":"Application Lifecycle"},{"location":"reference/core/app/#run","text":"Start the application. Connects to the Swift runtime, performs the initial render, and enters the main event loop. Blocks until the app quits. app . run () -> None","title":"run()"},{"location":"reference/core/app/#quit","text":"Quit the application and clean up resources. app . quit () -> None","title":"quit()"},{"location":"reference/core/app/#notifications","text":"","title":"Notifications"},{"location":"reference/core/app/#notifytitle-body-subtitle-sound-identifier","text":"Send a macOS system notification. app . notify ( title : str , body : str | None = None , subtitle : str | None = None , sound : bool = True , identifier : str | None = None , ) -> None Parameter Type Default Description title str -- Notification title (required) body str \\| None None Notification body text subtitle str \\| None None Subtitle shown below the title sound bool True Play the default notification sound identifier str \\| None None Unique ID for updating or removing the notification later","title":"notify(title, body, subtitle, sound, identifier)"},{"location":"reference/core/app/#clipboard","text":"","title":"Clipboard"},{"location":"reference/core/app/#get_clipboardcallback","text":"Read clipboard content asynchronously. The callback receives the clipboard string. app . get_clipboard ( callback : Callable [[ str ], None ]) -> None","title":"get_clipboard(callback)"},{"location":"reference/core/app/#set_clipboardcontent","text":"Set clipboard content. Equivalent to app.clipboard = content . app . set_clipboard ( content : str ) -> None","title":"set_clipboard(content)"},{"location":"reference/core/app/#hotkeys","text":"","title":"Hotkeys"},{"location":"reference/core/app/#on_hotkeyshortcut-callback","text":"Register a global keyboard shortcut. app . on_hotkey ( shortcut : str , callback : Callable [[], None ]) -> None Parameter Type Description shortcut str Key combination, e.g. \"cmd+shift+n\" , \"cmd+k\" callback Callable Function called when the hotkey is pressed","title":"on_hotkey(shortcut, callback)"},{"location":"reference/core/app/#hotkeyshortcut","text":"Decorator form of on_hotkey . @app . hotkey ( \"cmd+shift+n\" ) def show_window (): pass","title":"hotkey(shortcut)"},{"location":"reference/core/app/#settings_1","text":"","title":"Settings"},{"location":"reference/core/app/#register_settingssettings","text":"Register a Settings object for persistence. Connects the settings to UserDefaults and waits for initial values to load. app . register_settings ( settings : Settings ) -> None","title":"register_settings(settings)"},{"location":"reference/core/app/#open_settings","text":"Open the settings window programmatically. app . open_settings () -> None","title":"open_settings()"},{"location":"reference/core/app/#close_settings","text":"Close the settings window programmatically. app . close_settings () -> None","title":"close_settings()"},{"location":"reference/core/app/#class-methods","text":"","title":"Class Methods"},{"location":"reference/core/app/#set_assets_dirpath","text":"Set the assets directory for the application. Relative paths are resolved from the main script directory. App . set_assets_dir ( path : str | Path | None ) -> None","title":"set_assets_dir(path)"},{"location":"reference/core/app/#resolve_assetrelative_path","text":"Resolve a relative asset path to an absolute path. Returns the input unchanged for absolute paths and URLs. Returns an empty string if the asset is not found. App . resolve_asset ( relative_path : str ) -> str","title":"resolve_asset(relative_path)"},{"location":"reference/core/app/#examples","text":"","title":"Examples"},{"location":"reference/core/app/#function-based-app-recommended","text":"import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"number.circle\" ) app . width = 280 app . height = 150 label = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): label . content = str ( int ( label . content ) + 1 ) app . build ( nib . VStack ( controls = [ label , nib . Button ( \"Increment\" , action = increment ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Function-based app (recommended)"},{"location":"reference/core/app/#class-based-app","text":"import nib class CounterApp ( nib . App ): count = nib . State ( 0 ) def body ( self ): return nib . VStack ( controls = [ nib . Text ( f \"Count: { self . count } \" , font = nib . Font . TITLE ), nib . Button ( \"Increment\" , action = self . increment ), ], spacing = 12 , padding = 20 , ) def increment ( self ): self . count += 1 CounterApp ( title = \"Counter\" , icon = \"number.circle\" ) . run ()","title":"Class-based app"},{"location":"reference/core/app/#full-featured-app-with-menu-hotkeys-and-settings","text":"import nib def main ( app : nib . App ): app . title = \"Notes\" app . icon = nib . SFSymbol ( \"note.text\" ) app . width = 400 app . height = 300 settings = nib . Settings ({ \"dark_mode\" : False , \"font_size\" : 14 }) app . register_settings ( settings ) editor = nib . TextEditor ( text = \"\" , placeholder = \"Start typing...\" ) app . menu = [ nib . MenuItem ( \"Preferences\" , action = app . open_settings , icon = \"gear\" , shortcut = \"cmd+,\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] @app . hotkey ( \"cmd+shift+n\" ) def new_note (): editor . text = \"\" app . on_appear = lambda : print ( \"Popover opened\" ) app . build ( nib . VStack ( controls = [ editor ], padding = 16 , ) ) nib . run ( main )","title":"Full-featured app with menu, hotkeys, and settings"},{"location":"reference/core/app/#related","text":"run() -- Recommended entry point for function-based apps SFSymbol -- Menu bar icons MenuItem & MenuDivider -- Context menu items Settings -- Persistent settings SettingsPage -- Preferences window","title":"Related"},{"location":"reference/core/file-picker/","text":"Native macOS file picker dialogs for selecting and saving files. Wraps NSOpenPanel and NSSavePanel with full access to their configuration options. All methods are synchronous and block until the user makes a selection or cancels. Constructor \u00b6 nib . FilePicker ( app = None ) Parameters \u00b6 Parameter Type Default Description app App \\| None None The App instance to use. If None , uses the current running app set by nib.run() Methods \u00b6 pick_files(...) \u00b6 Open a file selection dialog. Returns a list of PickedFile objects, or None if the user cancels. picker . pick_files ( * , multiple = False , extensions = None , uttypes = None , directory = None , title = \"Select Files\" , message = None , button_label = \"Open\" , shows_hidden_files = False , resolves_aliases = True , allows_other_file_types = False , treats_packages_as_directories = False , validator = None , ) -> list [ PickedFile ] | None Parameter Type Default Description multiple bool False Allow selecting multiple files extensions list[str] \\| None None Allowed file extensions, e.g. [\"png\", \"jpg\", \"gif\"] uttypes list[str] \\| None None Allowed Uniform Type Identifiers, e.g. [\"public.image\"] directory str \\| None None Initial directory path to open the dialog in title str \"Select Files\" Dialog window title message str \\| None None Prompt text displayed below the title bar button_label str \"Open\" Text for the confirmation button shows_hidden_files bool False Show hidden files (dotfiles) in the dialog resolves_aliases bool True Follow macOS alias files to their targets allows_other_file_types bool False Allow files outside the specified extensions / uttypes treats_packages_as_directories bool False Show .app bundles and packages as browsable folders validator Callable[[list[str]], str \\| None] \\| None None Validation function. Receives a list of selected paths. Return None if valid, or an error message string to reject the selection pick_directory(...) \u00b6 Open a directory selection dialog. Returns a list of directory path strings, or None if cancelled. picker . pick_directory ( * , multiple = False , directory = None , title = \"Select Folder\" , message = None , button_label = \"Select\" , shows_hidden_files = False , resolves_aliases = True , can_create_directories = True , validator = None , ) -> list [ str ] | None Parameter Type Default Description multiple bool False Allow selecting multiple directories directory str \\| None None Initial directory path title str \"Select Folder\" Dialog window title message str \\| None None Prompt text below the title bar button_label str \"Select\" Text for the confirmation button shows_hidden_files bool False Show hidden files resolves_aliases bool True Follow alias files can_create_directories bool True Allow creating new folders in the dialog validator Callable[[list[str]], str \\| None] \\| None None Validation function. Receives selected directory paths. Return None if valid, or an error message to reject save_file(...) \u00b6 Open a save file dialog. Returns a SaveResult , or None if cancelled. picker . save_file ( * , filename = None , extensions = None , uttypes = None , directory = None , title = \"Save File\" , message = None , button_label = \"Save\" , name_field_label = \"Save As:\" , shows_hidden_files = False , can_create_directories = True , allows_other_file_types = False , shows_tag_field = True , validator = None , ) -> SaveResult | None Parameter Type Default Description filename str \\| None None Suggested filename pre-filled in the dialog extensions list[str] \\| None None Allowed file extensions uttypes list[str] \\| None None Allowed Uniform Type Identifiers directory str \\| None None Initial directory path title str \"Save File\" Dialog window title message str \\| None None Prompt text below the title bar button_label str \"Save\" Text for the save button name_field_label str \"Save As:\" Label for the filename text field shows_hidden_files bool False Show hidden files can_create_directories bool True Allow creating new folders allows_other_file_types bool False Allow extensions outside the allowed list shows_tag_field bool True Show the macOS Finder tags selector validator Callable[[str], str \\| None] \\| None None Validation function. Receives the chosen path. Return None if valid, or an error message to reject Data Classes \u00b6 PickedFile \u00b6 Represents a file selected by the user. @dataclass class PickedFile : name : str path : str size : int uti : str | None tags : list [ str ] Field Type Description name str Filename, e.g. \"photo.png\" path str Full absolute file path size int File size in bytes uti str \\| None Uniform Type Identifier, e.g. \"public.png\" tags list[str] macOS Finder tags assigned to the file SaveResult \u00b6 Result from a save file dialog. @dataclass class SaveResult : path : str tags : list [ str ] Field Type Description path str The chosen save path tags list[str] Finder tags selected by the user in the dialog Examples \u00b6 Picking image files \u00b6 import nib def main ( app : nib . App ): app . title = \"Image Picker\" app . icon = nib . SFSymbol ( \"photo\" ) app . width = 350 app . height = 200 result_label = nib . Text ( \"No file selected\" , font = nib . Font . BODY ) picker = nib . FilePicker () def select_images (): files = picker . pick_files ( multiple = True , extensions = [ \"png\" , \"jpg\" , \"jpeg\" , \"gif\" ], title = \"Select Images\" , message = \"Choose one or more image files\" , ) if files : names = \", \" . join ( f . name for f in files ) total_size = sum ( f . size for f in files ) result_label . content = f \" { len ( files ) } files ( { total_size } bytes): { names } \" else : result_label . content = \"Selection cancelled\" app . build ( nib . VStack ( controls = [ result_label , nib . Button ( \"Select Images\" , action = select_images ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Saving a file \u00b6 import nib def main ( app : nib . App ): app . title = \"Save Demo\" app . icon = nib . SFSymbol ( \"square.and.arrow.down\" ) app . width = 350 app . height = 150 info = nib . Text ( \"Click save to choose a location\" , font = nib . Font . BODY ) picker = nib . FilePicker () def save (): result = picker . save_file ( filename = \"report.txt\" , extensions = [ \"txt\" , \"md\" ], title = \"Save Report\" , message = \"Choose where to save the report\" , ) if result : info . content = f \"Saved to: { result . path } \" # Write the file with open ( result . path , \"w\" ) as f : f . write ( \"Hello from Nib!\" ) else : info . content = \"Save cancelled\" app . build ( nib . VStack ( controls = [ info , nib . Button ( \"Save Report\" , action = save )], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Picking a directory \u00b6 import nib import os def main ( app : nib . App ): app . title = \"Folder Picker\" app . icon = nib . SFSymbol ( \"folder\" ) app . width = 400 app . height = 200 info = nib . Text ( \"No folder selected\" ) picker = nib . FilePicker () def select_folder (): dirs = picker . pick_directory ( title = \"Select Output Folder\" , message = \"Files will be exported here\" , can_create_directories = True , ) if dirs : path = dirs [ 0 ] file_count = len ( os . listdir ( path )) info . content = f \"Selected: { path } ( { file_count } items)\" else : info . content = \"No folder selected\" app . build ( nib . VStack ( controls = [ info , nib . Button ( \"Choose Folder\" , action = select_folder )], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Related \u00b6 App -- The app.open_file_dialog() and app.save_file_dialog() convenience methods UserDefaults -- For persisting file paths or recent selections","title":"FilePicker"},{"location":"reference/core/file-picker/#constructor","text":"nib . FilePicker ( app = None )","title":"Constructor"},{"location":"reference/core/file-picker/#parameters","text":"Parameter Type Default Description app App \\| None None The App instance to use. If None , uses the current running app set by nib.run()","title":"Parameters"},{"location":"reference/core/file-picker/#methods","text":"","title":"Methods"},{"location":"reference/core/file-picker/#pick_files","text":"Open a file selection dialog. Returns a list of PickedFile objects, or None if the user cancels. picker . pick_files ( * , multiple = False , extensions = None , uttypes = None , directory = None , title = \"Select Files\" , message = None , button_label = \"Open\" , shows_hidden_files = False , resolves_aliases = True , allows_other_file_types = False , treats_packages_as_directories = False , validator = None , ) -> list [ PickedFile ] | None Parameter Type Default Description multiple bool False Allow selecting multiple files extensions list[str] \\| None None Allowed file extensions, e.g. [\"png\", \"jpg\", \"gif\"] uttypes list[str] \\| None None Allowed Uniform Type Identifiers, e.g. [\"public.image\"] directory str \\| None None Initial directory path to open the dialog in title str \"Select Files\" Dialog window title message str \\| None None Prompt text displayed below the title bar button_label str \"Open\" Text for the confirmation button shows_hidden_files bool False Show hidden files (dotfiles) in the dialog resolves_aliases bool True Follow macOS alias files to their targets allows_other_file_types bool False Allow files outside the specified extensions / uttypes treats_packages_as_directories bool False Show .app bundles and packages as browsable folders validator Callable[[list[str]], str \\| None] \\| None None Validation function. Receives a list of selected paths. Return None if valid, or an error message string to reject the selection","title":"pick_files(...)"},{"location":"reference/core/file-picker/#pick_directory","text":"Open a directory selection dialog. Returns a list of directory path strings, or None if cancelled. picker . pick_directory ( * , multiple = False , directory = None , title = \"Select Folder\" , message = None , button_label = \"Select\" , shows_hidden_files = False , resolves_aliases = True , can_create_directories = True , validator = None , ) -> list [ str ] | None Parameter Type Default Description multiple bool False Allow selecting multiple directories directory str \\| None None Initial directory path title str \"Select Folder\" Dialog window title message str \\| None None Prompt text below the title bar button_label str \"Select\" Text for the confirmation button shows_hidden_files bool False Show hidden files resolves_aliases bool True Follow alias files can_create_directories bool True Allow creating new folders in the dialog validator Callable[[list[str]], str \\| None] \\| None None Validation function. Receives selected directory paths. Return None if valid, or an error message to reject","title":"pick_directory(...)"},{"location":"reference/core/file-picker/#save_file","text":"Open a save file dialog. Returns a SaveResult , or None if cancelled. picker . save_file ( * , filename = None , extensions = None , uttypes = None , directory = None , title = \"Save File\" , message = None , button_label = \"Save\" , name_field_label = \"Save As:\" , shows_hidden_files = False , can_create_directories = True , allows_other_file_types = False , shows_tag_field = True , validator = None , ) -> SaveResult | None Parameter Type Default Description filename str \\| None None Suggested filename pre-filled in the dialog extensions list[str] \\| None None Allowed file extensions uttypes list[str] \\| None None Allowed Uniform Type Identifiers directory str \\| None None Initial directory path title str \"Save File\" Dialog window title message str \\| None None Prompt text below the title bar button_label str \"Save\" Text for the save button name_field_label str \"Save As:\" Label for the filename text field shows_hidden_files bool False Show hidden files can_create_directories bool True Allow creating new folders allows_other_file_types bool False Allow extensions outside the allowed list shows_tag_field bool True Show the macOS Finder tags selector validator Callable[[str], str \\| None] \\| None None Validation function. Receives the chosen path. Return None if valid, or an error message to reject","title":"save_file(...)"},{"location":"reference/core/file-picker/#data-classes","text":"","title":"Data Classes"},{"location":"reference/core/file-picker/#pickedfile","text":"Represents a file selected by the user. @dataclass class PickedFile : name : str path : str size : int uti : str | None tags : list [ str ] Field Type Description name str Filename, e.g. \"photo.png\" path str Full absolute file path size int File size in bytes uti str \\| None Uniform Type Identifier, e.g. \"public.png\" tags list[str] macOS Finder tags assigned to the file","title":"PickedFile"},{"location":"reference/core/file-picker/#saveresult","text":"Result from a save file dialog. @dataclass class SaveResult : path : str tags : list [ str ] Field Type Description path str The chosen save path tags list[str] Finder tags selected by the user in the dialog","title":"SaveResult"},{"location":"reference/core/file-picker/#examples","text":"","title":"Examples"},{"location":"reference/core/file-picker/#picking-image-files","text":"import nib def main ( app : nib . App ): app . title = \"Image Picker\" app . icon = nib . SFSymbol ( \"photo\" ) app . width = 350 app . height = 200 result_label = nib . Text ( \"No file selected\" , font = nib . Font . BODY ) picker = nib . FilePicker () def select_images (): files = picker . pick_files ( multiple = True , extensions = [ \"png\" , \"jpg\" , \"jpeg\" , \"gif\" ], title = \"Select Images\" , message = \"Choose one or more image files\" , ) if files : names = \", \" . join ( f . name for f in files ) total_size = sum ( f . size for f in files ) result_label . content = f \" { len ( files ) } files ( { total_size } bytes): { names } \" else : result_label . content = \"Selection cancelled\" app . build ( nib . VStack ( controls = [ result_label , nib . Button ( \"Select Images\" , action = select_images ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Picking image files"},{"location":"reference/core/file-picker/#saving-a-file","text":"import nib def main ( app : nib . App ): app . title = \"Save Demo\" app . icon = nib . SFSymbol ( \"square.and.arrow.down\" ) app . width = 350 app . height = 150 info = nib . Text ( \"Click save to choose a location\" , font = nib . Font . BODY ) picker = nib . FilePicker () def save (): result = picker . save_file ( filename = \"report.txt\" , extensions = [ \"txt\" , \"md\" ], title = \"Save Report\" , message = \"Choose where to save the report\" , ) if result : info . content = f \"Saved to: { result . path } \" # Write the file with open ( result . path , \"w\" ) as f : f . write ( \"Hello from Nib!\" ) else : info . content = \"Save cancelled\" app . build ( nib . VStack ( controls = [ info , nib . Button ( \"Save Report\" , action = save )], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Saving a file"},{"location":"reference/core/file-picker/#picking-a-directory","text":"import nib import os def main ( app : nib . App ): app . title = \"Folder Picker\" app . icon = nib . SFSymbol ( \"folder\" ) app . width = 400 app . height = 200 info = nib . Text ( \"No folder selected\" ) picker = nib . FilePicker () def select_folder (): dirs = picker . pick_directory ( title = \"Select Output Folder\" , message = \"Files will be exported here\" , can_create_directories = True , ) if dirs : path = dirs [ 0 ] file_count = len ( os . listdir ( path )) info . content = f \"Selected: { path } ( { file_count } items)\" else : info . content = \"No folder selected\" app . build ( nib . VStack ( controls = [ info , nib . Button ( \"Choose Folder\" , action = select_folder )], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Picking a directory"},{"location":"reference/core/file-picker/#related","text":"App -- The app.open_file_dialog() and app.save_file_dialog() convenience methods UserDefaults -- For persisting file paths or recent selections","title":"Related"},{"location":"reference/core/menu/","text":"Classes for building the right-click context menu on the status bar icon. MenuItem represents a clickable entry with optional icons, shortcuts, submenus, and custom view content. MenuDivider inserts a horizontal separator line between items. MenuItem \u00b6 Constructor \u00b6 nib . MenuItem ( title = None , action = None , icon = None , content = None , menu = None , shortcut = None , state = None , badge = None , enabled = True , height = None , ) Parameters \u00b6 Parameter Type Default Description title str \\| None None The menu item text. Optional if content is provided action Callable[[], None] \\| None None Callback invoked when the item is clicked icon str \\| SFSymbol \\| None None SF Symbol name as a string (e.g. \"gear\" ) or an SFSymbol instance with full configuration content View \\| None None Custom view for rich menu item content. Replaces title and icon when provided menu list[MenuItem] \\| None None Child items to create a submenu shortcut str \\| None None Keyboard shortcut displayed next to the item, e.g. \"cmd+q\" , \"cmd+shift+n\" , \"opt+x\" state str \\| None None Checkmark state indicator. \"on\" shows a checkmark, \"off\" shows nothing, \"mixed\" shows a dash badge str \\| None None Badge text shown on the right side of the item (macOS 14+) enabled bool True Whether the item is clickable. Disabled items appear grayed out height float \\| None None Custom height in points for content-based items. Default is auto-sized Properties \u00b6 All constructor parameters are stored as public instance attributes and can be read directly: Property Type Description title str \\| None The menu item text action Callable \\| None Click callback icon str \\| SFSymbol \\| None Icon configuration content View \\| None Custom view content menu list[MenuItem] Submenu items (empty list if none) shortcut str \\| None Keyboard shortcut string state str \\| None Checkmark state badge str \\| None Badge text enabled bool Whether the item is enabled height float \\| None Custom height MenuDivider \u00b6 A horizontal separator line between menu items. Takes no parameters. Constructor \u00b6 nib . MenuDivider () Examples \u00b6 Basic context menu \u00b6 import nib def main ( app : nib . App ): app . title = \"My App\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . width = 300 app . height = 200 def open_settings (): print ( \"Opening settings\" ) app . menu = [ nib . MenuItem ( \"Settings\" , action = open_settings , icon = \"gear\" , shortcut = \"cmd+,\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] app . build ( nib . Text ( \"Right-click the menu bar icon\" , padding = 20 )) nib . run ( main ) Submenus and state indicators \u00b6 import nib def main ( app : nib . App ): app . title = \"Editor\" app . icon = nib . SFSymbol ( \"doc.text\" ) app . width = 300 app . height = 200 current_theme = \"light\" def set_theme ( name ): nonlocal current_theme current_theme = name print ( f \"Theme set to { name } \" ) app . menu = [ nib . MenuItem ( \"Theme\" , icon = \"paintbrush\" , menu = [ nib . MenuItem ( \"Light\" , action = lambda : set_theme ( \"light\" ), state = \"on\" if current_theme == \"light\" else \"off\" , ), nib . MenuItem ( \"Dark\" , action = lambda : set_theme ( \"dark\" ), state = \"on\" if current_theme == \"dark\" else \"off\" , ), ], ), nib . MenuItem ( \"Export\" , icon = \"square.and.arrow.up\" , badge = \"New\" ), nib . MenuItem ( \"Disabled Item\" , enabled = False ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit ), ] app . build ( nib . Text ( \"Right-click for menu\" , padding = 20 )) nib . run ( main ) Custom view content in menu items \u00b6 import nib def main ( app : nib . App ): app . title = \"Pro App\" app . icon = nib . SFSymbol ( \"sparkles\" ) app . width = 300 app . height = 200 def upgrade (): print ( \"Upgrade clicked\" ) app . menu = [ nib . MenuItem ( content = nib . HStack ( controls = [ nib . SFSymbol ( \"star.fill\" , foreground_color = nib . Color . YELLOW ), nib . VStack ( controls = [ nib . Text ( \"Upgrade to Pro\" , font = nib . Font . HEADLINE ), nib . Text ( \"Unlock all features\" , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), ], spacing = 8 , ), action = upgrade , height = 50 , ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] app . build ( nib . Text ( \"Custom menu items\" , padding = 20 )) nib . run ( main ) Related \u00b6 App -- Set the menu via app.menu SFSymbol -- Used for menu item icons","title":"MenuItem & MenuDivider"},{"location":"reference/core/menu/#menuitem","text":"","title":"MenuItem"},{"location":"reference/core/menu/#constructor","text":"nib . MenuItem ( title = None , action = None , icon = None , content = None , menu = None , shortcut = None , state = None , badge = None , enabled = True , height = None , )","title":"Constructor"},{"location":"reference/core/menu/#parameters","text":"Parameter Type Default Description title str \\| None None The menu item text. Optional if content is provided action Callable[[], None] \\| None None Callback invoked when the item is clicked icon str \\| SFSymbol \\| None None SF Symbol name as a string (e.g. \"gear\" ) or an SFSymbol instance with full configuration content View \\| None None Custom view for rich menu item content. Replaces title and icon when provided menu list[MenuItem] \\| None None Child items to create a submenu shortcut str \\| None None Keyboard shortcut displayed next to the item, e.g. \"cmd+q\" , \"cmd+shift+n\" , \"opt+x\" state str \\| None None Checkmark state indicator. \"on\" shows a checkmark, \"off\" shows nothing, \"mixed\" shows a dash badge str \\| None None Badge text shown on the right side of the item (macOS 14+) enabled bool True Whether the item is clickable. Disabled items appear grayed out height float \\| None None Custom height in points for content-based items. Default is auto-sized","title":"Parameters"},{"location":"reference/core/menu/#properties","text":"All constructor parameters are stored as public instance attributes and can be read directly: Property Type Description title str \\| None The menu item text action Callable \\| None Click callback icon str \\| SFSymbol \\| None Icon configuration content View \\| None Custom view content menu list[MenuItem] Submenu items (empty list if none) shortcut str \\| None Keyboard shortcut string state str \\| None Checkmark state badge str \\| None Badge text enabled bool Whether the item is enabled height float \\| None Custom height","title":"Properties"},{"location":"reference/core/menu/#menudivider","text":"A horizontal separator line between menu items. Takes no parameters.","title":"MenuDivider"},{"location":"reference/core/menu/#constructor_1","text":"nib . MenuDivider ()","title":"Constructor"},{"location":"reference/core/menu/#examples","text":"","title":"Examples"},{"location":"reference/core/menu/#basic-context-menu","text":"import nib def main ( app : nib . App ): app . title = \"My App\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . width = 300 app . height = 200 def open_settings (): print ( \"Opening settings\" ) app . menu = [ nib . MenuItem ( \"Settings\" , action = open_settings , icon = \"gear\" , shortcut = \"cmd+,\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] app . build ( nib . Text ( \"Right-click the menu bar icon\" , padding = 20 )) nib . run ( main )","title":"Basic context menu"},{"location":"reference/core/menu/#submenus-and-state-indicators","text":"import nib def main ( app : nib . App ): app . title = \"Editor\" app . icon = nib . SFSymbol ( \"doc.text\" ) app . width = 300 app . height = 200 current_theme = \"light\" def set_theme ( name ): nonlocal current_theme current_theme = name print ( f \"Theme set to { name } \" ) app . menu = [ nib . MenuItem ( \"Theme\" , icon = \"paintbrush\" , menu = [ nib . MenuItem ( \"Light\" , action = lambda : set_theme ( \"light\" ), state = \"on\" if current_theme == \"light\" else \"off\" , ), nib . MenuItem ( \"Dark\" , action = lambda : set_theme ( \"dark\" ), state = \"on\" if current_theme == \"dark\" else \"off\" , ), ], ), nib . MenuItem ( \"Export\" , icon = \"square.and.arrow.up\" , badge = \"New\" ), nib . MenuItem ( \"Disabled Item\" , enabled = False ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit ), ] app . build ( nib . Text ( \"Right-click for menu\" , padding = 20 )) nib . run ( main )","title":"Submenus and state indicators"},{"location":"reference/core/menu/#custom-view-content-in-menu-items","text":"import nib def main ( app : nib . App ): app . title = \"Pro App\" app . icon = nib . SFSymbol ( \"sparkles\" ) app . width = 300 app . height = 200 def upgrade (): print ( \"Upgrade clicked\" ) app . menu = [ nib . MenuItem ( content = nib . HStack ( controls = [ nib . SFSymbol ( \"star.fill\" , foreground_color = nib . Color . YELLOW ), nib . VStack ( controls = [ nib . Text ( \"Upgrade to Pro\" , font = nib . Font . HEADLINE ), nib . Text ( \"Unlock all features\" , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), ], spacing = 8 , ), action = upgrade , height = 50 , ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit , shortcut = \"cmd+q\" ), ] app . build ( nib . Text ( \"Custom menu items\" , padding = 20 )) nib . run ( main )","title":"Custom view content in menu items"},{"location":"reference/core/menu/#related","text":"App -- Set the menu via app.menu SFSymbol -- Used for menu item icons","title":"Related"},{"location":"reference/core/run/","text":"The recommended entry point for Nib applications. Creates an App instance, passes it to your main function for configuration, then starts the application event loop. Signature \u00b6 nib . run ( main : Callable [[ App ], None ], assets_dir : str | Path | None = None ) -> None Parameters \u00b6 Parameter Type Default Description main Callable[[App], None] -- A function that receives an App instance and configures it by setting properties and calling app.build() assets_dir str \\| Path \\| None None Path to the assets directory. When None , Nib auto-detects an assets/ folder relative to the script. Relative paths resolve from the main script directory Behavior \u00b6 If assets_dir is provided, calls App.set_assets_dir(assets_dir) . Creates a new App() instance. Registers it as the current app (for UserDefaults and FilePicker to use by default). Calls main(app) so you can configure the app. Calls app.run() to connect to the Swift runtime and enter the event loop. Cleans up when the app exits. Examples \u00b6 Basic usage \u00b6 import nib def main ( app : nib . App ): app . title = \"Hello\" app . icon = nib . SFSymbol ( \"hand.wave\" ) app . width = 300 app . height = 200 app . build ( nib . Text ( \"Hello, World!\" , font = nib . Font . TITLE , padding = 20 ) ) nib . run ( main ) With custom assets directory \u00b6 import nib def main ( app : nib . App ): app . title = \"Gallery\" app . icon = nib . SFSymbol ( \"photo\" ) app . width = 400 app . height = 300 # \"logo.png\" resolves to \"my_assets/logo.png\" app . build ( nib . Image ( source = \"logo.png\" , width = 200 , height = 200 ) ) nib . run ( main , assets_dir = \"my_assets\" ) Interactive counter \u00b6 import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"plus.circle\" ) app . width = 250 app . height = 120 counter = nib . Text ( \"0\" , font = nib . Font . LARGE_TITLE ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) app . build ( nib . VStack ( controls = [ counter , nib . Button ( \"Add\" , action = increment ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Related \u00b6 App -- The application class configured inside the main function SFSymbol -- Icons used for app.icon","title":"run()"},{"location":"reference/core/run/#signature","text":"nib . run ( main : Callable [[ App ], None ], assets_dir : str | Path | None = None ) -> None","title":"Signature"},{"location":"reference/core/run/#parameters","text":"Parameter Type Default Description main Callable[[App], None] -- A function that receives an App instance and configures it by setting properties and calling app.build() assets_dir str \\| Path \\| None None Path to the assets directory. When None , Nib auto-detects an assets/ folder relative to the script. Relative paths resolve from the main script directory","title":"Parameters"},{"location":"reference/core/run/#behavior","text":"If assets_dir is provided, calls App.set_assets_dir(assets_dir) . Creates a new App() instance. Registers it as the current app (for UserDefaults and FilePicker to use by default). Calls main(app) so you can configure the app. Calls app.run() to connect to the Swift runtime and enter the event loop. Cleans up when the app exits.","title":"Behavior"},{"location":"reference/core/run/#examples","text":"","title":"Examples"},{"location":"reference/core/run/#basic-usage","text":"import nib def main ( app : nib . App ): app . title = \"Hello\" app . icon = nib . SFSymbol ( \"hand.wave\" ) app . width = 300 app . height = 200 app . build ( nib . Text ( \"Hello, World!\" , font = nib . Font . TITLE , padding = 20 ) ) nib . run ( main )","title":"Basic usage"},{"location":"reference/core/run/#with-custom-assets-directory","text":"import nib def main ( app : nib . App ): app . title = \"Gallery\" app . icon = nib . SFSymbol ( \"photo\" ) app . width = 400 app . height = 300 # \"logo.png\" resolves to \"my_assets/logo.png\" app . build ( nib . Image ( source = \"logo.png\" , width = 200 , height = 200 ) ) nib . run ( main , assets_dir = \"my_assets\" )","title":"With custom assets directory"},{"location":"reference/core/run/#interactive-counter","text":"import nib def main ( app : nib . App ): app . title = \"Counter\" app . icon = nib . SFSymbol ( \"plus.circle\" ) app . width = 250 app . height = 120 counter = nib . Text ( \"0\" , font = nib . Font . LARGE_TITLE ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) app . build ( nib . VStack ( controls = [ counter , nib . Button ( \"Add\" , action = increment ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Interactive counter"},{"location":"reference/core/run/#related","text":"App -- The application class configured inside the main function SFSymbol -- Icons used for app.icon","title":"Related"},{"location":"reference/core/settings-page/","text":"Components for creating tabbed preferences windows that follow macOS conventions. SettingsPage defines the window, and SettingsTab defines each tab within it. The settings window is accessible via Cmd+, (standard macOS shortcut) or programmatically via the open() method. SettingsPage \u00b6 Constructor \u00b6 nib . SettingsPage ( tabs = None , content = None , width = 450 , height = 300 , title = \"Settings\" , ) Parameters \u00b6 Parameter Type Default Description tabs list[SettingsTab] \\| None None List of SettingsTab objects for a tabbed interface content View \\| None None Single view for a non-tabbed settings page. If provided without tabs , automatically wraps in a single \"General\" tab with a gear icon width float 450 Window width in points height float 300 Window height in points title str \"Settings\" Window title text Properties \u00b6 Property Type Description tabs list[SettingsTab] The list of tabs in the settings page content View \\| None Single content view (if provided at construction) width float Window width height float Window height title str Window title Methods \u00b6 open() \u00b6 Open the settings window programmatically. settings_page . open () -> None close() \u00b6 Close the settings window programmatically. settings_page . close () -> None SettingsTab \u00b6 Constructor \u00b6 nib . SettingsTab ( title , icon = None , content = None ) Parameters \u00b6 Parameter Type Default Description title str -- The tab title displayed in the tab bar icon str \\| None None SF Symbol name for the tab icon (e.g. \"gear\" , \"person\" , \"bell\" ) content View \\| None None The view displayed when this tab is selected Properties \u00b6 Property Type Description title str Tab title text icon str \\| None SF Symbol icon name content View \\| None Tab content view Examples \u00b6 Multi-tab settings page \u00b6 import nib def main ( app : nib . App ): app . title = \"My App\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . width = 300 app . height = 200 settings = nib . Settings ({ \"dark_mode\" : False , \"font_size\" : 14 , \"notifications\" : True , }) app . register_settings ( settings ) app . settings = nib . SettingsPage ( width = 500 , height = 400 , tabs = [ nib . SettingsTab ( \"General\" , icon = \"gear\" , content = nib . Form ( controls = [ nib . Toggle ( \"Dark Mode\" , is_on = settings . dark_mode , on_change = lambda v : setattr ( settings , \"dark_mode\" , v ), ), nib . Slider ( \"Font Size\" , value = settings . font_size , min_value = 10 , max_value = 24 , on_change = lambda v : settings . set ( \"font_size\" , int ( v )), ), ], ), ), nib . SettingsTab ( \"Notifications\" , icon = \"bell\" , content = nib . Form ( controls = [ nib . Toggle ( \"Enable Notifications\" , is_on = settings . notifications , on_change = lambda v : setattr ( settings , \"notifications\" , v ), ), ], ), ), ], ) app . menu = [ nib . MenuItem ( \"Settings\" , action = app . settings . open , icon = \"gear\" , shortcut = \"cmd+,\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit ), ] app . build ( nib . Text ( \"Right-click for settings\" , padding = 20 ) ) nib . run ( main ) Simple single-view settings (no tabs) \u00b6 import nib def main ( app : nib . App ): app . title = \"Simple App\" app . icon = nib . SFSymbol ( \"circle\" ) app . width = 300 app . height = 100 app . settings = nib . SettingsPage ( content = nib . VStack ( controls = [ nib . Text ( \"Preferences\" , font = nib . Font . HEADLINE ), nib . Toggle ( \"Enable feature\" , is_on = True ), ], spacing = 12 , padding = 20 , ), width = 400 , height = 200 , ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Hello!\" , padding = 10 ), nib . Button ( \"Open Settings\" , action = app . settings . open ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Opening settings from a button \u00b6 import nib def main ( app : nib . App ): app . title = \"App\" app . icon = nib . SFSymbol ( \"app\" ) app . width = 300 app . height = 150 app . settings = nib . SettingsPage ( tabs = [ nib . SettingsTab ( \"Account\" , icon = \"person.circle\" , content = nib . VStack ( controls = [ nib . TextField ( value = \"\" , placeholder = \"Username\" ), nib . SecureField ( placeholder = \"Password\" ), ], spacing = 10 , padding = 20 , ), ), nib . SettingsTab ( \"Advanced\" , icon = \"wrench.and.screwdriver\" , content = nib . VStack ( controls = [ nib . Toggle ( \"Debug Mode\" , is_on = False ), nib . Toggle ( \"Verbose Logging\" , is_on = False ), ], spacing = 10 , padding = 20 , ), ), ], ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Welcome\" , font = nib . Font . TITLE ), nib . Button ( content = nib . HStack ( controls = [ nib . SFSymbol ( \"gear\" ), nib . Text ( \"Preferences\" ), ], spacing = 6 , ), action = app . settings . open , ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Related \u00b6 App -- Assign via app.settings and use app.open_settings() / app.close_settings() Settings -- Persistent settings data that pairs with the settings UI MenuItem -- Add a \"Settings\" menu item that opens the preferences window","title":"SettingsPage & SettingsTab"},{"location":"reference/core/settings-page/#settingspage","text":"","title":"SettingsPage"},{"location":"reference/core/settings-page/#constructor","text":"nib . SettingsPage ( tabs = None , content = None , width = 450 , height = 300 , title = \"Settings\" , )","title":"Constructor"},{"location":"reference/core/settings-page/#parameters","text":"Parameter Type Default Description tabs list[SettingsTab] \\| None None List of SettingsTab objects for a tabbed interface content View \\| None None Single view for a non-tabbed settings page. If provided without tabs , automatically wraps in a single \"General\" tab with a gear icon width float 450 Window width in points height float 300 Window height in points title str \"Settings\" Window title text","title":"Parameters"},{"location":"reference/core/settings-page/#properties","text":"Property Type Description tabs list[SettingsTab] The list of tabs in the settings page content View \\| None Single content view (if provided at construction) width float Window width height float Window height title str Window title","title":"Properties"},{"location":"reference/core/settings-page/#methods","text":"","title":"Methods"},{"location":"reference/core/settings-page/#open","text":"Open the settings window programmatically. settings_page . open () -> None","title":"open()"},{"location":"reference/core/settings-page/#close","text":"Close the settings window programmatically. settings_page . close () -> None","title":"close()"},{"location":"reference/core/settings-page/#settingstab","text":"","title":"SettingsTab"},{"location":"reference/core/settings-page/#constructor_1","text":"nib . SettingsTab ( title , icon = None , content = None )","title":"Constructor"},{"location":"reference/core/settings-page/#parameters_1","text":"Parameter Type Default Description title str -- The tab title displayed in the tab bar icon str \\| None None SF Symbol name for the tab icon (e.g. \"gear\" , \"person\" , \"bell\" ) content View \\| None None The view displayed when this tab is selected","title":"Parameters"},{"location":"reference/core/settings-page/#properties_1","text":"Property Type Description title str Tab title text icon str \\| None SF Symbol icon name content View \\| None Tab content view","title":"Properties"},{"location":"reference/core/settings-page/#examples","text":"","title":"Examples"},{"location":"reference/core/settings-page/#multi-tab-settings-page","text":"import nib def main ( app : nib . App ): app . title = \"My App\" app . icon = nib . SFSymbol ( \"star.fill\" ) app . width = 300 app . height = 200 settings = nib . Settings ({ \"dark_mode\" : False , \"font_size\" : 14 , \"notifications\" : True , }) app . register_settings ( settings ) app . settings = nib . SettingsPage ( width = 500 , height = 400 , tabs = [ nib . SettingsTab ( \"General\" , icon = \"gear\" , content = nib . Form ( controls = [ nib . Toggle ( \"Dark Mode\" , is_on = settings . dark_mode , on_change = lambda v : setattr ( settings , \"dark_mode\" , v ), ), nib . Slider ( \"Font Size\" , value = settings . font_size , min_value = 10 , max_value = 24 , on_change = lambda v : settings . set ( \"font_size\" , int ( v )), ), ], ), ), nib . SettingsTab ( \"Notifications\" , icon = \"bell\" , content = nib . Form ( controls = [ nib . Toggle ( \"Enable Notifications\" , is_on = settings . notifications , on_change = lambda v : setattr ( settings , \"notifications\" , v ), ), ], ), ), ], ) app . menu = [ nib . MenuItem ( \"Settings\" , action = app . settings . open , icon = \"gear\" , shortcut = \"cmd+,\" ), nib . MenuDivider (), nib . MenuItem ( \"Quit\" , action = app . quit ), ] app . build ( nib . Text ( \"Right-click for settings\" , padding = 20 ) ) nib . run ( main )","title":"Multi-tab settings page"},{"location":"reference/core/settings-page/#simple-single-view-settings-no-tabs","text":"import nib def main ( app : nib . App ): app . title = \"Simple App\" app . icon = nib . SFSymbol ( \"circle\" ) app . width = 300 app . height = 100 app . settings = nib . SettingsPage ( content = nib . VStack ( controls = [ nib . Text ( \"Preferences\" , font = nib . Font . HEADLINE ), nib . Toggle ( \"Enable feature\" , is_on = True ), ], spacing = 12 , padding = 20 , ), width = 400 , height = 200 , ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Hello!\" , padding = 10 ), nib . Button ( \"Open Settings\" , action = app . settings . open ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Simple single-view settings (no tabs)"},{"location":"reference/core/settings-page/#opening-settings-from-a-button","text":"import nib def main ( app : nib . App ): app . title = \"App\" app . icon = nib . SFSymbol ( \"app\" ) app . width = 300 app . height = 150 app . settings = nib . SettingsPage ( tabs = [ nib . SettingsTab ( \"Account\" , icon = \"person.circle\" , content = nib . VStack ( controls = [ nib . TextField ( value = \"\" , placeholder = \"Username\" ), nib . SecureField ( placeholder = \"Password\" ), ], spacing = 10 , padding = 20 , ), ), nib . SettingsTab ( \"Advanced\" , icon = \"wrench.and.screwdriver\" , content = nib . VStack ( controls = [ nib . Toggle ( \"Debug Mode\" , is_on = False ), nib . Toggle ( \"Verbose Logging\" , is_on = False ), ], spacing = 10 , padding = 20 , ), ), ], ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Welcome\" , font = nib . Font . TITLE ), nib . Button ( content = nib . HStack ( controls = [ nib . SFSymbol ( \"gear\" ), nib . Text ( \"Preferences\" ), ], spacing = 6 , ), action = app . settings . open , ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Opening settings from a button"},{"location":"reference/core/settings-page/#related","text":"App -- Assign via app.settings and use app.open_settings() / app.close_settings() Settings -- Persistent settings data that pairs with the settings UI MenuItem -- Add a \"Settings\" menu item that opens the preferences window","title":"Related"},{"location":"reference/core/settings/","text":"Application settings manager with instant reads from a local cache and automatic background persistence to macOS UserDefaults. Provides attribute-style access via dot notation. Constructor \u00b6 nib . Settings ( defaults : dict [ str , Any ], on_load : Callable [[], None ] | None = None ) Parameters \u00b6 Parameter Type Default Description defaults dict[str, Any] -- Dictionary mapping setting names to their default values. These defaults are used when no saved value exists in UserDefaults on_load Callable[[], None] \\| None None Optional callback invoked when settings finish loading persisted values from UserDefaults Properties \u00b6 Property Type Description on_load Callable[[], None] \\| None Get or set the callback invoked when settings finish loading. If settings have already loaded, assigning a new callback invokes it immediately <setting_name> Any Any key defined in defaults is accessible as an attribute. Reading returns the cached value instantly; writing updates the cache and persists in the background Methods \u00b6 get(name, default) \u00b6 Get a setting value with an optional fallback. settings . get ( name : str , default : Any = None ) -> Any Parameter Type Default Description name str -- The setting name default Any None Value returned if the setting is not found set(name, value) \u00b6 Set a setting value. Alternative to attribute assignment. settings . set ( name : str , value : Any ) -> None Parameter Type Default Description name str -- The setting name (must be defined in defaults ) value Any -- The new value wait_for_load(timeout) \u00b6 Block until initial settings have been loaded from UserDefaults. Usually not needed since defaults are available immediately. settings . wait_for_load ( timeout : float = 5.0 ) -> bool Parameter Type Default Description timeout float 5.0 Maximum wait time in seconds Returns: True if loading completed, False if timed out. load(blocking, timeout) \u00b6 Trigger loading of persisted values from UserDefaults. Called automatically on first attribute access, but can be called explicitly for more control. settings . load ( blocking : bool = False , timeout : float = 2.0 ) -> None Parameter Type Default Description blocking bool False If True , waits for the load to complete before returning timeout float 2.0 Maximum wait time when blocking=True to_dict() \u00b6 Get all current settings as a plain dictionary. settings . to_dict () -> dict [ str , Any ] reset(name) \u00b6 Reset settings to their default values. settings . reset ( name : str | None = None ) -> None Parameter Type Default Description name str \\| None None Specific setting to reset. If None , resets all settings to defaults How It Works \u00b6 Cache layer : All reads go to an in-memory dictionary, so settings.dark_mode never blocks. Background persistence : Writes update the cache immediately, then fire-and-forget a message to the Swift runtime to persist in UserDefaults. Initial load : When registered with app.register_settings() , saved values are loaded from UserDefaults in a background thread and merged into the cache. The on_load callback fires when this completes. Attribute validation : Only keys defined in defaults can be read or written. Accessing an undefined key raises AttributeError . Examples \u00b6 Basic settings with persistence \u00b6 import nib def main ( app : nib . App ): app . title = \"Preferences Demo\" app . icon = nib . SFSymbol ( \"gear\" ) app . width = 350 app . height = 250 settings = nib . Settings ({ \"dark_mode\" : False , \"font_size\" : 14 , \"username\" : \"guest\" , }) app . register_settings ( settings ) status = nib . Text ( f \"User: { settings . username } , Font: { settings . font_size } pt\" ) def toggle_dark (): settings . dark_mode = not settings . dark_mode status . content = f \"Dark mode: { settings . dark_mode } \" app . build ( nib . VStack ( controls = [ status , nib . Button ( \"Toggle Dark Mode\" , action = toggle_dark ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Using on_load to update UI after persisted values load \u00b6 import nib def main ( app : nib . App ): app . title = \"Settings\" app . icon = nib . SFSymbol ( \"slider.horizontal.3\" ) app . width = 350 app . height = 200 label = nib . Text ( \"Loading...\" , font = nib . Font . HEADLINE ) settings = nib . Settings ( { \"volume\" : 50 , \"notifications\" : True }, on_load = lambda : setattr ( label , \"content\" , f \"Volume: { settings . volume } %\" ), ) app . register_settings ( settings ) def update_volume ( value ): settings . volume = int ( value ) label . content = f \"Volume: { settings . volume } %\" app . build ( nib . VStack ( controls = [ label , nib . Slider ( \"Volume\" , value = settings . volume , min_value = 0 , max_value = 100 , on_change = update_volume , ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Resetting settings \u00b6 import nib def main ( app : nib . App ): app . title = \"Reset Demo\" app . icon = nib . SFSymbol ( \"arrow.counterclockwise\" ) app . width = 300 app . height = 150 settings = nib . Settings ({ \"theme\" : \"light\" , \"volume\" : 50 }) app . register_settings ( settings ) info = nib . Text ( f \"Theme: { settings . theme } , Volume: { settings . volume } \" ) def reset_all (): settings . reset () info . content = f \"Theme: { settings . theme } , Volume: { settings . volume } \" def reset_theme (): settings . reset ( \"theme\" ) info . content = f \"Theme: { settings . theme } , Volume: { settings . volume } \" app . build ( nib . VStack ( controls = [ info , nib . Button ( \"Reset Theme\" , action = reset_theme ), nib . Button ( \"Reset All\" , action = reset_all ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Related \u00b6 App -- Register settings via app.register_settings() UserDefaults -- Low-level persistent storage used under the hood SettingsPage -- UI for a preferences window","title":"Settings"},{"location":"reference/core/settings/#constructor","text":"nib . Settings ( defaults : dict [ str , Any ], on_load : Callable [[], None ] | None = None )","title":"Constructor"},{"location":"reference/core/settings/#parameters","text":"Parameter Type Default Description defaults dict[str, Any] -- Dictionary mapping setting names to their default values. These defaults are used when no saved value exists in UserDefaults on_load Callable[[], None] \\| None None Optional callback invoked when settings finish loading persisted values from UserDefaults","title":"Parameters"},{"location":"reference/core/settings/#properties","text":"Property Type Description on_load Callable[[], None] \\| None Get or set the callback invoked when settings finish loading. If settings have already loaded, assigning a new callback invokes it immediately <setting_name> Any Any key defined in defaults is accessible as an attribute. Reading returns the cached value instantly; writing updates the cache and persists in the background","title":"Properties"},{"location":"reference/core/settings/#methods","text":"","title":"Methods"},{"location":"reference/core/settings/#getname-default","text":"Get a setting value with an optional fallback. settings . get ( name : str , default : Any = None ) -> Any Parameter Type Default Description name str -- The setting name default Any None Value returned if the setting is not found","title":"get(name, default)"},{"location":"reference/core/settings/#setname-value","text":"Set a setting value. Alternative to attribute assignment. settings . set ( name : str , value : Any ) -> None Parameter Type Default Description name str -- The setting name (must be defined in defaults ) value Any -- The new value","title":"set(name, value)"},{"location":"reference/core/settings/#wait_for_loadtimeout","text":"Block until initial settings have been loaded from UserDefaults. Usually not needed since defaults are available immediately. settings . wait_for_load ( timeout : float = 5.0 ) -> bool Parameter Type Default Description timeout float 5.0 Maximum wait time in seconds Returns: True if loading completed, False if timed out.","title":"wait_for_load(timeout)"},{"location":"reference/core/settings/#loadblocking-timeout","text":"Trigger loading of persisted values from UserDefaults. Called automatically on first attribute access, but can be called explicitly for more control. settings . load ( blocking : bool = False , timeout : float = 2.0 ) -> None Parameter Type Default Description blocking bool False If True , waits for the load to complete before returning timeout float 2.0 Maximum wait time when blocking=True","title":"load(blocking, timeout)"},{"location":"reference/core/settings/#to_dict","text":"Get all current settings as a plain dictionary. settings . to_dict () -> dict [ str , Any ]","title":"to_dict()"},{"location":"reference/core/settings/#resetname","text":"Reset settings to their default values. settings . reset ( name : str | None = None ) -> None Parameter Type Default Description name str \\| None None Specific setting to reset. If None , resets all settings to defaults","title":"reset(name)"},{"location":"reference/core/settings/#how-it-works","text":"Cache layer : All reads go to an in-memory dictionary, so settings.dark_mode never blocks. Background persistence : Writes update the cache immediately, then fire-and-forget a message to the Swift runtime to persist in UserDefaults. Initial load : When registered with app.register_settings() , saved values are loaded from UserDefaults in a background thread and merged into the cache. The on_load callback fires when this completes. Attribute validation : Only keys defined in defaults can be read or written. Accessing an undefined key raises AttributeError .","title":"How It Works"},{"location":"reference/core/settings/#examples","text":"","title":"Examples"},{"location":"reference/core/settings/#basic-settings-with-persistence","text":"import nib def main ( app : nib . App ): app . title = \"Preferences Demo\" app . icon = nib . SFSymbol ( \"gear\" ) app . width = 350 app . height = 250 settings = nib . Settings ({ \"dark_mode\" : False , \"font_size\" : 14 , \"username\" : \"guest\" , }) app . register_settings ( settings ) status = nib . Text ( f \"User: { settings . username } , Font: { settings . font_size } pt\" ) def toggle_dark (): settings . dark_mode = not settings . dark_mode status . content = f \"Dark mode: { settings . dark_mode } \" app . build ( nib . VStack ( controls = [ status , nib . Button ( \"Toggle Dark Mode\" , action = toggle_dark ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Basic settings with persistence"},{"location":"reference/core/settings/#using-on_load-to-update-ui-after-persisted-values-load","text":"import nib def main ( app : nib . App ): app . title = \"Settings\" app . icon = nib . SFSymbol ( \"slider.horizontal.3\" ) app . width = 350 app . height = 200 label = nib . Text ( \"Loading...\" , font = nib . Font . HEADLINE ) settings = nib . Settings ( { \"volume\" : 50 , \"notifications\" : True }, on_load = lambda : setattr ( label , \"content\" , f \"Volume: { settings . volume } %\" ), ) app . register_settings ( settings ) def update_volume ( value ): settings . volume = int ( value ) label . content = f \"Volume: { settings . volume } %\" app . build ( nib . VStack ( controls = [ label , nib . Slider ( \"Volume\" , value = settings . volume , min_value = 0 , max_value = 100 , on_change = update_volume , ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Using on_load to update UI after persisted values load"},{"location":"reference/core/settings/#resetting-settings","text":"import nib def main ( app : nib . App ): app . title = \"Reset Demo\" app . icon = nib . SFSymbol ( \"arrow.counterclockwise\" ) app . width = 300 app . height = 150 settings = nib . Settings ({ \"theme\" : \"light\" , \"volume\" : 50 }) app . register_settings ( settings ) info = nib . Text ( f \"Theme: { settings . theme } , Volume: { settings . volume } \" ) def reset_all (): settings . reset () info . content = f \"Theme: { settings . theme } , Volume: { settings . volume } \" def reset_theme (): settings . reset ( \"theme\" ) info . content = f \"Theme: { settings . theme } , Volume: { settings . volume } \" app . build ( nib . VStack ( controls = [ info , nib . Button ( \"Reset Theme\" , action = reset_theme ), nib . Button ( \"Reset All\" , action = reset_all ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Resetting settings"},{"location":"reference/core/settings/#related","text":"App -- Register settings via app.register_settings() UserDefaults -- Low-level persistent storage used under the hood SettingsPage -- UI for a preferences window","title":"Related"},{"location":"reference/core/sfsymbol/","text":"A view that displays an Apple SF Symbol icon. SF Symbols are a library of over 5,000 configurable icons designed for Apple platforms. SFSymbol inherits from View , so it supports all standard view modifiers. Browse available symbols at developer.apple.com/sf-symbols or using the SF Symbols app. Constructor \u00b6 nib . SFSymbol ( name , weight = None , scale = None , rendering_mode = None , # View modifiers width = None , height = None , padding = None , foreground_color = None , background = None , opacity = None , font = None , font_weight = None , ** kwargs , ) Parameters \u00b6 Parameter Type Default Description name str -- SF Symbol name, e.g. \"star.fill\" , \"gear\" , \"heart.circle\" weight str \\| None None Symbol weight. One of \"ultralight\" , \"thin\" , \"light\" , \"regular\" , \"medium\" , \"semibold\" , \"bold\" , \"heavy\" , \"black\" scale str \\| None None Symbol scale. One of \"small\" , \"medium\" , \"large\" rendering_mode SymbolRenderingMode \\| str \\| None None How colors are applied to the symbol. One of \"monochrome\" , \"hierarchical\" , \"palette\" , \"multicolor\" In addition to the parameters above, SFSymbol accepts all standard View modifiers as keyword arguments: Parameter Type Default Description width float \\| None None Fixed width in points height float \\| None None Fixed height in points padding float \\| dict \\| None None Padding around the symbol. Float for uniform, or dict with keys like \"top\" , \"bottom\" , \"horizontal\" , \"vertical\" foreground_color str \\| Color \\| None None Symbol color. Accepts a color name, hex string, or Color instance background str \\| Color \\| None None Background color opacity float \\| None None Opacity from 0.0 (transparent) to 1.0 (opaque) font Font \\| None None Font that influences the symbol's size font_weight str \\| FontWeight \\| None None Alternative way to set symbol weight Properties \u00b6 Property Type Description name str The SF Symbol name. Readable and writable Usage Contexts \u00b6 SFSymbol can be used in several contexts: Menu bar icon : app.icon = nib.SFSymbol(\"star.fill\") Inside views : As a child of any layout container Button content : nib.Button(content=nib.SFSymbol(\"plus\"), action=add) Menu item icon : nib.MenuItem(\"Settings\", icon=\"gear\") (pass a string directly) Examples \u00b6 Basic icon in a layout \u00b6 import nib def main ( app : nib . App ): app . icon = nib . SFSymbol ( \"star.fill\" ) app . width = 300 app . height = 100 app . build ( nib . HStack ( controls = [ nib . SFSymbol ( \"heart.fill\" , foreground_color = nib . Color . RED ), nib . Text ( \"Favorites\" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Styled symbol with weight, scale, and rendering mode \u00b6 import nib def main ( app : nib . App ): app . icon = nib . SFSymbol ( \"cloud.sun.rain.fill\" , rendering_mode = \"multicolor\" , ) app . width = 300 app . height = 200 app . build ( nib . VStack ( controls = [ nib . SFSymbol ( \"cloud.sun.rain.fill\" , weight = \"bold\" , scale = \"large\" , rendering_mode = nib . SymbolRenderingMode . MULTICOLOR , font = nib . Font . system ( 48 ), ), nib . Text ( \"Weather\" , font = nib . Font . HEADLINE ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Icon button row \u00b6 import nib def main ( app : nib . App ): app . icon = nib . SFSymbol ( \"square.grid.2x2\" ) app . width = 300 app . height = 80 def action ( name ): print ( f \"Tapped { name } \" ) app . build ( nib . HStack ( controls = [ nib . Button ( content = nib . SFSymbol ( \"square.and.arrow.up\" ), action = lambda : action ( \"share\" ), ), nib . Button ( content = nib . SFSymbol ( \"doc.on.doc\" ), action = lambda : action ( \"copy\" ), ), nib . Button ( content = nib . SFSymbol ( \"trash\" , foreground_color = nib . Color . RED ), action = lambda : action ( \"delete\" ), ), ], spacing = 16 , padding = 20 , ) ) nib . run ( main ) Related \u00b6 App -- Uses SFSymbol for the icon property MenuItem -- Accepts SF Symbol name strings for the icon parameter","title":"SFSymbol"},{"location":"reference/core/sfsymbol/#constructor","text":"nib . SFSymbol ( name , weight = None , scale = None , rendering_mode = None , # View modifiers width = None , height = None , padding = None , foreground_color = None , background = None , opacity = None , font = None , font_weight = None , ** kwargs , )","title":"Constructor"},{"location":"reference/core/sfsymbol/#parameters","text":"Parameter Type Default Description name str -- SF Symbol name, e.g. \"star.fill\" , \"gear\" , \"heart.circle\" weight str \\| None None Symbol weight. One of \"ultralight\" , \"thin\" , \"light\" , \"regular\" , \"medium\" , \"semibold\" , \"bold\" , \"heavy\" , \"black\" scale str \\| None None Symbol scale. One of \"small\" , \"medium\" , \"large\" rendering_mode SymbolRenderingMode \\| str \\| None None How colors are applied to the symbol. One of \"monochrome\" , \"hierarchical\" , \"palette\" , \"multicolor\" In addition to the parameters above, SFSymbol accepts all standard View modifiers as keyword arguments: Parameter Type Default Description width float \\| None None Fixed width in points height float \\| None None Fixed height in points padding float \\| dict \\| None None Padding around the symbol. Float for uniform, or dict with keys like \"top\" , \"bottom\" , \"horizontal\" , \"vertical\" foreground_color str \\| Color \\| None None Symbol color. Accepts a color name, hex string, or Color instance background str \\| Color \\| None None Background color opacity float \\| None None Opacity from 0.0 (transparent) to 1.0 (opaque) font Font \\| None None Font that influences the symbol's size font_weight str \\| FontWeight \\| None None Alternative way to set symbol weight","title":"Parameters"},{"location":"reference/core/sfsymbol/#properties","text":"Property Type Description name str The SF Symbol name. Readable and writable","title":"Properties"},{"location":"reference/core/sfsymbol/#usage-contexts","text":"SFSymbol can be used in several contexts: Menu bar icon : app.icon = nib.SFSymbol(\"star.fill\") Inside views : As a child of any layout container Button content : nib.Button(content=nib.SFSymbol(\"plus\"), action=add) Menu item icon : nib.MenuItem(\"Settings\", icon=\"gear\") (pass a string directly)","title":"Usage Contexts"},{"location":"reference/core/sfsymbol/#examples","text":"","title":"Examples"},{"location":"reference/core/sfsymbol/#basic-icon-in-a-layout","text":"import nib def main ( app : nib . App ): app . icon = nib . SFSymbol ( \"star.fill\" ) app . width = 300 app . height = 100 app . build ( nib . HStack ( controls = [ nib . SFSymbol ( \"heart.fill\" , foreground_color = nib . Color . RED ), nib . Text ( \"Favorites\" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Basic icon in a layout"},{"location":"reference/core/sfsymbol/#styled-symbol-with-weight-scale-and-rendering-mode","text":"import nib def main ( app : nib . App ): app . icon = nib . SFSymbol ( \"cloud.sun.rain.fill\" , rendering_mode = \"multicolor\" , ) app . width = 300 app . height = 200 app . build ( nib . VStack ( controls = [ nib . SFSymbol ( \"cloud.sun.rain.fill\" , weight = \"bold\" , scale = \"large\" , rendering_mode = nib . SymbolRenderingMode . MULTICOLOR , font = nib . Font . system ( 48 ), ), nib . Text ( \"Weather\" , font = nib . Font . HEADLINE ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Styled symbol with weight, scale, and rendering mode"},{"location":"reference/core/sfsymbol/#icon-button-row","text":"import nib def main ( app : nib . App ): app . icon = nib . SFSymbol ( \"square.grid.2x2\" ) app . width = 300 app . height = 80 def action ( name ): print ( f \"Tapped { name } \" ) app . build ( nib . HStack ( controls = [ nib . Button ( content = nib . SFSymbol ( \"square.and.arrow.up\" ), action = lambda : action ( \"share\" ), ), nib . Button ( content = nib . SFSymbol ( \"doc.on.doc\" ), action = lambda : action ( \"copy\" ), ), nib . Button ( content = nib . SFSymbol ( \"trash\" , foreground_color = nib . Color . RED ), action = lambda : action ( \"delete\" ), ), ], spacing = 16 , padding = 20 , ) ) nib . run ( main )","title":"Icon button row"},{"location":"reference/core/sfsymbol/#related","text":"App -- Uses SFSymbol for the icon property MenuItem -- Accepts SF Symbol name strings for the icon parameter","title":"Related"},{"location":"reference/core/state/","text":"Reactive state primitives for class-based Nib applications. State is a Python descriptor that automatically triggers UI re-renders when its value changes. Binding wraps getter/setter functions for two-way data flow between state and UI controls. For function-based apps, you typically mutate view properties directly (e.g. text.content = \"new\" ) instead of using State . State \u00b6 A descriptor that stores per-instance state and calls the owner's _trigger_rerender() method whenever the value changes. Constructor \u00b6 nib . State ( initial : T ) Parameters \u00b6 Parameter Type Default Description initial T -- The initial/default value for this state variable. Can be any type: int , str , bool , list , dict , etc. Behavior \u00b6 Declare as a class variable on an App subclass. Read and write using normal attribute access on the instance ( self.count ). When the value changes (compared with != ), a re-render is triggered automatically. The underlying value is stored in a mangled attribute ( _state_<name> ) to avoid conflicts. Accessing the descriptor from the class (not an instance) returns the State object itself. Binding \u00b6 A two-way binding that wraps a getter and setter function. Useful for controls that need to both read a value and write changes back to state. Constructor \u00b6 nib . Binding ( getter : Callable [[], T ], setter : Callable [[ T ], None ]) Parameters \u00b6 Parameter Type Default Description getter Callable[[], T] -- A function that returns the current value setter Callable[[T], None] -- A function that updates the value Properties \u00b6 Property Type Description value T Read/write access to the bound value. Getting calls the getter; setting calls the setter Examples \u00b6 Basic counter with State \u00b6 import nib class CounterApp ( nib . App ): count = nib . State ( 0 ) def body ( self ): return nib . VStack ( controls = [ nib . Text ( f \"Count: { self . count } \" , font = nib . Font . TITLE ), nib . HStack ( controls = [ nib . Button ( \"- 1\" , action = self . decrement ), nib . Button ( \"+ 1\" , action = self . increment ), ], spacing = 8 , ), ], spacing = 12 , padding = 20 , ) def increment ( self ): self . count += 1 def decrement ( self ): self . count -= 1 CounterApp ( title = \"Counter\" , icon = \"number.circle\" ) . run () Multiple state variables \u00b6 import nib class ProfileApp ( nib . App ): name = nib . State ( \"\" ) dark_mode = nib . State ( False ) font_size = nib . State ( 14 ) def body ( self ): return nib . VStack ( controls = [ nib . Text ( f \"Hello, { self . name or 'stranger' } !\" , font = nib . Font . TITLE ), nib . TextField ( value = self . name , placeholder = \"Your name\" , on_change = lambda v : setattr ( self , \"name\" , v ), ), nib . Toggle ( \"Dark Mode\" , is_on = self . dark_mode , on_change = lambda v : setattr ( self , \"dark_mode\" , v ), ), nib . Slider ( \"Font Size\" , value = self . font_size , min_value = 10 , max_value = 24 , on_change = lambda v : setattr ( self , \"font_size\" , v ), ), ], spacing = 10 , padding = 16 , ) ProfileApp ( title = \"Profile\" , icon = \"person.circle\" ) . run () Using Binding for two-way data flow \u00b6 import nib from nib import Binding class SearchApp ( nib . App ): query = nib . State ( \"\" ) def body ( self ): binding = Binding ( getter = lambda : self . query , setter = lambda v : setattr ( self , \"query\" , v ), ) results = [ item for item in [ \"Apple\" , \"Banana\" , \"Cherry\" ] if self . query . lower () in item . lower ()] if self . query else [] return nib . VStack ( controls = [ nib . TextField ( value = binding . value , placeholder = \"Search fruits...\" , on_change = binding . value . __class__ . __set__ , ), * [ nib . Text ( r ) for r in results ], ], spacing = 8 , padding = 16 , ) SearchApp ( title = \"Search\" , icon = \"magnifyingglass\" ) . run () Related \u00b6 App -- The base class that State descriptors are used with Settings -- Persistent settings (survives app restarts, unlike State )","title":"State & Binding"},{"location":"reference/core/state/#state","text":"A descriptor that stores per-instance state and calls the owner's _trigger_rerender() method whenever the value changes.","title":"State"},{"location":"reference/core/state/#constructor","text":"nib . State ( initial : T )","title":"Constructor"},{"location":"reference/core/state/#parameters","text":"Parameter Type Default Description initial T -- The initial/default value for this state variable. Can be any type: int , str , bool , list , dict , etc.","title":"Parameters"},{"location":"reference/core/state/#behavior","text":"Declare as a class variable on an App subclass. Read and write using normal attribute access on the instance ( self.count ). When the value changes (compared with != ), a re-render is triggered automatically. The underlying value is stored in a mangled attribute ( _state_<name> ) to avoid conflicts. Accessing the descriptor from the class (not an instance) returns the State object itself.","title":"Behavior"},{"location":"reference/core/state/#binding","text":"A two-way binding that wraps a getter and setter function. Useful for controls that need to both read a value and write changes back to state.","title":"Binding"},{"location":"reference/core/state/#constructor_1","text":"nib . Binding ( getter : Callable [[], T ], setter : Callable [[ T ], None ])","title":"Constructor"},{"location":"reference/core/state/#parameters_1","text":"Parameter Type Default Description getter Callable[[], T] -- A function that returns the current value setter Callable[[T], None] -- A function that updates the value","title":"Parameters"},{"location":"reference/core/state/#properties","text":"Property Type Description value T Read/write access to the bound value. Getting calls the getter; setting calls the setter","title":"Properties"},{"location":"reference/core/state/#examples","text":"","title":"Examples"},{"location":"reference/core/state/#basic-counter-with-state","text":"import nib class CounterApp ( nib . App ): count = nib . State ( 0 ) def body ( self ): return nib . VStack ( controls = [ nib . Text ( f \"Count: { self . count } \" , font = nib . Font . TITLE ), nib . HStack ( controls = [ nib . Button ( \"- 1\" , action = self . decrement ), nib . Button ( \"+ 1\" , action = self . increment ), ], spacing = 8 , ), ], spacing = 12 , padding = 20 , ) def increment ( self ): self . count += 1 def decrement ( self ): self . count -= 1 CounterApp ( title = \"Counter\" , icon = \"number.circle\" ) . run ()","title":"Basic counter with State"},{"location":"reference/core/state/#multiple-state-variables","text":"import nib class ProfileApp ( nib . App ): name = nib . State ( \"\" ) dark_mode = nib . State ( False ) font_size = nib . State ( 14 ) def body ( self ): return nib . VStack ( controls = [ nib . Text ( f \"Hello, { self . name or 'stranger' } !\" , font = nib . Font . TITLE ), nib . TextField ( value = self . name , placeholder = \"Your name\" , on_change = lambda v : setattr ( self , \"name\" , v ), ), nib . Toggle ( \"Dark Mode\" , is_on = self . dark_mode , on_change = lambda v : setattr ( self , \"dark_mode\" , v ), ), nib . Slider ( \"Font Size\" , value = self . font_size , min_value = 10 , max_value = 24 , on_change = lambda v : setattr ( self , \"font_size\" , v ), ), ], spacing = 10 , padding = 16 , ) ProfileApp ( title = \"Profile\" , icon = \"person.circle\" ) . run ()","title":"Multiple state variables"},{"location":"reference/core/state/#using-binding-for-two-way-data-flow","text":"import nib from nib import Binding class SearchApp ( nib . App ): query = nib . State ( \"\" ) def body ( self ): binding = Binding ( getter = lambda : self . query , setter = lambda v : setattr ( self , \"query\" , v ), ) results = [ item for item in [ \"Apple\" , \"Banana\" , \"Cherry\" ] if self . query . lower () in item . lower ()] if self . query else [] return nib . VStack ( controls = [ nib . TextField ( value = binding . value , placeholder = \"Search fruits...\" , on_change = binding . value . __class__ . __set__ , ), * [ nib . Text ( r ) for r in results ], ], spacing = 8 , padding = 16 , ) SearchApp ( title = \"Search\" , icon = \"magnifyingglass\" ) . run ()","title":"Using Binding for two-way data flow"},{"location":"reference/core/state/#related","text":"App -- The base class that State descriptors are used with Settings -- Persistent settings (survives app restarts, unlike State )","title":"Related"},{"location":"reference/core/user-defaults/","text":"Low-level persistent key-value storage using macOS UserDefaults. Values survive app restarts and are scoped to the application's bundle identifier. For most use cases, the higher-level Settings class is preferred. Use UserDefaults directly when you need fine-grained control over individual keys or when working outside the settings pattern. Constructor \u00b6 nib . UserDefaults ( app = None ) Parameters \u00b6 Parameter Type Default Description app App \\| None None The App instance to use for communication with the Swift runtime. If None , uses the current running app set by nib.run() Supported Value Types \u00b6 Python Type Description str Strings int Integers float Floating point numbers bool Booleans list Lists (must be JSON-serializable) dict Dictionaries (must be JSON-serializable) bytes Binary data (base64-encoded for transport) Methods \u00b6 set(key, value) \u00b6 Store a value under the given key. defaults . set ( key : str , value : Any ) -> None Parameter Type Description key str The key to store the value under value Any The value to store. Must be one of the supported types get(key, default, timeout) \u00b6 Retrieve a value by key. This is a blocking call that waits for a response from the Swift runtime. defaults . get ( key : str , default : Any = None , timeout : float = 5.0 ) -> Any Parameter Type Default Description key str -- The key to retrieve default Any None Value returned if the key is not found timeout float 5.0 Maximum wait time in seconds Returns: The stored value with its original Python type, or default if the key does not exist or the request times out. remove(key) \u00b6 Delete a key and its value. defaults . remove ( key : str ) -> None Parameter Type Description key str The key to remove clear() \u00b6 Remove all keys and values stored by this application. defaults . clear () -> None contains_key(key, timeout) \u00b6 Check whether a key exists. This is a blocking call. defaults . contains_key ( key : str , timeout : float = 5.0 ) -> bool Parameter Type Default Description key str -- The key to check timeout float 5.0 Maximum wait time in seconds Returns: True if the key exists, False otherwise. get_keys(prefix, timeout) \u00b6 Get all stored keys, optionally filtered by a prefix. This is a blocking call. defaults . get_keys ( prefix : str = \"\" , timeout : float = 5.0 ) -> list [ str ] Parameter Type Default Description prefix str \"\" Filter keys that start with this string. Pass \"\" for all keys timeout float 5.0 Maximum wait time in seconds Returns: List of matching key strings. Examples \u00b6 Storing and retrieving values \u00b6 import nib def main ( app : nib . App ): app . title = \"Storage\" app . icon = nib . SFSymbol ( \"externaldrive\" ) app . width = 300 app . height = 200 defaults = nib . UserDefaults () # Store different value types defaults . set ( \"username\" , \"alice\" ) defaults . set ( \"login_count\" , 42 ) defaults . set ( \"dark_mode\" , True ) defaults . set ( \"favorites\" , [ \"python\" , \"swift\" ]) # Retrieve values (blocking) username = defaults . get ( \"username\" , default = \"guest\" ) count = defaults . get ( \"login_count\" , default = 0 ) app . build ( nib . VStack ( controls = [ nib . Text ( f \"User: { username } \" ), nib . Text ( f \"Logins: { count } \" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Checking keys and listing stored data \u00b6 import nib def main ( app : nib . App ): app . title = \"Keys\" app . icon = nib . SFSymbol ( \"key\" ) app . width = 300 app . height = 250 defaults = nib . UserDefaults () # Store some prefixed keys defaults . set ( \"user.name\" , \"alice\" ) defaults . set ( \"user.email\" , \"alice@example.com\" ) defaults . set ( \"app.theme\" , \"dark\" ) # Check if a key exists has_name = defaults . contains_key ( \"user.name\" ) # Get all keys with a prefix user_keys = defaults . get_keys ( \"user.\" ) app . build ( nib . VStack ( controls = [ nib . Text ( f \"Has user.name: { has_name } \" ), nib . Text ( f \"User keys: { ', ' . join ( user_keys ) } \" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Tracking launch count \u00b6 import nib def main ( app : nib . App ): app . title = \"Launch Counter\" app . icon = nib . SFSymbol ( \"arrow.clockwise\" ) app . width = 300 app . height = 120 defaults = nib . UserDefaults () # Increment and persist launch count count = defaults . get ( \"launch_count\" , default = 0 ) count += 1 defaults . set ( \"launch_count\" , count ) def reset (): defaults . remove ( \"launch_count\" ) label . content = \"Launch count reset. Restart to see 1.\" label = nib . Text ( f \"This app has been launched { count } time(s).\" ) app . build ( nib . VStack ( controls = [ label , nib . Button ( \"Reset Counter\" , action = reset ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Related \u00b6 Settings -- Higher-level settings API with caching built on top of UserDefaults App -- The identifier property controls the UserDefaults storage scope","title":"UserDefaults"},{"location":"reference/core/user-defaults/#constructor","text":"nib . UserDefaults ( app = None )","title":"Constructor"},{"location":"reference/core/user-defaults/#parameters","text":"Parameter Type Default Description app App \\| None None The App instance to use for communication with the Swift runtime. If None , uses the current running app set by nib.run()","title":"Parameters"},{"location":"reference/core/user-defaults/#supported-value-types","text":"Python Type Description str Strings int Integers float Floating point numbers bool Booleans list Lists (must be JSON-serializable) dict Dictionaries (must be JSON-serializable) bytes Binary data (base64-encoded for transport)","title":"Supported Value Types"},{"location":"reference/core/user-defaults/#methods","text":"","title":"Methods"},{"location":"reference/core/user-defaults/#setkey-value","text":"Store a value under the given key. defaults . set ( key : str , value : Any ) -> None Parameter Type Description key str The key to store the value under value Any The value to store. Must be one of the supported types","title":"set(key, value)"},{"location":"reference/core/user-defaults/#getkey-default-timeout","text":"Retrieve a value by key. This is a blocking call that waits for a response from the Swift runtime. defaults . get ( key : str , default : Any = None , timeout : float = 5.0 ) -> Any Parameter Type Default Description key str -- The key to retrieve default Any None Value returned if the key is not found timeout float 5.0 Maximum wait time in seconds Returns: The stored value with its original Python type, or default if the key does not exist or the request times out.","title":"get(key, default, timeout)"},{"location":"reference/core/user-defaults/#removekey","text":"Delete a key and its value. defaults . remove ( key : str ) -> None Parameter Type Description key str The key to remove","title":"remove(key)"},{"location":"reference/core/user-defaults/#clear","text":"Remove all keys and values stored by this application. defaults . clear () -> None","title":"clear()"},{"location":"reference/core/user-defaults/#contains_keykey-timeout","text":"Check whether a key exists. This is a blocking call. defaults . contains_key ( key : str , timeout : float = 5.0 ) -> bool Parameter Type Default Description key str -- The key to check timeout float 5.0 Maximum wait time in seconds Returns: True if the key exists, False otherwise.","title":"contains_key(key, timeout)"},{"location":"reference/core/user-defaults/#get_keysprefix-timeout","text":"Get all stored keys, optionally filtered by a prefix. This is a blocking call. defaults . get_keys ( prefix : str = \"\" , timeout : float = 5.0 ) -> list [ str ] Parameter Type Default Description prefix str \"\" Filter keys that start with this string. Pass \"\" for all keys timeout float 5.0 Maximum wait time in seconds Returns: List of matching key strings.","title":"get_keys(prefix, timeout)"},{"location":"reference/core/user-defaults/#examples","text":"","title":"Examples"},{"location":"reference/core/user-defaults/#storing-and-retrieving-values","text":"import nib def main ( app : nib . App ): app . title = \"Storage\" app . icon = nib . SFSymbol ( \"externaldrive\" ) app . width = 300 app . height = 200 defaults = nib . UserDefaults () # Store different value types defaults . set ( \"username\" , \"alice\" ) defaults . set ( \"login_count\" , 42 ) defaults . set ( \"dark_mode\" , True ) defaults . set ( \"favorites\" , [ \"python\" , \"swift\" ]) # Retrieve values (blocking) username = defaults . get ( \"username\" , default = \"guest\" ) count = defaults . get ( \"login_count\" , default = 0 ) app . build ( nib . VStack ( controls = [ nib . Text ( f \"User: { username } \" ), nib . Text ( f \"Logins: { count } \" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Storing and retrieving values"},{"location":"reference/core/user-defaults/#checking-keys-and-listing-stored-data","text":"import nib def main ( app : nib . App ): app . title = \"Keys\" app . icon = nib . SFSymbol ( \"key\" ) app . width = 300 app . height = 250 defaults = nib . UserDefaults () # Store some prefixed keys defaults . set ( \"user.name\" , \"alice\" ) defaults . set ( \"user.email\" , \"alice@example.com\" ) defaults . set ( \"app.theme\" , \"dark\" ) # Check if a key exists has_name = defaults . contains_key ( \"user.name\" ) # Get all keys with a prefix user_keys = defaults . get_keys ( \"user.\" ) app . build ( nib . VStack ( controls = [ nib . Text ( f \"Has user.name: { has_name } \" ), nib . Text ( f \"User keys: { ', ' . join ( user_keys ) } \" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Checking keys and listing stored data"},{"location":"reference/core/user-defaults/#tracking-launch-count","text":"import nib def main ( app : nib . App ): app . title = \"Launch Counter\" app . icon = nib . SFSymbol ( \"arrow.clockwise\" ) app . width = 300 app . height = 120 defaults = nib . UserDefaults () # Increment and persist launch count count = defaults . get ( \"launch_count\" , default = 0 ) count += 1 defaults . set ( \"launch_count\" , count ) def reset (): defaults . remove ( \"launch_count\" ) label . content = \"Launch count reset. Restart to see 1.\" label = nib . Text ( f \"This app has been launched { count } time(s).\" ) app . build ( nib . VStack ( controls = [ label , nib . Button ( \"Reset Counter\" , action = reset ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Tracking launch count"},{"location":"reference/core/user-defaults/#related","text":"Settings -- Higher-level settings API with caching built on top of UserDefaults App -- The identifier property controls the UserDefaults storage scope","title":"Related"},{"location":"reference/draw/","text":"The nib.draw module provides declarative drawing commands for the Canvas view. Commands describe shapes, images, text, and paths that are rendered via Core Graphics on macOS with GPU acceleration. All drawing is performed through command objects that are passed to canvas.draw() , canvas.append() , or provided as the commands parameter on the Canvas constructor. Commands are dataclasses and can be freely created, stored, and reused. Sections \u00b6 Section Description Primitives Shape commands: Rect , Circle , Ellipse , Line , Arc , Path , Polygon , BezierPath , Points , Shadow , Fill , ColorFill . Paint & Gradients Paint styling class, PaintStyle , StrokeCap , StrokeJoin enums, and gradient fills: LinearGradient , RadialGradient , SweepGradient . Path Elements Typed path elements for BezierPath : MoveTo , LineTo , CubicTo , QuadraticTo , Close , ArcTo , Oval , SubPath . Image & Text Image (raw bytes) and Text drawing commands with font and alignment support. Quick example \u00b6 import nib def main ( app : nib . App ): canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#1e1e1e\" ) canvas . draw ([ # Rounded rectangle with gradient fill nib . draw . Rect ( x = 20 , y = 20 , width = 160 , height = 100 , fill = nib . draw . LinearGradient ( start = ( 20 , 20 ), end = ( 180 , 120 ), colors = [ \"#6366F1\" , \"#EC4899\" ], ), corner_radius = 12 , ), # Circle with radial gradient nib . draw . Circle ( cx = 300 , cy = 80 , radius = 50 , fill = nib . draw . RadialGradient ( center = ( 300 , 80 ), radius = 50 , colors = [ \"#FBBF24\" , \"#F97316\" ], ), ), # Connecting line nib . draw . Line ( x1 = 180 , y1 = 70 , x2 = 250 , y2 = 80 , stroke = \"#ffffff\" , stroke_width = 2 ), # Label nib . draw . Text ( \"Dashboard\" , x = 20 , y = 260 , fill = \"#ffffff\" ), ]) app . build ( canvas ) nib . run ( main ) Color values \u00b6 All color parameters in draw commands accept either: Hex strings : \"#FF0000\" , \"#ff0000\" , \"FF0000\" nib.Color objects : nib.Color.RED , nib.Color(hex=\"#FF0000\") Gradient fills ( LinearGradient , RadialGradient , SweepGradient ) can be used in place of solid colors on any fill parameter.","title":"Index"},{"location":"reference/draw/#sections","text":"Section Description Primitives Shape commands: Rect , Circle , Ellipse , Line , Arc , Path , Polygon , BezierPath , Points , Shadow , Fill , ColorFill . Paint & Gradients Paint styling class, PaintStyle , StrokeCap , StrokeJoin enums, and gradient fills: LinearGradient , RadialGradient , SweepGradient . Path Elements Typed path elements for BezierPath : MoveTo , LineTo , CubicTo , QuadraticTo , Close , ArcTo , Oval , SubPath . Image & Text Image (raw bytes) and Text drawing commands with font and alignment support.","title":"Sections"},{"location":"reference/draw/#quick-example","text":"import nib def main ( app : nib . App ): canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#1e1e1e\" ) canvas . draw ([ # Rounded rectangle with gradient fill nib . draw . Rect ( x = 20 , y = 20 , width = 160 , height = 100 , fill = nib . draw . LinearGradient ( start = ( 20 , 20 ), end = ( 180 , 120 ), colors = [ \"#6366F1\" , \"#EC4899\" ], ), corner_radius = 12 , ), # Circle with radial gradient nib . draw . Circle ( cx = 300 , cy = 80 , radius = 50 , fill = nib . draw . RadialGradient ( center = ( 300 , 80 ), radius = 50 , colors = [ \"#FBBF24\" , \"#F97316\" ], ), ), # Connecting line nib . draw . Line ( x1 = 180 , y1 = 70 , x2 = 250 , y2 = 80 , stroke = \"#ffffff\" , stroke_width = 2 ), # Label nib . draw . Text ( \"Dashboard\" , x = 20 , y = 260 , fill = \"#ffffff\" ), ]) app . build ( canvas ) nib . run ( main )","title":"Quick example"},{"location":"reference/draw/#color-values","text":"All color parameters in draw commands accept either: Hex strings : \"#FF0000\" , \"#ff0000\" , \"FF0000\" nib.Color objects : nib.Color.RED , nib.Color(hex=\"#FF0000\") Gradient fills ( LinearGradient , RadialGradient , SweepGradient ) can be used in place of solid colors on any fill parameter.","title":"Color values"},{"location":"reference/draw/image-text/","text":"Commands for drawing images and text on a Canvas . These complement the shape primitives by allowing raster content and typographic elements on the drawing surface. Text \u00b6 Draws a text string at a specified position on the canvas. Supports font configuration, color, alignment, and text styles. Constructor \u00b6 nib . draw . Text ( content , x , y , font = None , fill = \"#000000\" , alignment = \"left\" , opacity = 1.0 , style = None ) Parameters \u00b6 Parameter Type Default Description content str required The text string to draw. x float required X coordinate of the text origin. y float required Y coordinate of the text origin. font Font None Font configuration ( nib.Font instance). Uses system default when None . fill str \\| Color \"#000000\" Text color. Accepts hex strings or nib.Color objects. alignment HorizontalAlignment \\| str \"left\" Text alignment: \"left\" , \"center\" , or \"right\" . Also accepts nib.HorizontalAlignment enum values. opacity float 1.0 Opacity from 0.0 to 1.0. style TextStyle None Optional nib.TextStyle for additional styling (bold, italic, etc.). Examples \u00b6 Simple text \u00b6 import nib canvas = nib . Canvas ( width = 400 , height = 200 , background_color = \"#1e1e1e\" ) canvas . draw ([ nib . draw . Text ( \"Hello, Canvas!\" , x = 20 , y = 50 , fill = \"#ffffff\" ), ]) Styled text with font and color \u00b6 import nib canvas = nib . Canvas ( width = 400 , height = 200 ) canvas . draw ([ nib . draw . Text ( \"Bold Title\" , x = 200 , y = 50 , font = nib . Font . system ( 24 , weight = nib . FontWeight . BOLD ), fill = nib . Color . RED , alignment = nib . HorizontalAlignment . CENTER , ), nib . draw . Text ( \"Subtitle text\" , x = 200 , y = 90 , font = nib . Font . system ( 14 ), fill = \"#888888\" , alignment = \"center\" , ), ]) Multiple text elements \u00b6 import nib canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#f5f5f5\" ) canvas . draw ([ nib . draw . Text ( \"Left aligned\" , x = 20 , y = 40 , fill = \"#333333\" ), nib . draw . Text ( \"Center aligned\" , x = 200 , y = 80 , fill = \"#333333\" , alignment = \"center\" ), nib . draw . Text ( \"Right aligned\" , x = 380 , y = 120 , fill = \"#333333\" , alignment = \"right\" ), ]) Image \u00b6 Draws a raster image on the canvas from raw JPEG/PNG bytes. Images can be scaled to a specific width and height, or drawn at their original resolution. Constructor \u00b6 nib . draw . Image ( data , x = 0 , y = 0 , width = None , height = None , opacity = 1.0 ) Parameters \u00b6 Parameter Type Default Description data bytes required Raw image bytes (JPEG, PNG, or other formats supported by macOS). x float 0 X coordinate of the top-left corner. y float 0 Y coordinate of the top-left corner. width float None Width to draw the image. None uses the original image width. height float None Height to draw the image. None uses the original image height. opacity float 1.0 Opacity from 0.0 to 1.0. Examples \u00b6 Drawing from file \u00b6 import nib canvas = nib . Canvas ( width = 400 , height = 300 ) with open ( \"photo.jpg\" , \"rb\" ) as f : canvas . draw ([ nib . draw . Image ( data = f . read (), x = 0 , y = 0 ), ]) Scaled image \u00b6 import nib canvas = nib . Canvas ( width = 400 , height = 300 ) with open ( \"icon.png\" , \"rb\" ) as f : canvas . draw ([ nib . draw . Image ( data = f . read (), x = 10 , y = 10 , width = 200 , height = 150 ), ]) Semi-transparent overlay \u00b6 import nib canvas = nib . Canvas ( width = 400 , height = 300 ) with open ( \"background.jpg\" , \"rb\" ) as bg , open ( \"overlay.png\" , \"rb\" ) as fg : canvas . draw ([ nib . draw . Image ( data = bg . read (), x = 0 , y = 0 , width = 400 , height = 300 ), nib . draw . Image ( data = fg . read (), x = 50 , y = 50 , width = 100 , height = 100 , opacity = 0.6 ), ]) Using PIL/Pillow \u00b6 import nib import io from PIL import Image as PILImage canvas = nib . Canvas ( width = 400 , height = 300 ) img = PILImage . open ( \"photo.jpg\" ) img = img . resize (( 200 , 150 )) buffer = io . BytesIO () img . save ( buffer , format = \"JPEG\" ) canvas . draw ([ nib . draw . Image ( data = buffer . getvalue (), x = 100 , y = 75 ), ])","title":"Image & Text"},{"location":"reference/draw/image-text/#text","text":"Draws a text string at a specified position on the canvas. Supports font configuration, color, alignment, and text styles.","title":"Text"},{"location":"reference/draw/image-text/#constructor","text":"nib . draw . Text ( content , x , y , font = None , fill = \"#000000\" , alignment = \"left\" , opacity = 1.0 , style = None )","title":"Constructor"},{"location":"reference/draw/image-text/#parameters","text":"Parameter Type Default Description content str required The text string to draw. x float required X coordinate of the text origin. y float required Y coordinate of the text origin. font Font None Font configuration ( nib.Font instance). Uses system default when None . fill str \\| Color \"#000000\" Text color. Accepts hex strings or nib.Color objects. alignment HorizontalAlignment \\| str \"left\" Text alignment: \"left\" , \"center\" , or \"right\" . Also accepts nib.HorizontalAlignment enum values. opacity float 1.0 Opacity from 0.0 to 1.0. style TextStyle None Optional nib.TextStyle for additional styling (bold, italic, etc.).","title":"Parameters"},{"location":"reference/draw/image-text/#examples","text":"","title":"Examples"},{"location":"reference/draw/image-text/#simple-text","text":"import nib canvas = nib . Canvas ( width = 400 , height = 200 , background_color = \"#1e1e1e\" ) canvas . draw ([ nib . draw . Text ( \"Hello, Canvas!\" , x = 20 , y = 50 , fill = \"#ffffff\" ), ])","title":"Simple text"},{"location":"reference/draw/image-text/#styled-text-with-font-and-color","text":"import nib canvas = nib . Canvas ( width = 400 , height = 200 ) canvas . draw ([ nib . draw . Text ( \"Bold Title\" , x = 200 , y = 50 , font = nib . Font . system ( 24 , weight = nib . FontWeight . BOLD ), fill = nib . Color . RED , alignment = nib . HorizontalAlignment . CENTER , ), nib . draw . Text ( \"Subtitle text\" , x = 200 , y = 90 , font = nib . Font . system ( 14 ), fill = \"#888888\" , alignment = \"center\" , ), ])","title":"Styled text with font and color"},{"location":"reference/draw/image-text/#multiple-text-elements","text":"import nib canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#f5f5f5\" ) canvas . draw ([ nib . draw . Text ( \"Left aligned\" , x = 20 , y = 40 , fill = \"#333333\" ), nib . draw . Text ( \"Center aligned\" , x = 200 , y = 80 , fill = \"#333333\" , alignment = \"center\" ), nib . draw . Text ( \"Right aligned\" , x = 380 , y = 120 , fill = \"#333333\" , alignment = \"right\" ), ])","title":"Multiple text elements"},{"location":"reference/draw/image-text/#image","text":"Draws a raster image on the canvas from raw JPEG/PNG bytes. Images can be scaled to a specific width and height, or drawn at their original resolution.","title":"Image"},{"location":"reference/draw/image-text/#constructor_1","text":"nib . draw . Image ( data , x = 0 , y = 0 , width = None , height = None , opacity = 1.0 )","title":"Constructor"},{"location":"reference/draw/image-text/#parameters_1","text":"Parameter Type Default Description data bytes required Raw image bytes (JPEG, PNG, or other formats supported by macOS). x float 0 X coordinate of the top-left corner. y float 0 Y coordinate of the top-left corner. width float None Width to draw the image. None uses the original image width. height float None Height to draw the image. None uses the original image height. opacity float 1.0 Opacity from 0.0 to 1.0.","title":"Parameters"},{"location":"reference/draw/image-text/#examples_1","text":"","title":"Examples"},{"location":"reference/draw/image-text/#drawing-from-file","text":"import nib canvas = nib . Canvas ( width = 400 , height = 300 ) with open ( \"photo.jpg\" , \"rb\" ) as f : canvas . draw ([ nib . draw . Image ( data = f . read (), x = 0 , y = 0 ), ])","title":"Drawing from file"},{"location":"reference/draw/image-text/#scaled-image","text":"import nib canvas = nib . Canvas ( width = 400 , height = 300 ) with open ( \"icon.png\" , \"rb\" ) as f : canvas . draw ([ nib . draw . Image ( data = f . read (), x = 10 , y = 10 , width = 200 , height = 150 ), ])","title":"Scaled image"},{"location":"reference/draw/image-text/#semi-transparent-overlay","text":"import nib canvas = nib . Canvas ( width = 400 , height = 300 ) with open ( \"background.jpg\" , \"rb\" ) as bg , open ( \"overlay.png\" , \"rb\" ) as fg : canvas . draw ([ nib . draw . Image ( data = bg . read (), x = 0 , y = 0 , width = 400 , height = 300 ), nib . draw . Image ( data = fg . read (), x = 50 , y = 50 , width = 100 , height = 100 , opacity = 0.6 ), ])","title":"Semi-transparent overlay"},{"location":"reference/draw/image-text/#using-pilpillow","text":"import nib import io from PIL import Image as PILImage canvas = nib . Canvas ( width = 400 , height = 300 ) img = PILImage . open ( \"photo.jpg\" ) img = img . resize (( 200 , 150 )) buffer = io . BytesIO () img . save ( buffer , format = \"JPEG\" ) canvas . draw ([ nib . draw . Image ( data = buffer . getvalue (), x = 100 , y = 75 ), ])","title":"Using PIL/Pillow"},{"location":"reference/draw/paint/","text":"Styling classes for controlling how shapes are drawn on a Canvas . The Paint class acts as a \"paintbrush\" that determines color, stroke style, gradients, and effects. Gradient classes provide LinearGradient , RadialGradient , and SweepGradient fills. All color parameters accept hex strings ( \"#FF0000\" ) or nib.Color objects. Paint \u00b6 Defines the full drawing style for shapes. Combines color, stroke properties, gradients, blur, and blend mode into a single configuration object. Constructor \u00b6 nib . draw . Paint ( color = None , style = PaintStyle . FILL , stroke_width = 1.0 , stroke_cap = StrokeCap . BUTT , stroke_join = StrokeJoin . MITER , stroke_miter_limit = 4.0 , opacity = 1.0 , blend_mode = None , gradient = None , blur = None , anti_alias = True , ) Parameters \u00b6 Parameter Type Default Description color str \\| Color None Base color for the paint. style PaintStyle PaintStyle.FILL Drawing style: FILL or STROKE . stroke_width float 1.0 Width of strokes in points. stroke_cap StrokeCap StrokeCap.BUTT Shape at line ends: BUTT , ROUND , or SQUARE . stroke_join StrokeJoin StrokeJoin.MITER Shape at corners: MITER , ROUND , or BEVEL . stroke_miter_limit float 4.0 Limit for miter joins before they are beveled. opacity float 1.0 Opacity from 0.0 to 1.0. blend_mode BlendMode None Blend mode for compositing (e.g., nib.BlendMode.MULTIPLY ). gradient LinearGradient \\| RadialGradient \\| SweepGradient None Gradient fill. Overrides color for fill rendering. blur Blur None Blur effect applied to the paint. anti_alias bool True Whether to apply anti-aliasing. Example \u00b6 import nib paint = nib . draw . Paint ( gradient = nib . draw . LinearGradient ( start = ( 0 , 0 ), end = ( 100 , 100 ), colors = [ nib . Color . RED , nib . Color . BLUE ], ), style = nib . draw . PaintStyle . FILL , opacity = 0.8 , ) PaintStyle \u00b6 Determines whether a shape is filled, stroked, or both. Value Description FILL Fill the interior of the shape. Default. STROKE Draw only the outline of the shape. StrokeCap \u00b6 Controls the shape at the ends of open line segments. Value Description BUTT Flat end, no extension beyond the endpoint. Default. ROUND Semicircular end extending beyond the endpoint by half the stroke width. SQUARE Flat end extending beyond the endpoint by half the stroke width. StrokeJoin \u00b6 Controls the shape at corners where two line segments meet. Value Description MITER Sharp corner. Default. Falls back to bevel if the angle is too acute (see stroke_miter_limit ). ROUND Rounded corner. BEVEL Flat corner, cutting the joint diagonally. PointMode \u00b6 Determines how a list of points is interpreted by the Points draw command. Value Description POINTS Draw each point as an individual dot. LINES Draw lines between consecutive pairs of points. POLYGON Draw connected line segments through all points. LinearGradient \u00b6 A linear gradient fill that transitions colors along a straight line. Constructor \u00b6 nib . draw . LinearGradient ( start , end , colors , stops = None ) Parameters \u00b6 Parameter Type Default Description start tuple[float, float] required Starting point (x, y) of the gradient in pixel coordinates. end tuple[float, float] required Ending point (x, y) of the gradient in pixel coordinates. colors list[str \\| Color] required List of colors. Minimum two. stops list[float] None Optional stop positions from 0.0 to 1.0. Must match the length of colors . Evenly distributed when omitted. Example \u00b6 nib . draw . LinearGradient ( start = ( 0 , 0 ), end = ( 200 , 200 ), colors = [ \"#FF0000\" , \"#00FF00\" , \"#0000FF\" ], stops = [ 0.0 , 0.5 , 1.0 ], ) RadialGradient \u00b6 A radial gradient fill that transitions colors outward from a center point. Constructor \u00b6 nib . draw . RadialGradient ( center , radius , colors , stops = None , focus = None ) Parameters \u00b6 Parameter Type Default Description center tuple[float, float] required Center point (x, y) of the gradient in pixels. radius float required Radius of the gradient in pixels. colors list[str \\| Color] required List of colors. Minimum two. stops list[float] None Optional stop positions from 0.0 to 1.0. focus tuple[float, float] None Optional focus point (x, y) for off-center gradients. Example \u00b6 nib . draw . RadialGradient ( center = ( 100 , 100 ), radius = 80 , colors = [ nib . Color . YELLOW , nib . Color . RED ], ) SweepGradient \u00b6 A sweep (conic/angular) gradient that transitions colors around a center point. Constructor \u00b6 nib . draw . SweepGradient ( center , colors , stops = None , start_angle = 0 , end_angle = 6.283 ) Parameters \u00b6 Parameter Type Default Description center tuple[float, float] required Center point (x, y) of the gradient. colors list[str \\| Color] required List of colors. stops list[float] None Optional stop positions from 0.0 to 1.0. start_angle float 0 Starting angle in radians. end_angle float 6.283 Ending angle in radians (default is 2 * pi, a full circle). Example \u00b6 # Color wheel nib . draw . SweepGradient ( center = ( 100 , 100 ), colors = [ nib . Color . RED , nib . Color . GREEN , nib . Color . BLUE , nib . Color . RED ], ) Blur \u00b6 A blur effect that can be applied via the Paint.blur parameter. Constructor \u00b6 nib . draw . Blur ( sigma_x , sigma_y = None , style = \"normal\" ) Parameters \u00b6 Parameter Type Default Description sigma_x float required Horizontal blur radius. sigma_y float None Vertical blur radius. Defaults to sigma_x if not specified. style str \"normal\" Blur style: \"normal\" , \"solid\" , \"outer\" , or \"inner\" . Example \u00b6 paint = nib . draw . Paint ( color = \"#000000\" , blur = nib . draw . Blur ( sigma_x = 5 ), )","title":"Paint & Gradients"},{"location":"reference/draw/paint/#paint","text":"Defines the full drawing style for shapes. Combines color, stroke properties, gradients, blur, and blend mode into a single configuration object.","title":"Paint"},{"location":"reference/draw/paint/#constructor","text":"nib . draw . Paint ( color = None , style = PaintStyle . FILL , stroke_width = 1.0 , stroke_cap = StrokeCap . BUTT , stroke_join = StrokeJoin . MITER , stroke_miter_limit = 4.0 , opacity = 1.0 , blend_mode = None , gradient = None , blur = None , anti_alias = True , )","title":"Constructor"},{"location":"reference/draw/paint/#parameters","text":"Parameter Type Default Description color str \\| Color None Base color for the paint. style PaintStyle PaintStyle.FILL Drawing style: FILL or STROKE . stroke_width float 1.0 Width of strokes in points. stroke_cap StrokeCap StrokeCap.BUTT Shape at line ends: BUTT , ROUND , or SQUARE . stroke_join StrokeJoin StrokeJoin.MITER Shape at corners: MITER , ROUND , or BEVEL . stroke_miter_limit float 4.0 Limit for miter joins before they are beveled. opacity float 1.0 Opacity from 0.0 to 1.0. blend_mode BlendMode None Blend mode for compositing (e.g., nib.BlendMode.MULTIPLY ). gradient LinearGradient \\| RadialGradient \\| SweepGradient None Gradient fill. Overrides color for fill rendering. blur Blur None Blur effect applied to the paint. anti_alias bool True Whether to apply anti-aliasing.","title":"Parameters"},{"location":"reference/draw/paint/#example","text":"import nib paint = nib . draw . Paint ( gradient = nib . draw . LinearGradient ( start = ( 0 , 0 ), end = ( 100 , 100 ), colors = [ nib . Color . RED , nib . Color . BLUE ], ), style = nib . draw . PaintStyle . FILL , opacity = 0.8 , )","title":"Example"},{"location":"reference/draw/paint/#paintstyle","text":"Determines whether a shape is filled, stroked, or both. Value Description FILL Fill the interior of the shape. Default. STROKE Draw only the outline of the shape.","title":"PaintStyle"},{"location":"reference/draw/paint/#strokecap","text":"Controls the shape at the ends of open line segments. Value Description BUTT Flat end, no extension beyond the endpoint. Default. ROUND Semicircular end extending beyond the endpoint by half the stroke width. SQUARE Flat end extending beyond the endpoint by half the stroke width.","title":"StrokeCap"},{"location":"reference/draw/paint/#strokejoin","text":"Controls the shape at corners where two line segments meet. Value Description MITER Sharp corner. Default. Falls back to bevel if the angle is too acute (see stroke_miter_limit ). ROUND Rounded corner. BEVEL Flat corner, cutting the joint diagonally.","title":"StrokeJoin"},{"location":"reference/draw/paint/#pointmode","text":"Determines how a list of points is interpreted by the Points draw command. Value Description POINTS Draw each point as an individual dot. LINES Draw lines between consecutive pairs of points. POLYGON Draw connected line segments through all points.","title":"PointMode"},{"location":"reference/draw/paint/#lineargradient","text":"A linear gradient fill that transitions colors along a straight line.","title":"LinearGradient"},{"location":"reference/draw/paint/#constructor_1","text":"nib . draw . LinearGradient ( start , end , colors , stops = None )","title":"Constructor"},{"location":"reference/draw/paint/#parameters_1","text":"Parameter Type Default Description start tuple[float, float] required Starting point (x, y) of the gradient in pixel coordinates. end tuple[float, float] required Ending point (x, y) of the gradient in pixel coordinates. colors list[str \\| Color] required List of colors. Minimum two. stops list[float] None Optional stop positions from 0.0 to 1.0. Must match the length of colors . Evenly distributed when omitted.","title":"Parameters"},{"location":"reference/draw/paint/#example_1","text":"nib . draw . LinearGradient ( start = ( 0 , 0 ), end = ( 200 , 200 ), colors = [ \"#FF0000\" , \"#00FF00\" , \"#0000FF\" ], stops = [ 0.0 , 0.5 , 1.0 ], )","title":"Example"},{"location":"reference/draw/paint/#radialgradient","text":"A radial gradient fill that transitions colors outward from a center point.","title":"RadialGradient"},{"location":"reference/draw/paint/#constructor_2","text":"nib . draw . RadialGradient ( center , radius , colors , stops = None , focus = None )","title":"Constructor"},{"location":"reference/draw/paint/#parameters_2","text":"Parameter Type Default Description center tuple[float, float] required Center point (x, y) of the gradient in pixels. radius float required Radius of the gradient in pixels. colors list[str \\| Color] required List of colors. Minimum two. stops list[float] None Optional stop positions from 0.0 to 1.0. focus tuple[float, float] None Optional focus point (x, y) for off-center gradients.","title":"Parameters"},{"location":"reference/draw/paint/#example_2","text":"nib . draw . RadialGradient ( center = ( 100 , 100 ), radius = 80 , colors = [ nib . Color . YELLOW , nib . Color . RED ], )","title":"Example"},{"location":"reference/draw/paint/#sweepgradient","text":"A sweep (conic/angular) gradient that transitions colors around a center point.","title":"SweepGradient"},{"location":"reference/draw/paint/#constructor_3","text":"nib . draw . SweepGradient ( center , colors , stops = None , start_angle = 0 , end_angle = 6.283 )","title":"Constructor"},{"location":"reference/draw/paint/#parameters_3","text":"Parameter Type Default Description center tuple[float, float] required Center point (x, y) of the gradient. colors list[str \\| Color] required List of colors. stops list[float] None Optional stop positions from 0.0 to 1.0. start_angle float 0 Starting angle in radians. end_angle float 6.283 Ending angle in radians (default is 2 * pi, a full circle).","title":"Parameters"},{"location":"reference/draw/paint/#example_3","text":"# Color wheel nib . draw . SweepGradient ( center = ( 100 , 100 ), colors = [ nib . Color . RED , nib . Color . GREEN , nib . Color . BLUE , nib . Color . RED ], )","title":"Example"},{"location":"reference/draw/paint/#blur","text":"A blur effect that can be applied via the Paint.blur parameter.","title":"Blur"},{"location":"reference/draw/paint/#constructor_4","text":"nib . draw . Blur ( sigma_x , sigma_y = None , style = \"normal\" )","title":"Constructor"},{"location":"reference/draw/paint/#parameters_4","text":"Parameter Type Default Description sigma_x float required Horizontal blur radius. sigma_y float None Vertical blur radius. Defaults to sigma_x if not specified. style str \"normal\" Blur style: \"normal\" , \"solid\" , \"outer\" , or \"inner\" .","title":"Parameters"},{"location":"reference/draw/paint/#example_4","text":"paint = nib . draw . Paint ( color = \"#000000\" , blur = nib . draw . Blur ( sigma_x = 5 ), )","title":"Example"},{"location":"reference/draw/path-elements/","text":"Typed path elements for constructing bezier paths used with BezierPath . Each element is a dataclass representing a segment of a path. Elements are composed into a list and passed to the BezierPath(elements=[...]) parameter. All path elements inherit from the PathElement base class. MoveTo \u00b6 Starts a new sub-path at the given point. Does not draw anything; it sets the current point for subsequent drawing elements. nib . draw . MoveTo ( x , y ) Parameter Type Description x float X coordinate of the point. y float Y coordinate of the point. LineTo \u00b6 Draws a straight line from the current point to the given point. nib . draw . LineTo ( x , y ) Parameter Type Description x float X coordinate of the endpoint. y float Y coordinate of the endpoint. CubicTo \u00b6 Draws a cubic bezier curve from the current point to (x, y) using two control points. Cubic beziers provide smooth curves with two degrees of curvature control. nib . draw . CubicTo ( cp1x , cp1y , cp2x , cp2y , x , y ) Parameter Type Description cp1x float First control point X coordinate. cp1y float First control point Y coordinate. cp2x float Second control point X coordinate. cp2y float Second control point Y coordinate. x float Endpoint X coordinate. y float Endpoint Y coordinate. QuadraticTo \u00b6 Draws a quadratic bezier curve from the current point to (x, y) using one control point. The optional weight w controls the conic section type. nib . draw . QuadraticTo ( cp1x , cp1y , x , y , w = 1.0 ) Parameter Type Default Description cp1x float required Control point X coordinate. cp1y float required Control point Y coordinate. x float required Endpoint X coordinate. y float required Endpoint Y coordinate. w float 1.0 Weight for conic sections. w > 1 : hyperbola, w == 1 : parabola (standard quadratic), w < 1 : ellipse. Close \u00b6 Closes the current sub-path by drawing a straight line from the current point back to the starting point of the sub-path. nib . draw . Close () No parameters. ArcTo \u00b6 Draws an arc from the current point to (x, y) with configurable radius, rotation, and sweep direction. nib . draw . ArcTo ( x , y , radius = 0 , rotation = 0 , large_arc = False , clockwise = True ) Parameter Type Default Description x float required Endpoint X coordinate. y float required Endpoint Y coordinate. radius float 0 Radius of the arc. rotation float 0 Rotation of the arc in degrees. large_arc bool False Whether to use the large arc sweep. clockwise bool True Whether the arc is drawn clockwise. PathArc \u00b6 Adds an arc segment following the edge of an oval. The arc follows the oval bounded by the rectangle at (x, y) with the given width and height . Note Imported as PathArc to avoid conflict with the top-level Arc draw command. Use from nib.draw import PathArc . nib . draw . PathArc ( x , y , width , height , start_angle , sweep_angle ) Parameter Type Description x float Top-left X of the bounding rectangle. y float Top-left Y of the bounding rectangle. width float Width of the bounding rectangle. height float Height of the bounding rectangle. start_angle float Starting angle in radians (0 = 3 o'clock position). sweep_angle float Sweep angle in radians from start_angle . Positive is clockwise. Oval \u00b6 Adds an ellipse that fills the given bounding rectangle as a sub-path. nib . draw . Oval ( x , y , width , height ) Parameter Type Description x float Top-left X of the bounding rectangle. y float Top-left Y of the bounding rectangle. width float Width of the bounding rectangle. height float Height of the bounding rectangle. PathRect \u00b6 Adds a rectangle as a new sub-path element, optionally with rounded corners. Note Imported as PathRect to avoid conflict with the top-level Rect draw command. Use from nib.draw import PathRect . nib . draw . PathRect ( x , y , width , height , border_radius = None ) Parameter Type Default Description x float required Top-left X of the rectangle. y float required Top-left Y of the rectangle. width float required Width of the rectangle. height float required Height of the rectangle. border_radius float None Corner radius for rounded rectangles. SubPath \u00b6 Embeds a group of path elements at a given offset, creating a translated sub-path within the parent path. nib . draw . SubPath ( x , y , elements ) Parameter Type Description x float X offset for the sub-path. y float Y offset for the sub-path. elements list[PathElement] List of path elements in the sub-path. Examples \u00b6 Heart shape with cubic beziers \u00b6 import nib from nib.draw import BezierPath , MoveTo , CubicTo , Close canvas = nib . Canvas ( width = 200 , height = 200 ) canvas . draw ([ BezierPath ( elements = [ MoveTo ( 100 , 50 ), CubicTo ( cp1x = 100 , cp1y = 0 , cp2x = 50 , cp2y = 0 , x = 50 , y = 50 ), CubicTo ( cp1x = 50 , cp1y = 80 , cp2x = 100 , cp2y = 120 , x = 100 , y = 150 ), CubicTo ( cp1x = 100 , cp1y = 120 , cp2x = 150 , cp2y = 80 , x = 150 , y = 50 ), CubicTo ( cp1x = 150 , cp1y = 0 , cp2x = 100 , cp2y = 0 , x = 100 , y = 50 ), Close (), ], fill = \"#FF0000\" , ), ]) Quadratic bezier curve \u00b6 import nib from nib.draw import BezierPath , MoveTo , QuadraticTo , Close canvas = nib . Canvas ( width = 200 , height = 200 ) canvas . draw ([ BezierPath ( elements = [ MoveTo ( 25 , 125 ), QuadraticTo ( cp1x = 50 , cp1y = 25 , x = 135 , y = 35 ), QuadraticTo ( cp1x = 75 , cp1y = 115 , x = 135 , y = 215 ), Close (), ], fill = \"#F06292\" , ), ]) Custom shape with mixed elements \u00b6 import nib from nib.draw import BezierPath , MoveTo , LineTo , ArcTo , Close canvas = nib . Canvas ( width = 300 , height = 200 ) canvas . draw ([ BezierPath ( elements = [ MoveTo ( 50 , 100 ), LineTo ( 150 , 20 ), ArcTo ( x = 250 , y = 100 , radius = 50 , clockwise = True ), LineTo ( 150 , 180 ), Close (), ], fill = \"#6366F1\" , stroke = \"#4F46E5\" , stroke_width = 2 , ), ])","title":"Path Elements"},{"location":"reference/draw/path-elements/#moveto","text":"Starts a new sub-path at the given point. Does not draw anything; it sets the current point for subsequent drawing elements. nib . draw . MoveTo ( x , y ) Parameter Type Description x float X coordinate of the point. y float Y coordinate of the point.","title":"MoveTo"},{"location":"reference/draw/path-elements/#lineto","text":"Draws a straight line from the current point to the given point. nib . draw . LineTo ( x , y ) Parameter Type Description x float X coordinate of the endpoint. y float Y coordinate of the endpoint.","title":"LineTo"},{"location":"reference/draw/path-elements/#cubicto","text":"Draws a cubic bezier curve from the current point to (x, y) using two control points. Cubic beziers provide smooth curves with two degrees of curvature control. nib . draw . CubicTo ( cp1x , cp1y , cp2x , cp2y , x , y ) Parameter Type Description cp1x float First control point X coordinate. cp1y float First control point Y coordinate. cp2x float Second control point X coordinate. cp2y float Second control point Y coordinate. x float Endpoint X coordinate. y float Endpoint Y coordinate.","title":"CubicTo"},{"location":"reference/draw/path-elements/#quadraticto","text":"Draws a quadratic bezier curve from the current point to (x, y) using one control point. The optional weight w controls the conic section type. nib . draw . QuadraticTo ( cp1x , cp1y , x , y , w = 1.0 ) Parameter Type Default Description cp1x float required Control point X coordinate. cp1y float required Control point Y coordinate. x float required Endpoint X coordinate. y float required Endpoint Y coordinate. w float 1.0 Weight for conic sections. w > 1 : hyperbola, w == 1 : parabola (standard quadratic), w < 1 : ellipse.","title":"QuadraticTo"},{"location":"reference/draw/path-elements/#close","text":"Closes the current sub-path by drawing a straight line from the current point back to the starting point of the sub-path. nib . draw . Close () No parameters.","title":"Close"},{"location":"reference/draw/path-elements/#arcto","text":"Draws an arc from the current point to (x, y) with configurable radius, rotation, and sweep direction. nib . draw . ArcTo ( x , y , radius = 0 , rotation = 0 , large_arc = False , clockwise = True ) Parameter Type Default Description x float required Endpoint X coordinate. y float required Endpoint Y coordinate. radius float 0 Radius of the arc. rotation float 0 Rotation of the arc in degrees. large_arc bool False Whether to use the large arc sweep. clockwise bool True Whether the arc is drawn clockwise.","title":"ArcTo"},{"location":"reference/draw/path-elements/#patharc","text":"Adds an arc segment following the edge of an oval. The arc follows the oval bounded by the rectangle at (x, y) with the given width and height . Note Imported as PathArc to avoid conflict with the top-level Arc draw command. Use from nib.draw import PathArc . nib . draw . PathArc ( x , y , width , height , start_angle , sweep_angle ) Parameter Type Description x float Top-left X of the bounding rectangle. y float Top-left Y of the bounding rectangle. width float Width of the bounding rectangle. height float Height of the bounding rectangle. start_angle float Starting angle in radians (0 = 3 o'clock position). sweep_angle float Sweep angle in radians from start_angle . Positive is clockwise.","title":"PathArc"},{"location":"reference/draw/path-elements/#oval","text":"Adds an ellipse that fills the given bounding rectangle as a sub-path. nib . draw . Oval ( x , y , width , height ) Parameter Type Description x float Top-left X of the bounding rectangle. y float Top-left Y of the bounding rectangle. width float Width of the bounding rectangle. height float Height of the bounding rectangle.","title":"Oval"},{"location":"reference/draw/path-elements/#pathrect","text":"Adds a rectangle as a new sub-path element, optionally with rounded corners. Note Imported as PathRect to avoid conflict with the top-level Rect draw command. Use from nib.draw import PathRect . nib . draw . PathRect ( x , y , width , height , border_radius = None ) Parameter Type Default Description x float required Top-left X of the rectangle. y float required Top-left Y of the rectangle. width float required Width of the rectangle. height float required Height of the rectangle. border_radius float None Corner radius for rounded rectangles.","title":"PathRect"},{"location":"reference/draw/path-elements/#subpath","text":"Embeds a group of path elements at a given offset, creating a translated sub-path within the parent path. nib . draw . SubPath ( x , y , elements ) Parameter Type Description x float X offset for the sub-path. y float Y offset for the sub-path. elements list[PathElement] List of path elements in the sub-path.","title":"SubPath"},{"location":"reference/draw/path-elements/#examples","text":"","title":"Examples"},{"location":"reference/draw/path-elements/#heart-shape-with-cubic-beziers","text":"import nib from nib.draw import BezierPath , MoveTo , CubicTo , Close canvas = nib . Canvas ( width = 200 , height = 200 ) canvas . draw ([ BezierPath ( elements = [ MoveTo ( 100 , 50 ), CubicTo ( cp1x = 100 , cp1y = 0 , cp2x = 50 , cp2y = 0 , x = 50 , y = 50 ), CubicTo ( cp1x = 50 , cp1y = 80 , cp2x = 100 , cp2y = 120 , x = 100 , y = 150 ), CubicTo ( cp1x = 100 , cp1y = 120 , cp2x = 150 , cp2y = 80 , x = 150 , y = 50 ), CubicTo ( cp1x = 150 , cp1y = 0 , cp2x = 100 , cp2y = 0 , x = 100 , y = 50 ), Close (), ], fill = \"#FF0000\" , ), ])","title":"Heart shape with cubic beziers"},{"location":"reference/draw/path-elements/#quadratic-bezier-curve","text":"import nib from nib.draw import BezierPath , MoveTo , QuadraticTo , Close canvas = nib . Canvas ( width = 200 , height = 200 ) canvas . draw ([ BezierPath ( elements = [ MoveTo ( 25 , 125 ), QuadraticTo ( cp1x = 50 , cp1y = 25 , x = 135 , y = 35 ), QuadraticTo ( cp1x = 75 , cp1y = 115 , x = 135 , y = 215 ), Close (), ], fill = \"#F06292\" , ), ])","title":"Quadratic bezier curve"},{"location":"reference/draw/path-elements/#custom-shape-with-mixed-elements","text":"import nib from nib.draw import BezierPath , MoveTo , LineTo , ArcTo , Close canvas = nib . Canvas ( width = 300 , height = 200 ) canvas . draw ([ BezierPath ( elements = [ MoveTo ( 50 , 100 ), LineTo ( 150 , 20 ), ArcTo ( x = 250 , y = 100 , radius = 50 , clockwise = True ), LineTo ( 150 , 180 ), Close (), ], fill = \"#6366F1\" , stroke = \"#4F46E5\" , stroke_width = 2 , ), ])","title":"Custom shape with mixed elements"},{"location":"reference/draw/primitives/","text":"Shape and utility commands for drawing on a Canvas . All primitives are dataclasses inheriting from DrawCommand and are passed to canvas.draw() or canvas.append() . Color parameters accept hex strings ( \"#FF0000\" ) or nib.Color objects. Fill parameters additionally accept gradient objects ( LinearGradient , RadialGradient , SweepGradient ). Rect \u00b6 A rectangle drawing command. nib . draw . Rect ( x , y , width , height , corner_radius = 0 , fill = None , stroke = None , stroke_width = 1 , opacity = 1.0 , blend_mode = None ) Parameter Type Default Description x float required X coordinate of the top-left corner. y float required Y coordinate of the top-left corner. width float required Width of the rectangle. height float required Height of the rectangle. corner_radius float 0 Radius for rounded corners. 0 for sharp corners. fill str \\| Color \\| Gradient None Fill color or gradient. stroke str \\| Color None Stroke (outline) color. stroke_width float 1 Width of the stroke. opacity float 1.0 Opacity from 0.0 to 1.0. blend_mode BlendMode None Blend mode for compositing. nib . draw . Rect ( x = 10 , y = 10 , width = 100 , height = 60 , fill = \"#3498db\" , corner_radius = 8 ) Circle \u00b6 A circle drawing command. nib . draw . Circle ( cx , cy , radius , fill = None , stroke = None , stroke_width = 1 , opacity = 1.0 , blend_mode = None ) Parameter Type Default Description cx float required X coordinate of the center. cy float required Y coordinate of the center. radius float required Radius of the circle. fill str \\| Color \\| Gradient None Fill color or gradient. stroke str \\| Color None Stroke color. stroke_width float 1 Width of the stroke. opacity float 1.0 Opacity from 0.0 to 1.0. blend_mode BlendMode None Blend mode for compositing. nib . draw . Circle ( cx = 100 , cy = 100 , radius = 40 , fill = \"#e74c3c\" ) Ellipse \u00b6 An ellipse drawing command. nib . draw . Ellipse ( cx , cy , rx , ry , fill = None , stroke = None , stroke_width = 1 , opacity = 1.0 , blend_mode = None ) Parameter Type Default Description cx float required X coordinate of the center. cy float required Y coordinate of the center. rx float required Horizontal radius. ry float required Vertical radius. fill str \\| Color \\| Gradient None Fill color or gradient. stroke str \\| Color None Stroke color. stroke_width float 1 Width of the stroke. opacity float 1.0 Opacity from 0.0 to 1.0. blend_mode BlendMode None Blend mode for compositing. nib . draw . Ellipse ( cx = 150 , cy = 100 , rx = 80 , ry = 40 , fill = \"#2ecc71\" , stroke = \"#27ae60\" ) Line \u00b6 A straight line drawing command. nib . draw . Line ( x1 , y1 , x2 , y2 , stroke = \"#000000\" , stroke_width = 1 , line_cap = \"butt\" , opacity = 1.0 ) Parameter Type Default Description x1 float required X coordinate of the start point. y1 float required Y coordinate of the start point. x2 float required X coordinate of the end point. y2 float required Y coordinate of the end point. stroke str \\| Color \"#000000\" Stroke color. stroke_width float 1 Width of the stroke. line_cap str \"butt\" Line cap style: \"butt\" , \"round\" , or \"square\" . opacity float 1.0 Opacity from 0.0 to 1.0. nib . draw . Line ( x1 = 10 , y1 = 200 , x2 = 390 , y2 = 200 , stroke = \"#2ecc71\" , stroke_width = 2 ) Arc \u00b6 An arc drawing command. nib . draw . Arc ( cx , cy , radius , start_angle , end_angle , clockwise = True , fill = None , stroke = None , stroke_width = 1 , opacity = 1.0 ) Parameter Type Default Description cx float required X coordinate of the center. cy float required Y coordinate of the center. radius float required Radius of the arc. start_angle float required Start angle in radians. end_angle float required End angle in radians. clockwise bool True Whether to draw in the clockwise direction. fill str \\| Color None Fill color for the arc wedge. stroke str \\| Color None Stroke color. stroke_width float 1 Width of the stroke. opacity float 1.0 Opacity from 0.0 to 1.0. import math nib . draw . Arc ( cx = 100 , cy = 100 , radius = 50 , start_angle = 0 , end_angle = math . pi , stroke = \"#9b59b6\" , stroke_width = 3 ) Path \u00b6 A polyline/polygon from a list of coordinate points. nib . draw . Path ( points , closed = False , fill = None , stroke = None , stroke_width = 1 , line_join = \"miter\" , opacity = 1.0 ) Parameter Type Default Description points list[tuple[float, float]] required List of (x, y) coordinate tuples. closed bool False Whether to close the path back to the first point. fill str \\| Color None Fill color (only meaningful when closed=True ). stroke str \\| Color None Stroke color. stroke_width float 1 Width of the stroke. line_join str \"miter\" Line join style: \"miter\" , \"round\" , or \"bevel\" . opacity float 1.0 Opacity from 0.0 to 1.0. nib . draw . Path ( points = [( 10 , 10 ), ( 100 , 50 ), ( 50 , 120 )], closed = True , fill = \"#3498db\" , stroke = \"#2980b9\" , ) Polygon \u00b6 A closed polygon. Convenience wrapper around Path with closed=True . nib . draw . Polygon ( points , fill = None , stroke = None , stroke_width = 1 , opacity = 1.0 ) Parameter Type Default Description points list[tuple[float, float]] required List of (x, y) coordinate tuples defining the polygon vertices. fill str \\| Color None Fill color. stroke str \\| Color None Stroke color. stroke_width float 1 Width of the stroke. opacity float 1.0 Opacity from 0.0 to 1.0. nib . draw . Polygon ( points = [( 50 , 0 ), ( 100 , 100 ), ( 0 , 100 )], fill = \"#e74c3c\" , ) BezierPath \u00b6 A bezier path built from typed path elements or legacy dict commands. Use the typed elements API (recommended) for type safety and IDE support. See Path Elements for the full list of element types. nib . draw . BezierPath ( elements = None , commands = None , fill = None , stroke = None , stroke_width = 1 , opacity = 1.0 ) Parameter Type Default Description elements list[PathElement] None List of typed path elements ( MoveTo , LineTo , CubicTo , etc.). Recommended. commands list[dict] None Legacy dict format. Deprecated; use elements instead. fill str \\| Color \\| Gradient None Fill color or gradient. stroke str \\| Color None Stroke color. stroke_width float 1 Width of the stroke. opacity float 1.0 Opacity from 0.0 to 1.0. from nib.draw import BezierPath , MoveTo , CubicTo , Close nib . draw . BezierPath ( elements = [ MoveTo ( 100 , 50 ), CubicTo ( cp1x = 100 , cp1y = 0 , cp2x = 50 , cp2y = 0 , x = 50 , y = 50 ), CubicTo ( cp1x = 50 , cp1y = 80 , cp2x = 100 , cp2y = 120 , x = 100 , y = 150 ), Close (), ], fill = \"#FF0000\" , ) Points \u00b6 Draws multiple points, lines between pairs, or a connected polygon. nib . draw . Points ( points , point_mode = PointMode . POINTS , stroke = \"#000000\" , stroke_width = 2 , stroke_cap = \"round\" , opacity = 1.0 ) Parameter Type Default Description points list[tuple[float, float]] required List of (x, y) coordinate tuples. point_mode PointMode PointMode.POINTS How to interpret points: POINTS (individual dots), LINES (pairs of points as line segments), POLYGON (connected segments). stroke str \\| Color \"#000000\" Stroke/point color. stroke_width float 2 Point size or line width. stroke_cap str \"round\" Cap style for points/lines. opacity float 1.0 Opacity from 0.0 to 1.0. nib . draw . Points ( points = [( 10 , 10 ), ( 50 , 50 ), ( 100 , 30 )], point_mode = nib . draw . PointMode . POINTS , stroke = nib . Color . RED , stroke_width = 5 , ) Shadow \u00b6 Draws a material-elevation shadow under a shape defined by a point path. nib . draw . Shadow ( path , elevation = 5 , color = \"#000000\" , opacity = 0.3 ) Parameter Type Default Description path list[tuple[float, float]] required List of (x, y) points defining the shadow shape. elevation float 5 Shadow elevation (material design style). color str \\| Color \"#000000\" Shadow color. opacity float 0.3 Shadow opacity. nib . draw . Shadow ( path = [( 10 , 10 ), ( 110 , 10 ), ( 110 , 110 ), ( 10 , 110 )], elevation = 10 , color = \"#000000\" , ) Fill \u00b6 Fills the entire canvas with a solid color or gradient. nib . draw . Fill ( fill = \"#FFFFFF\" , blend_mode = None ) Parameter Type Default Description fill str \\| Color \\| Gradient \"#FFFFFF\" Fill color or gradient. blend_mode BlendMode None Blend mode for compositing. nib . draw . Fill ( fill = nib . draw . LinearGradient ( start = ( 0 , 0 ), end = ( 400 , 300 ), colors = [ nib . Color . RED , nib . Color . BLUE ], )) ColorFill \u00b6 Fills the canvas with a color using a specific blend mode. Useful for tinting effects. nib . draw . ColorFill ( color = \"#000000\" , blend_mode = BlendMode . NORMAL ) Parameter Type Default Description color str \\| Color \"#000000\" Color to paint. blend_mode BlendMode BlendMode.NORMAL Blend mode to apply. nib . draw . ColorFill ( color = nib . Color . RED , blend_mode = nib . BlendMode . MULTIPLY )","title":"Primitives"},{"location":"reference/draw/primitives/#rect","text":"A rectangle drawing command. nib . draw . Rect ( x , y , width , height , corner_radius = 0 , fill = None , stroke = None , stroke_width = 1 , opacity = 1.0 , blend_mode = None ) Parameter Type Default Description x float required X coordinate of the top-left corner. y float required Y coordinate of the top-left corner. width float required Width of the rectangle. height float required Height of the rectangle. corner_radius float 0 Radius for rounded corners. 0 for sharp corners. fill str \\| Color \\| Gradient None Fill color or gradient. stroke str \\| Color None Stroke (outline) color. stroke_width float 1 Width of the stroke. opacity float 1.0 Opacity from 0.0 to 1.0. blend_mode BlendMode None Blend mode for compositing. nib . draw . Rect ( x = 10 , y = 10 , width = 100 , height = 60 , fill = \"#3498db\" , corner_radius = 8 )","title":"Rect"},{"location":"reference/draw/primitives/#circle","text":"A circle drawing command. nib . draw . Circle ( cx , cy , radius , fill = None , stroke = None , stroke_width = 1 , opacity = 1.0 , blend_mode = None ) Parameter Type Default Description cx float required X coordinate of the center. cy float required Y coordinate of the center. radius float required Radius of the circle. fill str \\| Color \\| Gradient None Fill color or gradient. stroke str \\| Color None Stroke color. stroke_width float 1 Width of the stroke. opacity float 1.0 Opacity from 0.0 to 1.0. blend_mode BlendMode None Blend mode for compositing. nib . draw . Circle ( cx = 100 , cy = 100 , radius = 40 , fill = \"#e74c3c\" )","title":"Circle"},{"location":"reference/draw/primitives/#ellipse","text":"An ellipse drawing command. nib . draw . Ellipse ( cx , cy , rx , ry , fill = None , stroke = None , stroke_width = 1 , opacity = 1.0 , blend_mode = None ) Parameter Type Default Description cx float required X coordinate of the center. cy float required Y coordinate of the center. rx float required Horizontal radius. ry float required Vertical radius. fill str \\| Color \\| Gradient None Fill color or gradient. stroke str \\| Color None Stroke color. stroke_width float 1 Width of the stroke. opacity float 1.0 Opacity from 0.0 to 1.0. blend_mode BlendMode None Blend mode for compositing. nib . draw . Ellipse ( cx = 150 , cy = 100 , rx = 80 , ry = 40 , fill = \"#2ecc71\" , stroke = \"#27ae60\" )","title":"Ellipse"},{"location":"reference/draw/primitives/#line","text":"A straight line drawing command. nib . draw . Line ( x1 , y1 , x2 , y2 , stroke = \"#000000\" , stroke_width = 1 , line_cap = \"butt\" , opacity = 1.0 ) Parameter Type Default Description x1 float required X coordinate of the start point. y1 float required Y coordinate of the start point. x2 float required X coordinate of the end point. y2 float required Y coordinate of the end point. stroke str \\| Color \"#000000\" Stroke color. stroke_width float 1 Width of the stroke. line_cap str \"butt\" Line cap style: \"butt\" , \"round\" , or \"square\" . opacity float 1.0 Opacity from 0.0 to 1.0. nib . draw . Line ( x1 = 10 , y1 = 200 , x2 = 390 , y2 = 200 , stroke = \"#2ecc71\" , stroke_width = 2 )","title":"Line"},{"location":"reference/draw/primitives/#arc","text":"An arc drawing command. nib . draw . Arc ( cx , cy , radius , start_angle , end_angle , clockwise = True , fill = None , stroke = None , stroke_width = 1 , opacity = 1.0 ) Parameter Type Default Description cx float required X coordinate of the center. cy float required Y coordinate of the center. radius float required Radius of the arc. start_angle float required Start angle in radians. end_angle float required End angle in radians. clockwise bool True Whether to draw in the clockwise direction. fill str \\| Color None Fill color for the arc wedge. stroke str \\| Color None Stroke color. stroke_width float 1 Width of the stroke. opacity float 1.0 Opacity from 0.0 to 1.0. import math nib . draw . Arc ( cx = 100 , cy = 100 , radius = 50 , start_angle = 0 , end_angle = math . pi , stroke = \"#9b59b6\" , stroke_width = 3 )","title":"Arc"},{"location":"reference/draw/primitives/#path","text":"A polyline/polygon from a list of coordinate points. nib . draw . Path ( points , closed = False , fill = None , stroke = None , stroke_width = 1 , line_join = \"miter\" , opacity = 1.0 ) Parameter Type Default Description points list[tuple[float, float]] required List of (x, y) coordinate tuples. closed bool False Whether to close the path back to the first point. fill str \\| Color None Fill color (only meaningful when closed=True ). stroke str \\| Color None Stroke color. stroke_width float 1 Width of the stroke. line_join str \"miter\" Line join style: \"miter\" , \"round\" , or \"bevel\" . opacity float 1.0 Opacity from 0.0 to 1.0. nib . draw . Path ( points = [( 10 , 10 ), ( 100 , 50 ), ( 50 , 120 )], closed = True , fill = \"#3498db\" , stroke = \"#2980b9\" , )","title":"Path"},{"location":"reference/draw/primitives/#polygon","text":"A closed polygon. Convenience wrapper around Path with closed=True . nib . draw . Polygon ( points , fill = None , stroke = None , stroke_width = 1 , opacity = 1.0 ) Parameter Type Default Description points list[tuple[float, float]] required List of (x, y) coordinate tuples defining the polygon vertices. fill str \\| Color None Fill color. stroke str \\| Color None Stroke color. stroke_width float 1 Width of the stroke. opacity float 1.0 Opacity from 0.0 to 1.0. nib . draw . Polygon ( points = [( 50 , 0 ), ( 100 , 100 ), ( 0 , 100 )], fill = \"#e74c3c\" , )","title":"Polygon"},{"location":"reference/draw/primitives/#bezierpath","text":"A bezier path built from typed path elements or legacy dict commands. Use the typed elements API (recommended) for type safety and IDE support. See Path Elements for the full list of element types. nib . draw . BezierPath ( elements = None , commands = None , fill = None , stroke = None , stroke_width = 1 , opacity = 1.0 ) Parameter Type Default Description elements list[PathElement] None List of typed path elements ( MoveTo , LineTo , CubicTo , etc.). Recommended. commands list[dict] None Legacy dict format. Deprecated; use elements instead. fill str \\| Color \\| Gradient None Fill color or gradient. stroke str \\| Color None Stroke color. stroke_width float 1 Width of the stroke. opacity float 1.0 Opacity from 0.0 to 1.0. from nib.draw import BezierPath , MoveTo , CubicTo , Close nib . draw . BezierPath ( elements = [ MoveTo ( 100 , 50 ), CubicTo ( cp1x = 100 , cp1y = 0 , cp2x = 50 , cp2y = 0 , x = 50 , y = 50 ), CubicTo ( cp1x = 50 , cp1y = 80 , cp2x = 100 , cp2y = 120 , x = 100 , y = 150 ), Close (), ], fill = \"#FF0000\" , )","title":"BezierPath"},{"location":"reference/draw/primitives/#points","text":"Draws multiple points, lines between pairs, or a connected polygon. nib . draw . Points ( points , point_mode = PointMode . POINTS , stroke = \"#000000\" , stroke_width = 2 , stroke_cap = \"round\" , opacity = 1.0 ) Parameter Type Default Description points list[tuple[float, float]] required List of (x, y) coordinate tuples. point_mode PointMode PointMode.POINTS How to interpret points: POINTS (individual dots), LINES (pairs of points as line segments), POLYGON (connected segments). stroke str \\| Color \"#000000\" Stroke/point color. stroke_width float 2 Point size or line width. stroke_cap str \"round\" Cap style for points/lines. opacity float 1.0 Opacity from 0.0 to 1.0. nib . draw . Points ( points = [( 10 , 10 ), ( 50 , 50 ), ( 100 , 30 )], point_mode = nib . draw . PointMode . POINTS , stroke = nib . Color . RED , stroke_width = 5 , )","title":"Points"},{"location":"reference/draw/primitives/#shadow","text":"Draws a material-elevation shadow under a shape defined by a point path. nib . draw . Shadow ( path , elevation = 5 , color = \"#000000\" , opacity = 0.3 ) Parameter Type Default Description path list[tuple[float, float]] required List of (x, y) points defining the shadow shape. elevation float 5 Shadow elevation (material design style). color str \\| Color \"#000000\" Shadow color. opacity float 0.3 Shadow opacity. nib . draw . Shadow ( path = [( 10 , 10 ), ( 110 , 10 ), ( 110 , 110 ), ( 10 , 110 )], elevation = 10 , color = \"#000000\" , )","title":"Shadow"},{"location":"reference/draw/primitives/#fill","text":"Fills the entire canvas with a solid color or gradient. nib . draw . Fill ( fill = \"#FFFFFF\" , blend_mode = None ) Parameter Type Default Description fill str \\| Color \\| Gradient \"#FFFFFF\" Fill color or gradient. blend_mode BlendMode None Blend mode for compositing. nib . draw . Fill ( fill = nib . draw . LinearGradient ( start = ( 0 , 0 ), end = ( 400 , 300 ), colors = [ nib . Color . RED , nib . Color . BLUE ], ))","title":"Fill"},{"location":"reference/draw/primitives/#colorfill","text":"Fills the canvas with a color using a specific blend mode. Useful for tinting effects. nib . draw . ColorFill ( color = \"#000000\" , blend_mode = BlendMode . NORMAL ) Parameter Type Default Description color str \\| Color \"#000000\" Color to paint. blend_mode BlendMode BlendMode.NORMAL Blend mode to apply. nib . draw . ColorFill ( color = nib . Color . RED , blend_mode = nib . BlendMode . MULTIPLY )","title":"ColorFill"},{"location":"reference/modifiers/","text":"Modifiers are constructor parameters shared by all Nib views. They control layout, appearance, typography, effects, and animation. Every view inherits these parameters from the base View class. import nib nib . Text ( \"Hello\" , font = nib . Font . TITLE , # Typography foreground_color = nib . Color . BLUE , # Appearance padding = 16 , # Layout shadow_radius = 4 , # Effects animation = nib . Animation . spring (), # Animation ) Complete Modifier Table \u00b6 Layout \u00b6 Parameter Type Default Description Details width float None Fixed width in points. Layout height float None Fixed height in points. Layout min_width float None Minimum width in points. Layout min_height float None Minimum height in points. Layout max_width float \\| str None Maximum width in points, or \"infinity\" . Layout max_height float \\| str None Maximum height in points, or \"infinity\" . Layout padding float \\| dict None Inner spacing (inside background). Layout margin float \\| dict None Outer spacing (outside background). Layout Appearance \u00b6 Parameter Type Default Description Details foreground_color Color \\| str None Text and content color. Appearance background Color \\| str \\| View None Background color or view. Appearance fill Color \\| str None Shape fill color. Appearance stroke Color \\| str None Shape stroke color. Appearance stroke_width float None Shape stroke thickness. Appearance opacity float None View transparency (0.0--1.0). Appearance corner_radius float \\| CornerRadius None Rounded corners in points. Appearance clip_shape str \\| View None Clip view to shape. Appearance visible bool True Show or hide view entirely. Appearance Typography \u00b6 Parameter Type Default Description Details font Font \\| str None Font configuration. Typography font_weight FontWeight \\| str None Text weight. Typography Effects \u00b6 Parameter Type Default Description Details shadow_color Color \\| str None Drop shadow color. Effects shadow_radius float None Drop shadow blur radius. Effects shadow_x float None Drop shadow horizontal offset. Effects shadow_y float None Drop shadow vertical offset. Effects border_color Color \\| str None Border color. Effects border_width float None Border width in points. Effects blend_mode BlendMode \\| str None Layer blending mode. Effects scale float None Scale transform factor. Effects offset Offset None Position offset (x, y). Effects animation Animation None Animation for property changes. Effects content_transition ContentTransition \\| str None How content changes animate. Effects transition Transition \\| str \\| TransitionConfig None How view appears/disappears. Effects Interaction \u00b6 Parameter Type Default Description on_drop Callable[[list[str]], None] None Callback for drag-and-drop file handling. on_hover Callable[[bool], None] None Callback when mouse enters/exits the view. on_click Callable[[], None] None Callback when the view is clicked. tooltip str \\| View None Tooltip text shown on hover. overlay View None View rendered on top of this view.","title":"Index"},{"location":"reference/modifiers/#complete-modifier-table","text":"","title":"Complete Modifier Table"},{"location":"reference/modifiers/#layout","text":"Parameter Type Default Description Details width float None Fixed width in points. Layout height float None Fixed height in points. Layout min_width float None Minimum width in points. Layout min_height float None Minimum height in points. Layout max_width float \\| str None Maximum width in points, or \"infinity\" . Layout max_height float \\| str None Maximum height in points, or \"infinity\" . Layout padding float \\| dict None Inner spacing (inside background). Layout margin float \\| dict None Outer spacing (outside background). Layout","title":"Layout"},{"location":"reference/modifiers/#appearance","text":"Parameter Type Default Description Details foreground_color Color \\| str None Text and content color. Appearance background Color \\| str \\| View None Background color or view. Appearance fill Color \\| str None Shape fill color. Appearance stroke Color \\| str None Shape stroke color. Appearance stroke_width float None Shape stroke thickness. Appearance opacity float None View transparency (0.0--1.0). Appearance corner_radius float \\| CornerRadius None Rounded corners in points. Appearance clip_shape str \\| View None Clip view to shape. Appearance visible bool True Show or hide view entirely. Appearance","title":"Appearance"},{"location":"reference/modifiers/#typography","text":"Parameter Type Default Description Details font Font \\| str None Font configuration. Typography font_weight FontWeight \\| str None Text weight. Typography","title":"Typography"},{"location":"reference/modifiers/#effects","text":"Parameter Type Default Description Details shadow_color Color \\| str None Drop shadow color. Effects shadow_radius float None Drop shadow blur radius. Effects shadow_x float None Drop shadow horizontal offset. Effects shadow_y float None Drop shadow vertical offset. Effects border_color Color \\| str None Border color. Effects border_width float None Border width in points. Effects blend_mode BlendMode \\| str None Layer blending mode. Effects scale float None Scale transform factor. Effects offset Offset None Position offset (x, y). Effects animation Animation None Animation for property changes. Effects content_transition ContentTransition \\| str None How content changes animate. Effects transition Transition \\| str \\| TransitionConfig None How view appears/disappears. Effects","title":"Effects"},{"location":"reference/modifiers/#interaction","text":"Parameter Type Default Description on_drop Callable[[list[str]], None] None Callback for drag-and-drop file handling. on_hover Callable[[bool], None] None Callback when mouse enters/exits the view. on_click Callable[[], None] None Callback when the view is clicked. tooltip str \\| View None Tooltip text shown on hover. overlay View None View rendered on top of this view.","title":"Interaction"},{"location":"reference/modifiers/appearance/","text":"Appearance modifiers control the visual presentation of views, including colors, fills, strokes, opacity, corner rounding, clipping, and visibility. import nib nib . Rectangle ( fill = nib . Color . BLUE , stroke = \"#FF0000\" , stroke_width = 2 , opacity = 0.9 , corner_radius = 12 , ) foreground_color \u00b6 Sets the color of text, icons, and other foreground content within a view. Type Default Color \\| str None Accepts a Color object, a named color string, or a hex string. nib . Text ( \"Blue text\" , foreground_color = nib . Color . BLUE ) nib . Text ( \"Red text\" , foreground_color = \"red\" ) nib . Text ( \"Custom color\" , foreground_color = \"#FF5733\" ) background \u00b6 Sets a background color or view behind the content. Accepts three types of values: Type Default Color \\| str \\| View None Color string or Color object: nib . Text ( \"On dark bg\" , background = \"#1E1E1E\" , foreground_color = \"white\" ) nib . Text ( \"On blue bg\" , background = nib . Color . BLUE ) Background view (e.g., a shape with styling): nib . VStack ( controls = [ nib . Text ( \"Card content\" )], background = nib . Rectangle ( corner_radius = 12 , fill = \"#262626\" , stroke = \"#383837\" , stroke_width = 1 , ), padding = 16 , ) fill \u00b6 Sets the interior color of shape views ( Rectangle , Circle , Capsule , Ellipse ). Also accepts gradient views. Type Default Color \\| str None nib . Circle ( fill = nib . Color . RED , width = 80 , height = 80 ) nib . Rectangle ( fill = \"#333333\" , width = 200 , height = 100 ) stroke \u00b6 Sets the outline color of shape views. Used in combination with stroke_width . Type Default Color \\| str None nib . Circle ( stroke = nib . Color . BLUE , stroke_width = 2 , width = 80 , height = 80 ) stroke_width \u00b6 Sets the thickness of the shape outline in points. Only applies when stroke is also set. Type Default float None nib . Rectangle ( stroke = \"red\" , stroke_width = 3 , width = 100 , height = 50 ) opacity \u00b6 Controls the transparency of a view and all its children. Values range from 0.0 (fully transparent) to 1.0 (fully opaque). Type Default float None nib . Text ( \"Faded\" , opacity = 0.5 ) nib . Rectangle ( fill = \"blue\" , width = 100 , height = 100 , opacity = 0.3 ) Opacity can be updated reactively: box = nib . Rectangle ( fill = \"blue\" , width = 100 , height = 100 , animation = nib . Animation . easeInOut ()) def toggle_opacity (): box . opacity = 0.2 if ( box . opacity or 1.0 ) > 0.5 else 1.0 corner_radius \u00b6 Rounds the corners of a view's bounds. Accepts a uniform radius or a CornerRadius object for per-corner control. Type Default float \\| CornerRadius None # Uniform corners nib . Rectangle ( fill = \"blue\" , corner_radius = 10 , width = 100 , height = 60 ) # Per-corner control nib . Rectangle ( fill = \"blue\" , corner_radius = nib . CornerRadius . vertical ( top = 16 , bottom = 0 ), width = 100 , height = 60 , ) clip_shape \u00b6 Clips the view's content to a specified shape. Content outside the shape is hidden. Type Default str \\| View None String values: \"circle\" , \"capsule\" , \"rectangle\" # Circular avatar nib . Image ( source = \"photo.jpg\" , width = 80 , height = 80 , clip_shape = \"circle\" ) # Pill-shaped button nib . Text ( \"Tag\" , padding = { \"horizontal\" : 12 , \"vertical\" : 6 }, background = \"blue\" , clip_shape = \"capsule\" ) Shape view (for custom corner radius): nib . Image ( source = \"photo.jpg\" , width = 200 , height = 150 , clip_shape = nib . Rectangle ( corner_radius = 16 ), ) visible \u00b6 Controls whether a view is included in the layout tree. When set to False , the view is completely removed and does not occupy any layout space. This is different from opacity=0 , where the view is invisible but still takes up space. Type Default bool True label = nib . Text ( \"Conditional content\" , visible = False ) def show (): label . visible = True Examples \u00b6 Styled card component \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Card Title\" , font = nib . Font . HEADLINE ), nib . Text ( \"This is a card with custom styling.\" , foreground_color = nib . Color . SECONDARY , ), ], spacing = 8 , padding = 16 , background = nib . Rectangle ( corner_radius = 12 , fill = \"#2A2A2A\" , stroke = \"#3A3A3A\" , stroke_width = 1 , ), shadow_color = \"black\" , shadow_radius = 8 , shadow_y = 4 , ) ) nib . run ( main ) Shape fills and strokes \u00b6 import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Circle ( fill = nib . Color . RED , width = 60 , height = 60 ), nib . Circle ( stroke = nib . Color . BLUE , stroke_width = 3 , width = 60 , height = 60 , ), nib . Rectangle ( fill = \"#333\" , stroke = nib . Color . ORANGE , stroke_width = 2 , corner_radius = 8 , width = 60 , height = 60 , ), ], spacing = 16 , padding = 20 , ) ) nib . run ( main )","title":"Appearance Modifiers"},{"location":"reference/modifiers/appearance/#foreground_color","text":"Sets the color of text, icons, and other foreground content within a view. Type Default Color \\| str None Accepts a Color object, a named color string, or a hex string. nib . Text ( \"Blue text\" , foreground_color = nib . Color . BLUE ) nib . Text ( \"Red text\" , foreground_color = \"red\" ) nib . Text ( \"Custom color\" , foreground_color = \"#FF5733\" )","title":"foreground_color"},{"location":"reference/modifiers/appearance/#background","text":"Sets a background color or view behind the content. Accepts three types of values: Type Default Color \\| str \\| View None Color string or Color object: nib . Text ( \"On dark bg\" , background = \"#1E1E1E\" , foreground_color = \"white\" ) nib . Text ( \"On blue bg\" , background = nib . Color . BLUE ) Background view (e.g., a shape with styling): nib . VStack ( controls = [ nib . Text ( \"Card content\" )], background = nib . Rectangle ( corner_radius = 12 , fill = \"#262626\" , stroke = \"#383837\" , stroke_width = 1 , ), padding = 16 , )","title":"background"},{"location":"reference/modifiers/appearance/#fill","text":"Sets the interior color of shape views ( Rectangle , Circle , Capsule , Ellipse ). Also accepts gradient views. Type Default Color \\| str None nib . Circle ( fill = nib . Color . RED , width = 80 , height = 80 ) nib . Rectangle ( fill = \"#333333\" , width = 200 , height = 100 )","title":"fill"},{"location":"reference/modifiers/appearance/#stroke","text":"Sets the outline color of shape views. Used in combination with stroke_width . Type Default Color \\| str None nib . Circle ( stroke = nib . Color . BLUE , stroke_width = 2 , width = 80 , height = 80 )","title":"stroke"},{"location":"reference/modifiers/appearance/#stroke_width","text":"Sets the thickness of the shape outline in points. Only applies when stroke is also set. Type Default float None nib . Rectangle ( stroke = \"red\" , stroke_width = 3 , width = 100 , height = 50 )","title":"stroke_width"},{"location":"reference/modifiers/appearance/#opacity","text":"Controls the transparency of a view and all its children. Values range from 0.0 (fully transparent) to 1.0 (fully opaque). Type Default float None nib . Text ( \"Faded\" , opacity = 0.5 ) nib . Rectangle ( fill = \"blue\" , width = 100 , height = 100 , opacity = 0.3 ) Opacity can be updated reactively: box = nib . Rectangle ( fill = \"blue\" , width = 100 , height = 100 , animation = nib . Animation . easeInOut ()) def toggle_opacity (): box . opacity = 0.2 if ( box . opacity or 1.0 ) > 0.5 else 1.0","title":"opacity"},{"location":"reference/modifiers/appearance/#corner_radius","text":"Rounds the corners of a view's bounds. Accepts a uniform radius or a CornerRadius object for per-corner control. Type Default float \\| CornerRadius None # Uniform corners nib . Rectangle ( fill = \"blue\" , corner_radius = 10 , width = 100 , height = 60 ) # Per-corner control nib . Rectangle ( fill = \"blue\" , corner_radius = nib . CornerRadius . vertical ( top = 16 , bottom = 0 ), width = 100 , height = 60 , )","title":"corner_radius"},{"location":"reference/modifiers/appearance/#clip_shape","text":"Clips the view's content to a specified shape. Content outside the shape is hidden. Type Default str \\| View None String values: \"circle\" , \"capsule\" , \"rectangle\" # Circular avatar nib . Image ( source = \"photo.jpg\" , width = 80 , height = 80 , clip_shape = \"circle\" ) # Pill-shaped button nib . Text ( \"Tag\" , padding = { \"horizontal\" : 12 , \"vertical\" : 6 }, background = \"blue\" , clip_shape = \"capsule\" ) Shape view (for custom corner radius): nib . Image ( source = \"photo.jpg\" , width = 200 , height = 150 , clip_shape = nib . Rectangle ( corner_radius = 16 ), )","title":"clip_shape"},{"location":"reference/modifiers/appearance/#visible","text":"Controls whether a view is included in the layout tree. When set to False , the view is completely removed and does not occupy any layout space. This is different from opacity=0 , where the view is invisible but still takes up space. Type Default bool True label = nib . Text ( \"Conditional content\" , visible = False ) def show (): label . visible = True","title":"visible"},{"location":"reference/modifiers/appearance/#examples","text":"","title":"Examples"},{"location":"reference/modifiers/appearance/#styled-card-component","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Card Title\" , font = nib . Font . HEADLINE ), nib . Text ( \"This is a card with custom styling.\" , foreground_color = nib . Color . SECONDARY , ), ], spacing = 8 , padding = 16 , background = nib . Rectangle ( corner_radius = 12 , fill = \"#2A2A2A\" , stroke = \"#3A3A3A\" , stroke_width = 1 , ), shadow_color = \"black\" , shadow_radius = 8 , shadow_y = 4 , ) ) nib . run ( main )","title":"Styled card component"},{"location":"reference/modifiers/appearance/#shape-fills-and-strokes","text":"import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Circle ( fill = nib . Color . RED , width = 60 , height = 60 ), nib . Circle ( stroke = nib . Color . BLUE , stroke_width = 3 , width = 60 , height = 60 , ), nib . Rectangle ( fill = \"#333\" , stroke = nib . Color . ORANGE , stroke_width = 2 , corner_radius = 8 , width = 60 , height = 60 , ), ], spacing = 16 , padding = 20 , ) ) nib . run ( main )","title":"Shape fills and strokes"},{"location":"reference/modifiers/effects/","text":"Effect modifiers add visual effects and transformations to views, including shadows, borders, blend modes, scaling, offsets, and animations. import nib nib . VStack ( controls = [ nib . Text ( \"Card\" )], shadow_color = \"black\" , shadow_radius = 10 , shadow_y = 4 , border_color = \"#CCCCCC\" , border_width = 1 , animation = nib . Animation . spring (), ) Shadow \u00b6 Drop shadows are controlled by four parameters that work together. At least one shadow parameter must be set for the shadow to render. shadow_color \u00b6 The color of the drop shadow. Type Default Color \\| str None shadow_radius \u00b6 The blur radius of the shadow in points. Larger values produce softer shadows. Type Default (when shadow is active) float 4.0 shadow_x \u00b6 Horizontal offset of the shadow in points. Positive values shift the shadow right. Type Default (when shadow is active) float 0.0 shadow_y \u00b6 Vertical offset of the shadow in points. Positive values shift the shadow down. Type Default (when shadow is active) float 2.0 # Basic shadow nib . Rectangle ( fill = \"white\" , shadow_color = \"black\" , shadow_radius = 8 ) # Customized shadow nib . VStack ( controls = [ nib . Text ( \"Elevated Card\" )], padding = 16 , background = \"#FFFFFF\" , corner_radius = 12 , shadow_color = \"black\" , shadow_radius = 12 , shadow_x = 0 , shadow_y = 6 , ) # Shadow with only radius (no color) nib . Rectangle ( fill = \"white\" , shadow_radius = 4 ) Border \u00b6 Border modifiers draw an outline around a view's bounds. Unlike stroke (which is for shapes), borders work on any view type. border_color \u00b6 The color of the border. Required for the border to render. Type Default Color \\| str None border_width \u00b6 The width of the border in points. Type Default (when border_color is set) float 1.0 # Default 1pt border nib . Rectangle ( fill = \"white\" , border_color = \"#CCCCCC\" ) # Custom border width nib . VStack ( controls = [ nib . Text ( \"Bordered content\" )], padding = 12 , border_color = nib . Color . RED , border_width = 2 , corner_radius = 8 , ) Note: border_width without border_color has no effect. blend_mode \u00b6 Controls how a view is composited with the content behind it. See BlendMode for all available modes. Type Default BlendMode \\| str None nib . Rectangle ( fill = nib . Color . BLUE , blend_mode = nib . BlendMode . MULTIPLY ) nib . Image ( source = \"overlay.png\" , blend_mode = \"screen\" ) scale \u00b6 Applies a uniform scale transformation to a view. The view is scaled from its center point. A value of 1.0 is the original size. Type Default float None nib . Image ( system_name = \"star.fill\" , scale = 2.0 ) # Double size nib . Text ( \"Small\" , scale = 0.75 ) # 75% size offset \u00b6 Shifts a view from its natural position. The view still occupies its original space in the layout. See Offset for constructor details. Type Default Offset None nib . Circle ( fill = nib . Color . BLUE , width = 50 , height = 50 , offset = nib . Offset ( 10 , - 5 ), ) Animation \u00b6 animation \u00b6 Configures how property changes on this view are animated. Once set, the animation is \"sticky\" -- all future property mutations on the view animate using this configuration. See Animation for factory methods and presets. Type Default Animation None # Spring animation on all property changes counter = nib . Text ( \"0\" , animation = nib . Animation . spring ()) def increment (): counter . content = str ( int ( counter . content ) + 1 ) # Animates automatically # Ease-in-out opacity toggle box = nib . Rectangle ( fill = \"blue\" , width = 100 , height = 100 , animation = nib . Animation . easeInOut ( 0.3 ), ) content_transition \u00b6 Controls how a view's content animates when it changes. This is separate from view transitions -- it affects the content within a view that remains visible. See ContentTransition for all values. Type Default ContentTransition \\| str None # Rolling numeric digits counter = nib . Text ( \"0\" , content_transition = nib . ContentTransition . NUMERIC_TEXT , animation = nib . Animation . spring (), ) # Fading content swap label = nib . Text ( \"Status\" , content_transition = nib . ContentTransition . OPACITY ) transition \u00b6 Controls how a view animates when it appears in or disappears from the view hierarchy. See Transition for all values, asymmetric transitions, and custom keyframes. Type Default Transition \\| str \\| TransitionConfig None # Simple fade panel = nib . VStack ( controls = [ ... ], transition = nib . Transition . OPACITY ) # Asymmetric: slide in, fade out panel = nib . VStack ( controls = [ ... ], transition = nib . Transition . asymmetric ( insertion = nib . Transition . SLIDE , removal = nib . Transition . OPACITY , ), ) # Combined: fade and scale simultaneously badge = nib . Text ( \"New\" , transition = nib . Transition . combined ( nib . Transition . OPACITY , nib . Transition . SCALE ), ) Examples \u00b6 Elevated card with shadow and border \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Notification\" , font = nib . Font . HEADLINE ), nib . Text ( \"You have 3 new messages.\" , foreground_color = nib . Color . SECONDARY , ), ], spacing = 6 , padding = 16 , background = \"#FFFFFF\" , corner_radius = 12 , border_color = \"#E0E0E0\" , border_width = 1 , shadow_color = \"black\" , shadow_radius = 10 , shadow_y = 4 , ) ) nib . run ( main ) Animated counter with effects \u00b6 import nib def main ( app : nib . App ): count = 0 label = nib . Text ( \"0\" , font = nib . Font . system ( 48 , nib . FontWeight . BOLD ), content_transition = nib . ContentTransition . NUMERIC_TEXT , animation = nib . Animation . spring ( response = 0.4 , damping = 0.6 ), ) def increment (): nonlocal count count += 1 label . content = str ( count ) app . build ( nib . VStack ( controls = [ label , nib . Button ( \"Add\" , action = increment , style = nib . ButtonStyle . BORDERED_PROMINENT , ), ], spacing = 16 , padding = 24 , ) ) nib . run ( main ) Overlapping views with offset and blend \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Circle ( fill = nib . Color . RED , width = 100 , height = 100 ), nib . Circle ( fill = nib . Color . BLUE , width = 100 , height = 100 , offset = nib . Offset ( 40 , 0 ), blend_mode = nib . BlendMode . SCREEN , ), ], padding = 40 , ) ) nib . run ( main )","title":"Effect Modifiers"},{"location":"reference/modifiers/effects/#shadow","text":"Drop shadows are controlled by four parameters that work together. At least one shadow parameter must be set for the shadow to render.","title":"Shadow"},{"location":"reference/modifiers/effects/#shadow_color","text":"The color of the drop shadow. Type Default Color \\| str None","title":"shadow_color"},{"location":"reference/modifiers/effects/#shadow_radius","text":"The blur radius of the shadow in points. Larger values produce softer shadows. Type Default (when shadow is active) float 4.0","title":"shadow_radius"},{"location":"reference/modifiers/effects/#shadow_x","text":"Horizontal offset of the shadow in points. Positive values shift the shadow right. Type Default (when shadow is active) float 0.0","title":"shadow_x"},{"location":"reference/modifiers/effects/#shadow_y","text":"Vertical offset of the shadow in points. Positive values shift the shadow down. Type Default (when shadow is active) float 2.0 # Basic shadow nib . Rectangle ( fill = \"white\" , shadow_color = \"black\" , shadow_radius = 8 ) # Customized shadow nib . VStack ( controls = [ nib . Text ( \"Elevated Card\" )], padding = 16 , background = \"#FFFFFF\" , corner_radius = 12 , shadow_color = \"black\" , shadow_radius = 12 , shadow_x = 0 , shadow_y = 6 , ) # Shadow with only radius (no color) nib . Rectangle ( fill = \"white\" , shadow_radius = 4 )","title":"shadow_y"},{"location":"reference/modifiers/effects/#border","text":"Border modifiers draw an outline around a view's bounds. Unlike stroke (which is for shapes), borders work on any view type.","title":"Border"},{"location":"reference/modifiers/effects/#border_color","text":"The color of the border. Required for the border to render. Type Default Color \\| str None","title":"border_color"},{"location":"reference/modifiers/effects/#border_width","text":"The width of the border in points. Type Default (when border_color is set) float 1.0 # Default 1pt border nib . Rectangle ( fill = \"white\" , border_color = \"#CCCCCC\" ) # Custom border width nib . VStack ( controls = [ nib . Text ( \"Bordered content\" )], padding = 12 , border_color = nib . Color . RED , border_width = 2 , corner_radius = 8 , ) Note: border_width without border_color has no effect.","title":"border_width"},{"location":"reference/modifiers/effects/#blend_mode","text":"Controls how a view is composited with the content behind it. See BlendMode for all available modes. Type Default BlendMode \\| str None nib . Rectangle ( fill = nib . Color . BLUE , blend_mode = nib . BlendMode . MULTIPLY ) nib . Image ( source = \"overlay.png\" , blend_mode = \"screen\" )","title":"blend_mode"},{"location":"reference/modifiers/effects/#scale","text":"Applies a uniform scale transformation to a view. The view is scaled from its center point. A value of 1.0 is the original size. Type Default float None nib . Image ( system_name = \"star.fill\" , scale = 2.0 ) # Double size nib . Text ( \"Small\" , scale = 0.75 ) # 75% size","title":"scale"},{"location":"reference/modifiers/effects/#offset","text":"Shifts a view from its natural position. The view still occupies its original space in the layout. See Offset for constructor details. Type Default Offset None nib . Circle ( fill = nib . Color . BLUE , width = 50 , height = 50 , offset = nib . Offset ( 10 , - 5 ), )","title":"offset"},{"location":"reference/modifiers/effects/#animation","text":"","title":"Animation"},{"location":"reference/modifiers/effects/#animation_1","text":"Configures how property changes on this view are animated. Once set, the animation is \"sticky\" -- all future property mutations on the view animate using this configuration. See Animation for factory methods and presets. Type Default Animation None # Spring animation on all property changes counter = nib . Text ( \"0\" , animation = nib . Animation . spring ()) def increment (): counter . content = str ( int ( counter . content ) + 1 ) # Animates automatically # Ease-in-out opacity toggle box = nib . Rectangle ( fill = \"blue\" , width = 100 , height = 100 , animation = nib . Animation . easeInOut ( 0.3 ), )","title":"animation"},{"location":"reference/modifiers/effects/#content_transition","text":"Controls how a view's content animates when it changes. This is separate from view transitions -- it affects the content within a view that remains visible. See ContentTransition for all values. Type Default ContentTransition \\| str None # Rolling numeric digits counter = nib . Text ( \"0\" , content_transition = nib . ContentTransition . NUMERIC_TEXT , animation = nib . Animation . spring (), ) # Fading content swap label = nib . Text ( \"Status\" , content_transition = nib . ContentTransition . OPACITY )","title":"content_transition"},{"location":"reference/modifiers/effects/#transition","text":"Controls how a view animates when it appears in or disappears from the view hierarchy. See Transition for all values, asymmetric transitions, and custom keyframes. Type Default Transition \\| str \\| TransitionConfig None # Simple fade panel = nib . VStack ( controls = [ ... ], transition = nib . Transition . OPACITY ) # Asymmetric: slide in, fade out panel = nib . VStack ( controls = [ ... ], transition = nib . Transition . asymmetric ( insertion = nib . Transition . SLIDE , removal = nib . Transition . OPACITY , ), ) # Combined: fade and scale simultaneously badge = nib . Text ( \"New\" , transition = nib . Transition . combined ( nib . Transition . OPACITY , nib . Transition . SCALE ), )","title":"transition"},{"location":"reference/modifiers/effects/#examples","text":"","title":"Examples"},{"location":"reference/modifiers/effects/#elevated-card-with-shadow-and-border","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Notification\" , font = nib . Font . HEADLINE ), nib . Text ( \"You have 3 new messages.\" , foreground_color = nib . Color . SECONDARY , ), ], spacing = 6 , padding = 16 , background = \"#FFFFFF\" , corner_radius = 12 , border_color = \"#E0E0E0\" , border_width = 1 , shadow_color = \"black\" , shadow_radius = 10 , shadow_y = 4 , ) ) nib . run ( main )","title":"Elevated card with shadow and border"},{"location":"reference/modifiers/effects/#animated-counter-with-effects","text":"import nib def main ( app : nib . App ): count = 0 label = nib . Text ( \"0\" , font = nib . Font . system ( 48 , nib . FontWeight . BOLD ), content_transition = nib . ContentTransition . NUMERIC_TEXT , animation = nib . Animation . spring ( response = 0.4 , damping = 0.6 ), ) def increment (): nonlocal count count += 1 label . content = str ( count ) app . build ( nib . VStack ( controls = [ label , nib . Button ( \"Add\" , action = increment , style = nib . ButtonStyle . BORDERED_PROMINENT , ), ], spacing = 16 , padding = 24 , ) ) nib . run ( main )","title":"Animated counter with effects"},{"location":"reference/modifiers/effects/#overlapping-views-with-offset-and-blend","text":"import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Circle ( fill = nib . Color . RED , width = 100 , height = 100 ), nib . Circle ( fill = nib . Color . BLUE , width = 100 , height = 100 , offset = nib . Offset ( 40 , 0 ), blend_mode = nib . BlendMode . SCREEN , ), ], padding = 40 , ) ) nib . run ( main )","title":"Overlapping views with offset and blend"},{"location":"reference/modifiers/layout/","text":"Layout modifiers control the size and spacing of views. They map to SwiftUI's .frame() and .padding() view modifiers. import nib nib . Text ( \"Hello\" , width = 200 , padding = 16 ) nib . VStack ( controls = [ ... ], min_width = 300 , max_width = \"infinity\" , height = 400 ) Frame Modifiers \u00b6 Frame modifiers set fixed or flexible dimensions on a view. width \u00b6 Fixed width in points. Type Default float None nib . Rectangle ( fill = \"blue\" , width = 100 , height = 50 ) height \u00b6 Fixed height in points. Type Default float None nib . Rectangle ( fill = \"blue\" , width = 100 , height = 50 ) min_width \u00b6 Minimum width constraint in points. The view will not shrink below this size. Type Default float None nib . TextField ( \"Search...\" , text = \"\" , min_width = 200 ) min_height \u00b6 Minimum height constraint in points. Type Default float None nib . TextEditor ( text = \"\" , min_height = 100 ) max_width \u00b6 Maximum width constraint. The view will not expand beyond this size. Use \"infinity\" or float(\"inf\") to fill all available horizontal space. Type Default float \\| str None # Fill available width nib . Rectangle ( fill = \"blue\" , max_width = \"infinity\" , height = 2 ) # Cap at 400 points nib . VStack ( controls = [ ... ], max_width = 400 ) max_height \u00b6 Maximum height constraint. Use \"infinity\" or float(\"inf\") to fill all available vertical space. Type Default float \\| str None nib . ScrollView ( controls = [ ... ], max_height = 300 ) Combining frame modifiers \u00b6 Frame modifiers can be combined to create flexible layouts: import nib # Fixed size box nib . Rectangle ( fill = \"blue\" , width = 100 , height = 100 ) # Flexible width with constraints nib . TextField ( \"Name\" , text = \"\" , min_width = 150 , max_width = 400 , height = 32 ) # Full-width container with fixed height nib . HStack ( controls = [ nib . Text ( \"Left\" ), nib . Spacer (), nib . Text ( \"Right\" )], max_width = \"infinity\" , height = 44 , padding = { \"horizontal\" : 16 }, ) Padding \u00b6 Padding adds space between a view's content and its boundary. It is applied inside the view's background. Type Default float \\| dict None Uniform padding \u00b6 A single numeric value applies equal padding to all four edges: nib . Text ( \"Padded\" , padding = 16 ) Edge-specific padding \u00b6 A dictionary specifying individual edges. Available keys: top , bottom , leading , trailing . nib . Text ( \"Custom padding\" , padding = { \"top\" : 8 , \"bottom\" : 8 , \"leading\" : 16 , \"trailing\" : 16 , }) Directional padding \u00b6 A dictionary with horizontal and/or vertical keys for symmetric padding: nib . Text ( \"Directional\" , padding = { \"horizontal\" : 16 , \"vertical\" : 8 }) This is equivalent to: nib . Text ( \"Directional\" , padding = { \"leading\" : 16 , \"trailing\" : 16 , \"top\" : 8 , \"bottom\" : 8 }) Padding examples \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ # Uniform padding nib . Text ( \"All sides: 20\" , background = \"#333\" , padding = 20 ), # Horizontal only nib . Text ( \"Horizontal: 24\" , background = \"#333\" , padding = { \"horizontal\" : 24 }), # Per-edge control nib . Text ( \"Custom edges\" , background = \"#333\" , padding = { \"top\" : 4 , \"bottom\" : 12 , \"leading\" : 20 , \"trailing\" : 8 , }), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Margin \u00b6 Margin adds space outside a view's bounds, after the background is rendered. This creates spacing between the view (including its background) and surrounding content. Type Default float \\| dict None Margin supports the same formats as padding: uniform value, edge-specific dictionary, or directional dictionary. # Uniform margin nib . Rectangle ( fill = \"blue\" , width = 100 , height = 100 , margin = 8 ) # Directional margin nib . Text ( \"Spaced\" , background = \"#333\" , margin = { \"horizontal\" : 16 , \"vertical\" : 8 }) # Edge-specific margin nib . VStack ( controls = [ ... ], margin = { \"top\" : 0 , \"bottom\" : 20 , \"leading\" : 16 , \"trailing\" : 16 }, ) Padding vs. Margin \u00b6 The key difference is where the space appears relative to the background: Padding is inside the background -- it increases the visible area of the background. Margin is outside the background -- it pushes the view away from its neighbors. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ # Padding: background extends behind the padding nib . Text ( \"Padding (inside bg)\" , background = \"#444\" , foreground_color = \"white\" , padding = 20 , ), # Margin: space outside the background nib . Text ( \"Margin (outside bg)\" , background = \"#444\" , foreground_color = \"white\" , margin = 20 , ), ], spacing = 0 , background = \"#222\" , padding = 16 , ) ) nib . run ( main )","title":"Layout Modifiers"},{"location":"reference/modifiers/layout/#frame-modifiers","text":"Frame modifiers set fixed or flexible dimensions on a view.","title":"Frame Modifiers"},{"location":"reference/modifiers/layout/#width","text":"Fixed width in points. Type Default float None nib . Rectangle ( fill = \"blue\" , width = 100 , height = 50 )","title":"width"},{"location":"reference/modifiers/layout/#height","text":"Fixed height in points. Type Default float None nib . Rectangle ( fill = \"blue\" , width = 100 , height = 50 )","title":"height"},{"location":"reference/modifiers/layout/#min_width","text":"Minimum width constraint in points. The view will not shrink below this size. Type Default float None nib . TextField ( \"Search...\" , text = \"\" , min_width = 200 )","title":"min_width"},{"location":"reference/modifiers/layout/#min_height","text":"Minimum height constraint in points. Type Default float None nib . TextEditor ( text = \"\" , min_height = 100 )","title":"min_height"},{"location":"reference/modifiers/layout/#max_width","text":"Maximum width constraint. The view will not expand beyond this size. Use \"infinity\" or float(\"inf\") to fill all available horizontal space. Type Default float \\| str None # Fill available width nib . Rectangle ( fill = \"blue\" , max_width = \"infinity\" , height = 2 ) # Cap at 400 points nib . VStack ( controls = [ ... ], max_width = 400 )","title":"max_width"},{"location":"reference/modifiers/layout/#max_height","text":"Maximum height constraint. Use \"infinity\" or float(\"inf\") to fill all available vertical space. Type Default float \\| str None nib . ScrollView ( controls = [ ... ], max_height = 300 )","title":"max_height"},{"location":"reference/modifiers/layout/#combining-frame-modifiers","text":"Frame modifiers can be combined to create flexible layouts: import nib # Fixed size box nib . Rectangle ( fill = \"blue\" , width = 100 , height = 100 ) # Flexible width with constraints nib . TextField ( \"Name\" , text = \"\" , min_width = 150 , max_width = 400 , height = 32 ) # Full-width container with fixed height nib . HStack ( controls = [ nib . Text ( \"Left\" ), nib . Spacer (), nib . Text ( \"Right\" )], max_width = \"infinity\" , height = 44 , padding = { \"horizontal\" : 16 }, )","title":"Combining frame modifiers"},{"location":"reference/modifiers/layout/#padding","text":"Padding adds space between a view's content and its boundary. It is applied inside the view's background. Type Default float \\| dict None","title":"Padding"},{"location":"reference/modifiers/layout/#uniform-padding","text":"A single numeric value applies equal padding to all four edges: nib . Text ( \"Padded\" , padding = 16 )","title":"Uniform padding"},{"location":"reference/modifiers/layout/#edge-specific-padding","text":"A dictionary specifying individual edges. Available keys: top , bottom , leading , trailing . nib . Text ( \"Custom padding\" , padding = { \"top\" : 8 , \"bottom\" : 8 , \"leading\" : 16 , \"trailing\" : 16 , })","title":"Edge-specific padding"},{"location":"reference/modifiers/layout/#directional-padding","text":"A dictionary with horizontal and/or vertical keys for symmetric padding: nib . Text ( \"Directional\" , padding = { \"horizontal\" : 16 , \"vertical\" : 8 }) This is equivalent to: nib . Text ( \"Directional\" , padding = { \"leading\" : 16 , \"trailing\" : 16 , \"top\" : 8 , \"bottom\" : 8 })","title":"Directional padding"},{"location":"reference/modifiers/layout/#padding-examples","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ # Uniform padding nib . Text ( \"All sides: 20\" , background = \"#333\" , padding = 20 ), # Horizontal only nib . Text ( \"Horizontal: 24\" , background = \"#333\" , padding = { \"horizontal\" : 24 }), # Per-edge control nib . Text ( \"Custom edges\" , background = \"#333\" , padding = { \"top\" : 4 , \"bottom\" : 12 , \"leading\" : 20 , \"trailing\" : 8 , }), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Padding examples"},{"location":"reference/modifiers/layout/#margin","text":"Margin adds space outside a view's bounds, after the background is rendered. This creates spacing between the view (including its background) and surrounding content. Type Default float \\| dict None Margin supports the same formats as padding: uniform value, edge-specific dictionary, or directional dictionary. # Uniform margin nib . Rectangle ( fill = \"blue\" , width = 100 , height = 100 , margin = 8 ) # Directional margin nib . Text ( \"Spaced\" , background = \"#333\" , margin = { \"horizontal\" : 16 , \"vertical\" : 8 }) # Edge-specific margin nib . VStack ( controls = [ ... ], margin = { \"top\" : 0 , \"bottom\" : 20 , \"leading\" : 16 , \"trailing\" : 16 }, )","title":"Margin"},{"location":"reference/modifiers/layout/#padding-vs-margin","text":"The key difference is where the space appears relative to the background: Padding is inside the background -- it increases the visible area of the background. Margin is outside the background -- it pushes the view away from its neighbors. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ # Padding: background extends behind the padding nib . Text ( \"Padding (inside bg)\" , background = \"#444\" , foreground_color = \"white\" , padding = 20 , ), # Margin: space outside the background nib . Text ( \"Margin (outside bg)\" , background = \"#444\" , foreground_color = \"white\" , margin = 20 , ), ], spacing = 0 , background = \"#222\" , padding = 16 , ) ) nib . run ( main )","title":"Padding vs. Margin"},{"location":"reference/modifiers/typography/","text":"Typography modifiers control the font and weight of text content within views. They map to SwiftUI's .font() view modifier. import nib nib . Text ( \"Title\" , font = nib . Font . TITLE , font_weight = nib . FontWeight . BOLD ) font \u00b6 Configures the font for text content. Accepts a Font object or a font family name string. Type Default Font \\| str None Using system fonts \u00b6 System fonts use Apple's semantic sizing, which adapts to accessibility settings: nib . Text ( \"Title\" , font = nib . Font . TITLE ) nib . Text ( \"Body\" , font = nib . Font . BODY ) nib . Text ( \"Caption\" , font = nib . Font . CAPTION ) See Font for all system font constants. Using custom sizes \u00b6 Create a font with a specific point size: nib . Text ( \"Custom\" , font = nib . Font . system ( 18 )) nib . Text ( \"Bold Custom\" , font = nib . Font . system ( 20 , nib . FontWeight . BOLD )) Using font family names \u00b6 Pass a string to use a named font family: nib . Text ( \"Helvetica\" , font = \"Helvetica Neue\" ) Using custom font files \u00b6 Load a font from a .ttf or .otf file: nib . Text ( \"Custom\" , font = nib . Font . custom ( \"Inter\" , 14 , path = \"fonts/Inter.ttf\" )) Font with weight embedded \u00b6 The Font.system() and Font.custom() methods accept an optional weight parameter: nib . Text ( \"Heavy\" , font = nib . Font . system ( 24 , nib . FontWeight . HEAVY )) nib . Text ( \"Light Custom\" , font = nib . Font . custom ( \"Inter\" , 16 , weight = nib . FontWeight . LIGHT )) font_weight \u00b6 Sets the font weight independently. This can be used alone or in combination with font . When both font (with a weight) and font_weight are specified, font_weight takes precedence. Type Default FontWeight \\| str None nib . Text ( \"Bold\" , font_weight = nib . FontWeight . BOLD ) nib . Text ( \"Semibold\" , font_weight = \"semibold\" ) nib . Text ( \"Light\" , font_weight = nib . FontWeight . LIGHT ) FontWeight values \u00b6 Value Description FontWeight.ULTRA_LIGHT Thinnest weight FontWeight.THIN Very thin FontWeight.LIGHT Light FontWeight.REGULAR Standard (default) FontWeight.MEDIUM Medium FontWeight.SEMIBOLD Semi-bold FontWeight.BOLD Bold FontWeight.HEAVY Heavy FontWeight.BLACK Heaviest weight Combining font and font_weight \u00b6 # font_weight overrides the weight in the Font object nib . Text ( \"Override\" , font = nib . Font . system ( 18 , nib . FontWeight . LIGHT ), font_weight = nib . FontWeight . BOLD , # This takes precedence ) Examples \u00b6 Typography scale \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Large Title\" , font = nib . Font . LARGE_TITLE ), nib . Text ( \"Title\" , font = nib . Font . TITLE ), nib . Text ( \"Headline\" , font = nib . Font . HEADLINE ), nib . Text ( \"Body\" , font = nib . Font . BODY ), nib . Text ( \"Callout\" , font = nib . Font . CALLOUT ), nib . Text ( \"Footnote\" , font = nib . Font . FOOTNOTE ), nib . Text ( \"Caption\" , font = nib . Font . CAPTION ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 4 , padding = 16 , ) ) nib . run ( main ) Mixed fonts in a layout \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Dashboard\" , font = nib . Font . LARGE_TITLE , font_weight = nib . FontWeight . BOLD ), nib . HStack ( controls = [ nib . Text ( \"Status:\" , font = nib . Font . BODY ), nib . Text ( \"Active\" , font_weight = nib . FontWeight . SEMIBOLD , foreground_color = nib . Color . GREEN ), ], spacing = 4 , ), nib . Text ( \"Last updated: just now\" , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY , ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Typography Modifiers"},{"location":"reference/modifiers/typography/#font","text":"Configures the font for text content. Accepts a Font object or a font family name string. Type Default Font \\| str None","title":"font"},{"location":"reference/modifiers/typography/#using-system-fonts","text":"System fonts use Apple's semantic sizing, which adapts to accessibility settings: nib . Text ( \"Title\" , font = nib . Font . TITLE ) nib . Text ( \"Body\" , font = nib . Font . BODY ) nib . Text ( \"Caption\" , font = nib . Font . CAPTION ) See Font for all system font constants.","title":"Using system fonts"},{"location":"reference/modifiers/typography/#using-custom-sizes","text":"Create a font with a specific point size: nib . Text ( \"Custom\" , font = nib . Font . system ( 18 )) nib . Text ( \"Bold Custom\" , font = nib . Font . system ( 20 , nib . FontWeight . BOLD ))","title":"Using custom sizes"},{"location":"reference/modifiers/typography/#using-font-family-names","text":"Pass a string to use a named font family: nib . Text ( \"Helvetica\" , font = \"Helvetica Neue\" )","title":"Using font family names"},{"location":"reference/modifiers/typography/#using-custom-font-files","text":"Load a font from a .ttf or .otf file: nib . Text ( \"Custom\" , font = nib . Font . custom ( \"Inter\" , 14 , path = \"fonts/Inter.ttf\" ))","title":"Using custom font files"},{"location":"reference/modifiers/typography/#font-with-weight-embedded","text":"The Font.system() and Font.custom() methods accept an optional weight parameter: nib . Text ( \"Heavy\" , font = nib . Font . system ( 24 , nib . FontWeight . HEAVY )) nib . Text ( \"Light Custom\" , font = nib . Font . custom ( \"Inter\" , 16 , weight = nib . FontWeight . LIGHT ))","title":"Font with weight embedded"},{"location":"reference/modifiers/typography/#font_weight","text":"Sets the font weight independently. This can be used alone or in combination with font . When both font (with a weight) and font_weight are specified, font_weight takes precedence. Type Default FontWeight \\| str None nib . Text ( \"Bold\" , font_weight = nib . FontWeight . BOLD ) nib . Text ( \"Semibold\" , font_weight = \"semibold\" ) nib . Text ( \"Light\" , font_weight = nib . FontWeight . LIGHT )","title":"font_weight"},{"location":"reference/modifiers/typography/#fontweight-values","text":"Value Description FontWeight.ULTRA_LIGHT Thinnest weight FontWeight.THIN Very thin FontWeight.LIGHT Light FontWeight.REGULAR Standard (default) FontWeight.MEDIUM Medium FontWeight.SEMIBOLD Semi-bold FontWeight.BOLD Bold FontWeight.HEAVY Heavy FontWeight.BLACK Heaviest weight","title":"FontWeight values"},{"location":"reference/modifiers/typography/#combining-font-and-font_weight","text":"# font_weight overrides the weight in the Font object nib . Text ( \"Override\" , font = nib . Font . system ( 18 , nib . FontWeight . LIGHT ), font_weight = nib . FontWeight . BOLD , # This takes precedence )","title":"Combining font and font_weight"},{"location":"reference/modifiers/typography/#examples","text":"","title":"Examples"},{"location":"reference/modifiers/typography/#typography-scale","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Large Title\" , font = nib . Font . LARGE_TITLE ), nib . Text ( \"Title\" , font = nib . Font . TITLE ), nib . Text ( \"Headline\" , font = nib . Font . HEADLINE ), nib . Text ( \"Body\" , font = nib . Font . BODY ), nib . Text ( \"Callout\" , font = nib . Font . CALLOUT ), nib . Text ( \"Footnote\" , font = nib . Font . FOOTNOTE ), nib . Text ( \"Caption\" , font = nib . Font . CAPTION ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 4 , padding = 16 , ) ) nib . run ( main )","title":"Typography scale"},{"location":"reference/modifiers/typography/#mixed-fonts-in-a-layout","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Dashboard\" , font = nib . Font . LARGE_TITLE , font_weight = nib . FontWeight . BOLD ), nib . HStack ( controls = [ nib . Text ( \"Status:\" , font = nib . Font . BODY ), nib . Text ( \"Active\" , font_weight = nib . FontWeight . SEMIBOLD , foreground_color = nib . Color . GREEN ), ], spacing = 4 , ), nib . Text ( \"Last updated: just now\" , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY , ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Mixed fonts in a layout"},{"location":"reference/notifications/","text":"Nib provides a comprehensive API for macOS notifications using the UserNotifications framework. You can push notifications immediately, schedule them for future delivery, add interactive action buttons with text input, and handle user responses. import nib def main ( app : nib . App ): # Request permission first app . notifications . request_permission () # Push a notification notification = nib . Notification ( title = \"Hello\" , body = \"This is a notification from Nib\" ) app . notifications . push ( notification ) nib . run ( main ) Overview \u00b6 The notification system consists of three parts: Class Description Notification Dataclass representing a single notification with title, body, sound, and actions NotificationManager Manager accessed via app.notifications for pushing, scheduling, canceling, and querying notifications Sound & Actions Supporting types: NotificationSound , NotificationSoundName , NotificationAction , NotificationActionOption , TextInputNotificationAction Quick Reference \u00b6 import nib from datetime import datetime , timedelta def main ( app : nib . App ): # Request permission app . notifications . request_permission ( callback = lambda granted : print ( f \"Permission: { granted } \" ) ) # Push immediately app . notifications . push ( nib . Notification ( title = \"Hello\" , body = \"World\" )) # Schedule for later app . notifications . schedule ( nib . Notification ( title = \"Reminder\" , body = \"Time to stretch!\" ), at = datetime . now () + timedelta ( minutes = 30 ), ) # Schedule daily app . notifications . schedule_daily ( nib . Notification ( title = \"Stand Up\" , body = \"Take a break\" ), from_time = \"09:00\" , ) # Cancel by ID n = nib . Notification ( title = \"Temp\" ) app . notifications . push ( n ) app . notifications . cancel_notification ( n . id ) # Cancel all app . notifications . cancel_all_notifications () # Handle user actions def on_action ( notification_id , action_id , user_text ): print ( f \"User tapped { action_id } on { notification_id } \" ) app . notifications . on_action ( on_action ) nib . run ( main ) Permission Notifications require user permission. Call app.notifications.request_permission() before pushing. On the first call, macOS shows a system dialog. Subsequent calls return the cached status. Critical Alerts Critical alert sounds ( NotificationSoundName.DEFAULT_CRITICAL ) require a special entitlement from Apple. Without it, the sound falls back to the default. Request the entitlement at developer.apple.com .","title":"Index"},{"location":"reference/notifications/#overview","text":"The notification system consists of three parts: Class Description Notification Dataclass representing a single notification with title, body, sound, and actions NotificationManager Manager accessed via app.notifications for pushing, scheduling, canceling, and querying notifications Sound & Actions Supporting types: NotificationSound , NotificationSoundName , NotificationAction , NotificationActionOption , TextInputNotificationAction","title":"Overview"},{"location":"reference/notifications/#quick-reference","text":"import nib from datetime import datetime , timedelta def main ( app : nib . App ): # Request permission app . notifications . request_permission ( callback = lambda granted : print ( f \"Permission: { granted } \" ) ) # Push immediately app . notifications . push ( nib . Notification ( title = \"Hello\" , body = \"World\" )) # Schedule for later app . notifications . schedule ( nib . Notification ( title = \"Reminder\" , body = \"Time to stretch!\" ), at = datetime . now () + timedelta ( minutes = 30 ), ) # Schedule daily app . notifications . schedule_daily ( nib . Notification ( title = \"Stand Up\" , body = \"Take a break\" ), from_time = \"09:00\" , ) # Cancel by ID n = nib . Notification ( title = \"Temp\" ) app . notifications . push ( n ) app . notifications . cancel_notification ( n . id ) # Cancel all app . notifications . cancel_all_notifications () # Handle user actions def on_action ( notification_id , action_id , user_text ): print ( f \"User tapped { action_id } on { notification_id } \" ) app . notifications . on_action ( on_action ) nib . run ( main ) Permission Notifications require user permission. Call app.notifications.request_permission() before pushing. On the first call, macOS shows a system dialog. Subsequent calls return the cached status. Critical Alerts Critical alert sounds ( NotificationSoundName.DEFAULT_CRITICAL ) require a special entitlement from Apple. Without it, the sound falls back to the default. Request the entitlement at developer.apple.com .","title":"Quick Reference"},{"location":"reference/notifications/manager/","text":"The NotificationManager handles all notification operations: pushing, scheduling, querying, canceling, and responding to user actions. Access it via app.notifications . app . notifications . push ( nib . Notification ( title = \"Hello\" , body = \"World\" )) Methods \u00b6 Permission \u00b6 request_permission(callback) \u00b6 Request notification permission from the user. On the first call, macOS shows a system permission dialog. Subsequent calls return the cached status. app . notifications . request_permission ( callback : Callable [[ bool ], None ] | None = None ) -> None Parameter Type Default Description callback Callable[[bool], None] \\| None None Optional function called with True if permission was granted, False otherwise Push \u00b6 push(notification) \u00b6 Push a notification for immediate delivery. app . notifications . push ( notification : Notification ) -> str Parameter Type Description notification Notification The notification to deliver immediately Returns the notification ID. Schedule \u00b6 schedule(notification, at) \u00b6 Schedule a notification for delivery at a specific date and time. If the target time is in the past, the notification is pushed immediately. app . notifications . schedule ( notification : Notification , at : datetime ) -> str Parameter Type Description notification Notification The notification to schedule at datetime The date and time when the notification should be delivered Returns the notification ID. reschedule(notification, at) \u00b6 Cancel an existing notification and schedule it for a new time. app . notifications . reschedule ( notification : Notification , at : datetime ) -> str Parameter Type Description notification Notification The notification to reschedule (must have the same id as the original) at datetime The new delivery time Returns the notification ID. schedule_daily(notification, from_time, to_time, count, from_date, to_date, interval) \u00b6 Schedule a notification that recurs daily. Supports time windows, multiple notifications per day, and date ranges. app . notifications . schedule_daily ( notification : Notification , from_time : str , to_time : str | None = None , count : int = 1 , from_date : date | None = None , to_date : date | None = None , interval : timedelta | None = None , ) -> str Parameter Type Default Description notification Notification -- The notification to schedule from_time str -- Start time in \"HH:MM\" format (e.g., \"08:00\" ) to_time str \\| None None Optional end time in \"HH:MM\" format count int 1 Number of notifications per day from_date date \\| None None Optional start date for the schedule to_date date \\| None None Optional end date for the schedule interval timedelta \\| None None Optional interval between notifications Returns the notification ID. Cancel \u00b6 cancel_notification(id) \u00b6 Cancel a specific notification by its ID. Works for both scheduled (pending) and delivered notifications. app . notifications . cancel_notification ( id : str ) -> None Parameter Type Description id str The notification ID to cancel cancel_all_notifications() \u00b6 Cancel all scheduled notifications and remove all delivered notifications from Notification Center. app . notifications . cancel_all_notifications () -> None Query \u00b6 get_all_scheduled_notifications(callback) \u00b6 Get all pending (scheduled but not yet delivered) notifications. app . notifications . get_all_scheduled_notifications ( callback : Callable [[ list [ Notification ]], None ] ) -> None Parameter Type Description callback Callable[[list[Notification]], None] Function called with the list of scheduled notifications get_all_delivered_notifications(callback) \u00b6 Get all delivered notifications still visible in Notification Center. app . notifications . get_all_delivered_notifications ( callback : Callable [[ list [ Notification ]], None ] ) -> None Parameter Type Description callback Callable[[list[Notification]], None] Function called with the list of delivered notifications get_scheduled_notification(id, callback) \u00b6 Get a specific scheduled notification by ID. app . notifications . get_scheduled_notification ( id : str , callback : Callable [[ Notification | None ], None ] ) -> None Parameter Type Description id str The notification ID to look up callback Callable[[Notification \\| None], None] Function called with the notification, or None if not found get_delivered_notification(id, callback) \u00b6 Get a specific delivered notification by ID. app . notifications . get_delivered_notification ( id : str , callback : Callable [[ Notification | None ], None ] ) -> None Parameter Type Description id str The notification ID to look up callback Callable[[Notification \\| None], None] Function called with the notification, or None if not found Action Handling \u00b6 on_action(callback) \u00b6 Register a handler for notification action callbacks. Called when the user interacts with a notification (taps an action button, types a reply, or clicks the notification itself). app . notifications . on_action ( callback : Callable [[ str , str , str | None ], None ] ) -> Callable [[], None ] Parameter Type Description callback Callable[[str, str, str \\| None], None] Function called with (notification_id, action_id, user_text) . user_text is the text entered if the action has a text_input field, otherwise None Returns an unsubscribe function. Call it to stop receiving callbacks. Built-in action IDs: Action ID When \"default\" User clicked the notification body \"dismiss\" User dismissed the notification Custom ID User tapped a custom action button Examples \u00b6 Push and schedule notifications \u00b6 import nib from datetime import datetime , timedelta def main ( app : nib . App ): app . title = \"Reminders\" app . icon = nib . SFSymbol ( \"bell.fill\" ) app . width = 320 app . height = 200 status = nib . Text ( \"Ready\" , foreground_color = nib . Color . SECONDARY ) # Request permission on startup app . notifications . request_permission ( callback = lambda granted : setattr ( status , \"content\" , \"Permission granted\" if granted else \"Permission denied\" ) ) def push_now (): app . notifications . push ( nib . Notification ( title = \"Instant\" , body = \"Delivered right now!\" ) ) status . content = \"Notification pushed\" def schedule_later (): n = nib . Notification ( title = \"Reminder\" , body = \"Time to take a break!\" ) app . notifications . schedule ( n , at = datetime . now () + timedelta ( seconds = 30 )) status . content = f \"Scheduled for 30s (ID: { n . id [: 8 ] } ...)\" def cancel_all (): app . notifications . cancel_all_notifications () status . content = \"All notifications cancelled\" app . build ( nib . VStack ( controls = [ nib . Text ( \"Reminders\" , font = nib . Font . HEADLINE ), nib . HStack ( controls = [ nib . Button ( \"Push Now\" , action = push_now ), nib . Button ( \"In 30s\" , action = schedule_later ), ], spacing = 8 , ), nib . Button ( \"Cancel All\" , action = cancel_all , role = nib . ButtonRole . DESTRUCTIVE ), status , ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Handle action callbacks \u00b6 import nib def main ( app : nib . App ): app . title = \"Chat\" app . icon = nib . SFSymbol ( \"message.fill\" ) app . width = 320 app . height = 180 last_reply = nib . Text ( \"No replies yet\" , foreground_color = nib . Color . SECONDARY ) def on_action ( notification_id , action_id , user_text ): if action_id == \"reply\" and user_text : last_reply . content = f \"You replied: { user_text } \" elif action_id == \"mark_read\" : last_reply . content = \"Marked as read\" elif action_id == \"default\" : last_reply . content = \"Notification clicked\" app . notifications . on_action ( on_action ) app . notifications . request_permission () def send_message (): app . notifications . push ( nib . Notification ( title = \"New Message\" , body = \"Alice: Want to grab lunch?\" , sound = nib . NotificationSound (), actions = [ nib . NotificationAction ( id = \"reply\" , title = \"Reply\" , text_input = nib . TextInputNotificationAction ( button_title = \"Send\" , placeholder = \"Type reply...\" , ), ), nib . NotificationAction ( id = \"mark_read\" , title = \"Mark as Read\" ), ], ) ) app . build ( nib . VStack ( controls = [ nib . Button ( \"Simulate Message\" , action = send_message , style = nib . ButtonStyle . BORDERED_PROMINENT ), last_reply , ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Daily recurring notification \u00b6 import nib from datetime import date , timedelta def main ( app : nib . App ): app . notifications . request_permission () # Daily reminder at 9 AM app . notifications . schedule_daily ( nib . Notification ( title = \"Good Morning\" , body = \"Time to start your day!\" , sound = nib . NotificationSound (), ), from_time = \"09:00\" , ) # Three reminders between 8 AM and 6 PM for one week app . notifications . schedule_daily ( nib . Notification ( title = \"Hydration\" , body = \"Drink some water!\" ), from_time = \"08:00\" , to_time = \"18:00\" , count = 3 , from_date = date . today (), to_date = date . today () + timedelta ( days = 7 ), ) nib . run ( main ) Query scheduled notifications \u00b6 import nib def main ( app : nib . App ): app . title = \"Scheduled\" app . icon = nib . SFSymbol ( \"clock\" ) app . width = 320 app . height = 200 count_text = nib . Text ( \"--\" , font = nib . Font . TITLE ) list_text = nib . Text ( \"\" , foreground_color = nib . Color . SECONDARY ) def check (): def on_result ( notifications ): count_text . content = f \" { len ( notifications ) } scheduled\" titles = [ n . title for n in notifications [: 5 ]] list_text . content = \" \\n \" . join ( titles ) if titles else \"None\" app . notifications . get_all_scheduled_notifications ( on_result ) app . on_appear = check app . build ( nib . VStack ( controls = [ count_text , list_text , nib . Button ( \"Refresh\" , action = check )], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Related \u00b6 Notification -- Notification dataclass Sound & Actions -- Sound and action button types","title":"NotificationManager"},{"location":"reference/notifications/manager/#methods","text":"","title":"Methods"},{"location":"reference/notifications/manager/#permission","text":"","title":"Permission"},{"location":"reference/notifications/manager/#request_permissioncallback","text":"Request notification permission from the user. On the first call, macOS shows a system permission dialog. Subsequent calls return the cached status. app . notifications . request_permission ( callback : Callable [[ bool ], None ] | None = None ) -> None Parameter Type Default Description callback Callable[[bool], None] \\| None None Optional function called with True if permission was granted, False otherwise","title":"request_permission(callback)"},{"location":"reference/notifications/manager/#push","text":"","title":"Push"},{"location":"reference/notifications/manager/#pushnotification","text":"Push a notification for immediate delivery. app . notifications . push ( notification : Notification ) -> str Parameter Type Description notification Notification The notification to deliver immediately Returns the notification ID.","title":"push(notification)"},{"location":"reference/notifications/manager/#schedule","text":"","title":"Schedule"},{"location":"reference/notifications/manager/#schedulenotification-at","text":"Schedule a notification for delivery at a specific date and time. If the target time is in the past, the notification is pushed immediately. app . notifications . schedule ( notification : Notification , at : datetime ) -> str Parameter Type Description notification Notification The notification to schedule at datetime The date and time when the notification should be delivered Returns the notification ID.","title":"schedule(notification, at)"},{"location":"reference/notifications/manager/#reschedulenotification-at","text":"Cancel an existing notification and schedule it for a new time. app . notifications . reschedule ( notification : Notification , at : datetime ) -> str Parameter Type Description notification Notification The notification to reschedule (must have the same id as the original) at datetime The new delivery time Returns the notification ID.","title":"reschedule(notification, at)"},{"location":"reference/notifications/manager/#schedule_dailynotification-from_time-to_time-count-from_date-to_date-interval","text":"Schedule a notification that recurs daily. Supports time windows, multiple notifications per day, and date ranges. app . notifications . schedule_daily ( notification : Notification , from_time : str , to_time : str | None = None , count : int = 1 , from_date : date | None = None , to_date : date | None = None , interval : timedelta | None = None , ) -> str Parameter Type Default Description notification Notification -- The notification to schedule from_time str -- Start time in \"HH:MM\" format (e.g., \"08:00\" ) to_time str \\| None None Optional end time in \"HH:MM\" format count int 1 Number of notifications per day from_date date \\| None None Optional start date for the schedule to_date date \\| None None Optional end date for the schedule interval timedelta \\| None None Optional interval between notifications Returns the notification ID.","title":"schedule_daily(notification, from_time, to_time, count, from_date, to_date, interval)"},{"location":"reference/notifications/manager/#cancel","text":"","title":"Cancel"},{"location":"reference/notifications/manager/#cancel_notificationid","text":"Cancel a specific notification by its ID. Works for both scheduled (pending) and delivered notifications. app . notifications . cancel_notification ( id : str ) -> None Parameter Type Description id str The notification ID to cancel","title":"cancel_notification(id)"},{"location":"reference/notifications/manager/#cancel_all_notifications","text":"Cancel all scheduled notifications and remove all delivered notifications from Notification Center. app . notifications . cancel_all_notifications () -> None","title":"cancel_all_notifications()"},{"location":"reference/notifications/manager/#query","text":"","title":"Query"},{"location":"reference/notifications/manager/#get_all_scheduled_notificationscallback","text":"Get all pending (scheduled but not yet delivered) notifications. app . notifications . get_all_scheduled_notifications ( callback : Callable [[ list [ Notification ]], None ] ) -> None Parameter Type Description callback Callable[[list[Notification]], None] Function called with the list of scheduled notifications","title":"get_all_scheduled_notifications(callback)"},{"location":"reference/notifications/manager/#get_all_delivered_notificationscallback","text":"Get all delivered notifications still visible in Notification Center. app . notifications . get_all_delivered_notifications ( callback : Callable [[ list [ Notification ]], None ] ) -> None Parameter Type Description callback Callable[[list[Notification]], None] Function called with the list of delivered notifications","title":"get_all_delivered_notifications(callback)"},{"location":"reference/notifications/manager/#get_scheduled_notificationid-callback","text":"Get a specific scheduled notification by ID. app . notifications . get_scheduled_notification ( id : str , callback : Callable [[ Notification | None ], None ] ) -> None Parameter Type Description id str The notification ID to look up callback Callable[[Notification \\| None], None] Function called with the notification, or None if not found","title":"get_scheduled_notification(id, callback)"},{"location":"reference/notifications/manager/#get_delivered_notificationid-callback","text":"Get a specific delivered notification by ID. app . notifications . get_delivered_notification ( id : str , callback : Callable [[ Notification | None ], None ] ) -> None Parameter Type Description id str The notification ID to look up callback Callable[[Notification \\| None], None] Function called with the notification, or None if not found","title":"get_delivered_notification(id, callback)"},{"location":"reference/notifications/manager/#action-handling","text":"","title":"Action Handling"},{"location":"reference/notifications/manager/#on_actioncallback","text":"Register a handler for notification action callbacks. Called when the user interacts with a notification (taps an action button, types a reply, or clicks the notification itself). app . notifications . on_action ( callback : Callable [[ str , str , str | None ], None ] ) -> Callable [[], None ] Parameter Type Description callback Callable[[str, str, str \\| None], None] Function called with (notification_id, action_id, user_text) . user_text is the text entered if the action has a text_input field, otherwise None Returns an unsubscribe function. Call it to stop receiving callbacks. Built-in action IDs: Action ID When \"default\" User clicked the notification body \"dismiss\" User dismissed the notification Custom ID User tapped a custom action button","title":"on_action(callback)"},{"location":"reference/notifications/manager/#examples","text":"","title":"Examples"},{"location":"reference/notifications/manager/#push-and-schedule-notifications","text":"import nib from datetime import datetime , timedelta def main ( app : nib . App ): app . title = \"Reminders\" app . icon = nib . SFSymbol ( \"bell.fill\" ) app . width = 320 app . height = 200 status = nib . Text ( \"Ready\" , foreground_color = nib . Color . SECONDARY ) # Request permission on startup app . notifications . request_permission ( callback = lambda granted : setattr ( status , \"content\" , \"Permission granted\" if granted else \"Permission denied\" ) ) def push_now (): app . notifications . push ( nib . Notification ( title = \"Instant\" , body = \"Delivered right now!\" ) ) status . content = \"Notification pushed\" def schedule_later (): n = nib . Notification ( title = \"Reminder\" , body = \"Time to take a break!\" ) app . notifications . schedule ( n , at = datetime . now () + timedelta ( seconds = 30 )) status . content = f \"Scheduled for 30s (ID: { n . id [: 8 ] } ...)\" def cancel_all (): app . notifications . cancel_all_notifications () status . content = \"All notifications cancelled\" app . build ( nib . VStack ( controls = [ nib . Text ( \"Reminders\" , font = nib . Font . HEADLINE ), nib . HStack ( controls = [ nib . Button ( \"Push Now\" , action = push_now ), nib . Button ( \"In 30s\" , action = schedule_later ), ], spacing = 8 , ), nib . Button ( \"Cancel All\" , action = cancel_all , role = nib . ButtonRole . DESTRUCTIVE ), status , ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Push and schedule notifications"},{"location":"reference/notifications/manager/#handle-action-callbacks","text":"import nib def main ( app : nib . App ): app . title = \"Chat\" app . icon = nib . SFSymbol ( \"message.fill\" ) app . width = 320 app . height = 180 last_reply = nib . Text ( \"No replies yet\" , foreground_color = nib . Color . SECONDARY ) def on_action ( notification_id , action_id , user_text ): if action_id == \"reply\" and user_text : last_reply . content = f \"You replied: { user_text } \" elif action_id == \"mark_read\" : last_reply . content = \"Marked as read\" elif action_id == \"default\" : last_reply . content = \"Notification clicked\" app . notifications . on_action ( on_action ) app . notifications . request_permission () def send_message (): app . notifications . push ( nib . Notification ( title = \"New Message\" , body = \"Alice: Want to grab lunch?\" , sound = nib . NotificationSound (), actions = [ nib . NotificationAction ( id = \"reply\" , title = \"Reply\" , text_input = nib . TextInputNotificationAction ( button_title = \"Send\" , placeholder = \"Type reply...\" , ), ), nib . NotificationAction ( id = \"mark_read\" , title = \"Mark as Read\" ), ], ) ) app . build ( nib . VStack ( controls = [ nib . Button ( \"Simulate Message\" , action = send_message , style = nib . ButtonStyle . BORDERED_PROMINENT ), last_reply , ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Handle action callbacks"},{"location":"reference/notifications/manager/#daily-recurring-notification","text":"import nib from datetime import date , timedelta def main ( app : nib . App ): app . notifications . request_permission () # Daily reminder at 9 AM app . notifications . schedule_daily ( nib . Notification ( title = \"Good Morning\" , body = \"Time to start your day!\" , sound = nib . NotificationSound (), ), from_time = \"09:00\" , ) # Three reminders between 8 AM and 6 PM for one week app . notifications . schedule_daily ( nib . Notification ( title = \"Hydration\" , body = \"Drink some water!\" ), from_time = \"08:00\" , to_time = \"18:00\" , count = 3 , from_date = date . today (), to_date = date . today () + timedelta ( days = 7 ), ) nib . run ( main )","title":"Daily recurring notification"},{"location":"reference/notifications/manager/#query-scheduled-notifications","text":"import nib def main ( app : nib . App ): app . title = \"Scheduled\" app . icon = nib . SFSymbol ( \"clock\" ) app . width = 320 app . height = 200 count_text = nib . Text ( \"--\" , font = nib . Font . TITLE ) list_text = nib . Text ( \"\" , foreground_color = nib . Color . SECONDARY ) def check (): def on_result ( notifications ): count_text . content = f \" { len ( notifications ) } scheduled\" titles = [ n . title for n in notifications [: 5 ]] list_text . content = \" \\n \" . join ( titles ) if titles else \"None\" app . notifications . get_all_scheduled_notifications ( on_result ) app . on_appear = check app . build ( nib . VStack ( controls = [ count_text , list_text , nib . Button ( \"Refresh\" , action = check )], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Query scheduled notifications"},{"location":"reference/notifications/manager/#related","text":"Notification -- Notification dataclass Sound & Actions -- Sound and action button types","title":"Related"},{"location":"reference/notifications/notification/","text":"The Notification dataclass represents a single macOS notification. It holds the content (title, body, subtitle), optional sound configuration, and optional action buttons. notification = nib . Notification ( title = \"Download Complete\" , body = \"Your file has been saved\" , ) app . notifications . push ( notification ) Constructor \u00b6 nib . Notification ( title : str , body : str = \"\" , subtitle : str = \"\" , sound : NotificationSound | None = None , actions : list [ NotificationAction ] = [], id : str | None = None , ) Parameters \u00b6 Parameter Type Default Description title str -- The main title of the notification (required) body str \"\" The body text displayed below the title subtitle str \"\" A secondary line of text displayed below the title and above the body sound NotificationSound \\| None None Sound configuration. Pass NotificationSound() for the default sound, or configure a custom sound actions list[NotificationAction] [] List of action buttons displayed on the notification id str \\| None Auto-generated UUID Unique identifier for this notification. Used for canceling or querying. Auto-generated if not provided Properties \u00b6 Property Type Description title str The notification title body str The notification body text subtitle str The notification subtitle sound NotificationSound \\| None Sound configuration actions list[NotificationAction] Action buttons id str Unique notification identifier Methods \u00b6 to_dict() \u00b6 Convert the notification to a dictionary for serialization. Used internally when sending to the Swift runtime. notification . to_dict () -> dict Notification.from_dict(data) \u00b6 Class method to create a Notification from a dictionary. Used internally when receiving notification data from the Swift runtime. Notification . from_dict ( data : dict ) -> Notification Examples \u00b6 Simple notification \u00b6 import nib def main ( app : nib . App ): app . title = \"Notify\" app . icon = nib . SFSymbol ( \"bell\" ) app . width = 280 app . height = 100 def send (): notification = nib . Notification ( title = \"Hello!\" , body = \"This is a notification from your Nib app.\" , ) app . notifications . push ( notification ) app . build ( nib . VStack ( controls = [ nib . Button ( \"Send Notification\" , action = send )], padding = 20 , ) ) nib . run ( main ) Notification with subtitle and sound \u00b6 import nib notification = nib . Notification ( title = \"New Message\" , subtitle = \"From: Alice\" , body = \"Hey, are you free for coffee?\" , sound = nib . NotificationSound ( name = nib . NotificationSoundName . DEFAULT ), ) Notification with action buttons \u00b6 import nib notification = nib . Notification ( title = \"New Message\" , body = \"John: Hey, are you there?\" , sound = nib . NotificationSound (), actions = [ nib . NotificationAction ( id = \"reply\" , title = \"Reply\" , options = [ nib . NotificationActionOption . FOREGROUND ], text_input = nib . TextInputNotificationAction ( button_title = \"Send\" , placeholder = \"Type your reply...\" , ), ), nib . NotificationAction ( id = \"mark_read\" , title = \"Mark as Read\" , ), nib . NotificationAction ( id = \"delete\" , title = \"Delete\" , options = [ nib . NotificationActionOption . DESTRUCTIVE ], ), ], ) Notification with a custom ID for later cancellation \u00b6 import nib # Use a stable ID so you can cancel or replace it later notification = nib . Notification ( title = \"Downloading...\" , body = \"50 % c omplete\" , id = \"download-progress\" , ) app . notifications . push ( notification ) # Update the same notification by reusing the ID updated = nib . Notification ( title = \"Downloading...\" , body = \"100 % c omplete\" , id = \"download-progress\" , ) app . notifications . push ( updated ) # Cancel it app . notifications . cancel_notification ( \"download-progress\" ) Related \u00b6 NotificationManager -- Push, schedule, and manage notifications Sound & Actions -- Configure sounds and action buttons","title":"Notification"},{"location":"reference/notifications/notification/#constructor","text":"nib . Notification ( title : str , body : str = \"\" , subtitle : str = \"\" , sound : NotificationSound | None = None , actions : list [ NotificationAction ] = [], id : str | None = None , )","title":"Constructor"},{"location":"reference/notifications/notification/#parameters","text":"Parameter Type Default Description title str -- The main title of the notification (required) body str \"\" The body text displayed below the title subtitle str \"\" A secondary line of text displayed below the title and above the body sound NotificationSound \\| None None Sound configuration. Pass NotificationSound() for the default sound, or configure a custom sound actions list[NotificationAction] [] List of action buttons displayed on the notification id str \\| None Auto-generated UUID Unique identifier for this notification. Used for canceling or querying. Auto-generated if not provided","title":"Parameters"},{"location":"reference/notifications/notification/#properties","text":"Property Type Description title str The notification title body str The notification body text subtitle str The notification subtitle sound NotificationSound \\| None Sound configuration actions list[NotificationAction] Action buttons id str Unique notification identifier","title":"Properties"},{"location":"reference/notifications/notification/#methods","text":"","title":"Methods"},{"location":"reference/notifications/notification/#to_dict","text":"Convert the notification to a dictionary for serialization. Used internally when sending to the Swift runtime. notification . to_dict () -> dict","title":"to_dict()"},{"location":"reference/notifications/notification/#notificationfrom_dictdata","text":"Class method to create a Notification from a dictionary. Used internally when receiving notification data from the Swift runtime. Notification . from_dict ( data : dict ) -> Notification","title":"Notification.from_dict(data)"},{"location":"reference/notifications/notification/#examples","text":"","title":"Examples"},{"location":"reference/notifications/notification/#simple-notification","text":"import nib def main ( app : nib . App ): app . title = \"Notify\" app . icon = nib . SFSymbol ( \"bell\" ) app . width = 280 app . height = 100 def send (): notification = nib . Notification ( title = \"Hello!\" , body = \"This is a notification from your Nib app.\" , ) app . notifications . push ( notification ) app . build ( nib . VStack ( controls = [ nib . Button ( \"Send Notification\" , action = send )], padding = 20 , ) ) nib . run ( main )","title":"Simple notification"},{"location":"reference/notifications/notification/#notification-with-subtitle-and-sound","text":"import nib notification = nib . Notification ( title = \"New Message\" , subtitle = \"From: Alice\" , body = \"Hey, are you free for coffee?\" , sound = nib . NotificationSound ( name = nib . NotificationSoundName . DEFAULT ), )","title":"Notification with subtitle and sound"},{"location":"reference/notifications/notification/#notification-with-action-buttons","text":"import nib notification = nib . Notification ( title = \"New Message\" , body = \"John: Hey, are you there?\" , sound = nib . NotificationSound (), actions = [ nib . NotificationAction ( id = \"reply\" , title = \"Reply\" , options = [ nib . NotificationActionOption . FOREGROUND ], text_input = nib . TextInputNotificationAction ( button_title = \"Send\" , placeholder = \"Type your reply...\" , ), ), nib . NotificationAction ( id = \"mark_read\" , title = \"Mark as Read\" , ), nib . NotificationAction ( id = \"delete\" , title = \"Delete\" , options = [ nib . NotificationActionOption . DESTRUCTIVE ], ), ], )","title":"Notification with action buttons"},{"location":"reference/notifications/notification/#notification-with-a-custom-id-for-later-cancellation","text":"import nib # Use a stable ID so you can cancel or replace it later notification = nib . Notification ( title = \"Downloading...\" , body = \"50 % c omplete\" , id = \"download-progress\" , ) app . notifications . push ( notification ) # Update the same notification by reusing the ID updated = nib . Notification ( title = \"Downloading...\" , body = \"100 % c omplete\" , id = \"download-progress\" , ) app . notifications . push ( updated ) # Cancel it app . notifications . cancel_notification ( \"download-progress\" )","title":"Notification with a custom ID for later cancellation"},{"location":"reference/notifications/notification/#related","text":"NotificationManager -- Push, schedule, and manage notifications Sound & Actions -- Configure sounds and action buttons","title":"Related"},{"location":"reference/notifications/types/","text":"Supporting types for configuring notification sounds and interactive action buttons. NotificationSound \u00b6 Configuration for the sound played when a notification is delivered. Constructor \u00b6 nib . NotificationSound ( name : NotificationSoundName | CustomNotificationSoundName = NotificationSoundName . DEFAULT , volume : float = 1.0 , ) Parameters \u00b6 Parameter Type Default Description name NotificationSoundName \\| CustomNotificationSoundName NotificationSoundName.DEFAULT The sound to play volume float 1.0 Volume level from 0.0 to 1.0 . Only applies to critical alerts Examples \u00b6 # Default notification sound sound = nib . NotificationSound () # Explicit default sound = nib . NotificationSound ( name = nib . NotificationSoundName . DEFAULT ) # Custom macOS system sound sound = nib . NotificationSound ( name = nib . NotificationSoundName . custom ( \"Glass\" )) # Custom sound file (must be .aiff, .wav, .caff, or .mp3, under 30 seconds) sound = nib . NotificationSound ( name = nib . NotificationSoundName . custom ( \"alert.aiff\" )) # Critical alert (requires Apple entitlement) sound = nib . NotificationSound ( name = nib . NotificationSoundName . DEFAULT_CRITICAL , volume = 1.0 , ) NotificationSoundName \u00b6 Enum of built-in notification sound names. import nib # or: from nib.notifications.types import NotificationSoundName Value Description NotificationSoundName.DEFAULT The default notification sound NotificationSoundName.DEFAULT_CRITICAL Critical alert sound (requires Apple entitlement) NotificationSoundName.custom(name) \u00b6 Create a custom sound name from a file name or built-in macOS sound name. NotificationSoundName . custom ( name : str ) -> CustomNotificationSoundName Parameter Type Description name str Sound file name ( .aiff , .wav , .caff , .mp3 ) or a built-in macOS sound name Custom sound files must be: Less than 30 seconds in duration Placed in the app bundle's sound resources, or in ~/Library/Sounds Built-in macOS sound names that can be used directly: Basso , Blow , Bottle , Frog , Funk , Glass , Hero , Morse , Ping , Pop , Purr , Sosumi , Submarine , Tink # Using a built-in macOS sound sound = nib . NotificationSound ( name = nib . NotificationSoundName . custom ( \"Frog\" )) # Using a custom sound file in the app bundle sound = nib . NotificationSound ( name = nib . NotificationSoundName . custom ( \"mysound.aiff\" )) CustomNotificationSoundName \u00b6 Wrapper for custom sound names. Created via NotificationSoundName.custom() , not instantiated directly. Property Type Description name str The sound file name or built-in sound name value str Same as name , used for serialization NotificationAction \u00b6 An action button displayed on a notification. Actions allow users to respond to notifications without opening the app. Constructor \u00b6 nib . NotificationAction ( id : str , title : str , options : list [ NotificationActionOption ] = [], text_input : TextInputNotificationAction | None = None , ) Parameters \u00b6 Parameter Type Default Description id str -- Unique identifier for this action, received in the on_action callback title str -- Display title for the action button options list[NotificationActionOption] [] Behavioral flags for the action. Empty list means the action runs in the background text_input TextInputNotificationAction \\| None None Optional text input configuration for reply-style actions Examples \u00b6 # Simple action button action = nib . NotificationAction ( id = \"mark_read\" , title = \"Mark as Read\" , ) # Reply action with text input action = nib . NotificationAction ( id = \"reply\" , title = \"Reply\" , options = [ nib . NotificationActionOption . FOREGROUND ], text_input = nib . TextInputNotificationAction ( button_title = \"Send\" , placeholder = \"Type your reply...\" , ), ) # Destructive action requiring authentication action = nib . NotificationAction ( id = \"delete\" , title = \"Delete\" , options = [ nib . NotificationActionOption . DESTRUCTIVE , nib . NotificationActionOption . AUTHENTICATION_REQUIRED , ], ) NotificationActionOption \u00b6 Enum of behavioral flags for notification action buttons. import nib # or: from nib.notifications.types import NotificationActionOption Value Description NotificationActionOption.FOREGROUND Brings the app to the foreground when the action is triggered NotificationActionOption.DESTRUCTIVE Displays the action button in red, indicating a destructive operation NotificationActionOption.AUTHENTICATION_REQUIRED Requires the device to be unlocked before executing the action TextInputNotificationAction \u00b6 Configuration for adding a text input field to a notification action. When attached to a NotificationAction , users can type a response directly in the notification banner. Constructor \u00b6 nib . TextInputNotificationAction ( button_title : str = \"Send\" , placeholder : str = \"Type message...\" , ) Parameters \u00b6 Parameter Type Default Description button_title str \"Send\" Title of the send/submit button placeholder str \"Type message...\" Placeholder text in the input field Example \u00b6 text_input = nib . TextInputNotificationAction ( button_title = \"Reply\" , placeholder = \"Type your reply...\" , ) action = nib . NotificationAction ( id = \"reply\" , title = \"Reply\" , text_input = text_input , ) Complete Example \u00b6 A full notification with sound, multiple actions, and text input: import nib def main ( app : nib . App ): app . title = \"Chat\" app . icon = nib . SFSymbol ( \"message\" ) app . width = 300 app . height = 150 app . notifications . request_permission () def on_action ( notification_id , action_id , user_text ): if action_id == \"reply\" and user_text : print ( f \"Reply: { user_text } \" ) elif action_id == \"like\" : print ( \"Liked the message\" ) elif action_id == \"delete\" : print ( \"Message deleted\" ) app . notifications . on_action ( on_action ) def send (): notification = nib . Notification ( title = \"Alice\" , subtitle = \"iMessage\" , body = \"Hey, want to grab coffee tomorrow?\" , sound = nib . NotificationSound ( name = nib . NotificationSoundName . custom ( \"Glass\" ), ), actions = [ nib . NotificationAction ( id = \"reply\" , title = \"Reply\" , options = [ nib . NotificationActionOption . FOREGROUND ], text_input = nib . TextInputNotificationAction ( button_title = \"Send\" , placeholder = \"iMessage\" , ), ), nib . NotificationAction ( id = \"like\" , title = \"Thumbs Up\" , ), nib . NotificationAction ( id = \"delete\" , title = \"Delete\" , options = [ nib . NotificationActionOption . DESTRUCTIVE , nib . NotificationActionOption . AUTHENTICATION_REQUIRED , ], ), ], ) app . notifications . push ( notification ) app . build ( nib . VStack ( controls = [ nib . Button ( \"Send Message\" , action = send )], padding = 20 , ) ) nib . run ( main ) Related \u00b6 Notification -- The notification dataclass NotificationManager -- Push, schedule, and manage notifications","title":"Sound & Actions"},{"location":"reference/notifications/types/#notificationsound","text":"Configuration for the sound played when a notification is delivered.","title":"NotificationSound"},{"location":"reference/notifications/types/#constructor","text":"nib . NotificationSound ( name : NotificationSoundName | CustomNotificationSoundName = NotificationSoundName . DEFAULT , volume : float = 1.0 , )","title":"Constructor"},{"location":"reference/notifications/types/#parameters","text":"Parameter Type Default Description name NotificationSoundName \\| CustomNotificationSoundName NotificationSoundName.DEFAULT The sound to play volume float 1.0 Volume level from 0.0 to 1.0 . Only applies to critical alerts","title":"Parameters"},{"location":"reference/notifications/types/#examples","text":"# Default notification sound sound = nib . NotificationSound () # Explicit default sound = nib . NotificationSound ( name = nib . NotificationSoundName . DEFAULT ) # Custom macOS system sound sound = nib . NotificationSound ( name = nib . NotificationSoundName . custom ( \"Glass\" )) # Custom sound file (must be .aiff, .wav, .caff, or .mp3, under 30 seconds) sound = nib . NotificationSound ( name = nib . NotificationSoundName . custom ( \"alert.aiff\" )) # Critical alert (requires Apple entitlement) sound = nib . NotificationSound ( name = nib . NotificationSoundName . DEFAULT_CRITICAL , volume = 1.0 , )","title":"Examples"},{"location":"reference/notifications/types/#notificationsoundname","text":"Enum of built-in notification sound names. import nib # or: from nib.notifications.types import NotificationSoundName Value Description NotificationSoundName.DEFAULT The default notification sound NotificationSoundName.DEFAULT_CRITICAL Critical alert sound (requires Apple entitlement)","title":"NotificationSoundName"},{"location":"reference/notifications/types/#notificationsoundnamecustomname","text":"Create a custom sound name from a file name or built-in macOS sound name. NotificationSoundName . custom ( name : str ) -> CustomNotificationSoundName Parameter Type Description name str Sound file name ( .aiff , .wav , .caff , .mp3 ) or a built-in macOS sound name Custom sound files must be: Less than 30 seconds in duration Placed in the app bundle's sound resources, or in ~/Library/Sounds Built-in macOS sound names that can be used directly: Basso , Blow , Bottle , Frog , Funk , Glass , Hero , Morse , Ping , Pop , Purr , Sosumi , Submarine , Tink # Using a built-in macOS sound sound = nib . NotificationSound ( name = nib . NotificationSoundName . custom ( \"Frog\" )) # Using a custom sound file in the app bundle sound = nib . NotificationSound ( name = nib . NotificationSoundName . custom ( \"mysound.aiff\" ))","title":"NotificationSoundName.custom(name)"},{"location":"reference/notifications/types/#customnotificationsoundname","text":"Wrapper for custom sound names. Created via NotificationSoundName.custom() , not instantiated directly. Property Type Description name str The sound file name or built-in sound name value str Same as name , used for serialization","title":"CustomNotificationSoundName"},{"location":"reference/notifications/types/#notificationaction","text":"An action button displayed on a notification. Actions allow users to respond to notifications without opening the app.","title":"NotificationAction"},{"location":"reference/notifications/types/#constructor_1","text":"nib . NotificationAction ( id : str , title : str , options : list [ NotificationActionOption ] = [], text_input : TextInputNotificationAction | None = None , )","title":"Constructor"},{"location":"reference/notifications/types/#parameters_1","text":"Parameter Type Default Description id str -- Unique identifier for this action, received in the on_action callback title str -- Display title for the action button options list[NotificationActionOption] [] Behavioral flags for the action. Empty list means the action runs in the background text_input TextInputNotificationAction \\| None None Optional text input configuration for reply-style actions","title":"Parameters"},{"location":"reference/notifications/types/#examples_1","text":"# Simple action button action = nib . NotificationAction ( id = \"mark_read\" , title = \"Mark as Read\" , ) # Reply action with text input action = nib . NotificationAction ( id = \"reply\" , title = \"Reply\" , options = [ nib . NotificationActionOption . FOREGROUND ], text_input = nib . TextInputNotificationAction ( button_title = \"Send\" , placeholder = \"Type your reply...\" , ), ) # Destructive action requiring authentication action = nib . NotificationAction ( id = \"delete\" , title = \"Delete\" , options = [ nib . NotificationActionOption . DESTRUCTIVE , nib . NotificationActionOption . AUTHENTICATION_REQUIRED , ], )","title":"Examples"},{"location":"reference/notifications/types/#notificationactionoption","text":"Enum of behavioral flags for notification action buttons. import nib # or: from nib.notifications.types import NotificationActionOption Value Description NotificationActionOption.FOREGROUND Brings the app to the foreground when the action is triggered NotificationActionOption.DESTRUCTIVE Displays the action button in red, indicating a destructive operation NotificationActionOption.AUTHENTICATION_REQUIRED Requires the device to be unlocked before executing the action","title":"NotificationActionOption"},{"location":"reference/notifications/types/#textinputnotificationaction","text":"Configuration for adding a text input field to a notification action. When attached to a NotificationAction , users can type a response directly in the notification banner.","title":"TextInputNotificationAction"},{"location":"reference/notifications/types/#constructor_2","text":"nib . TextInputNotificationAction ( button_title : str = \"Send\" , placeholder : str = \"Type message...\" , )","title":"Constructor"},{"location":"reference/notifications/types/#parameters_2","text":"Parameter Type Default Description button_title str \"Send\" Title of the send/submit button placeholder str \"Type message...\" Placeholder text in the input field","title":"Parameters"},{"location":"reference/notifications/types/#example","text":"text_input = nib . TextInputNotificationAction ( button_title = \"Reply\" , placeholder = \"Type your reply...\" , ) action = nib . NotificationAction ( id = \"reply\" , title = \"Reply\" , text_input = text_input , )","title":"Example"},{"location":"reference/notifications/types/#complete-example","text":"A full notification with sound, multiple actions, and text input: import nib def main ( app : nib . App ): app . title = \"Chat\" app . icon = nib . SFSymbol ( \"message\" ) app . width = 300 app . height = 150 app . notifications . request_permission () def on_action ( notification_id , action_id , user_text ): if action_id == \"reply\" and user_text : print ( f \"Reply: { user_text } \" ) elif action_id == \"like\" : print ( \"Liked the message\" ) elif action_id == \"delete\" : print ( \"Message deleted\" ) app . notifications . on_action ( on_action ) def send (): notification = nib . Notification ( title = \"Alice\" , subtitle = \"iMessage\" , body = \"Hey, want to grab coffee tomorrow?\" , sound = nib . NotificationSound ( name = nib . NotificationSoundName . custom ( \"Glass\" ), ), actions = [ nib . NotificationAction ( id = \"reply\" , title = \"Reply\" , options = [ nib . NotificationActionOption . FOREGROUND ], text_input = nib . TextInputNotificationAction ( button_title = \"Send\" , placeholder = \"iMessage\" , ), ), nib . NotificationAction ( id = \"like\" , title = \"Thumbs Up\" , ), nib . NotificationAction ( id = \"delete\" , title = \"Delete\" , options = [ nib . NotificationActionOption . DESTRUCTIVE , nib . NotificationActionOption . AUTHENTICATION_REQUIRED , ], ), ], ) app . notifications . push ( notification ) app . build ( nib . VStack ( controls = [ nib . Button ( \"Send Message\" , action = send )], padding = 20 , ) ) nib . run ( main )","title":"Complete Example"},{"location":"reference/notifications/types/#related","text":"Notification -- The notification dataclass NotificationManager -- Push, schedule, and manage notifications","title":"Related"},{"location":"reference/services/","text":"Nib provides access to macOS system services through properties on the App instance. Each service communicates with the Swift runtime over the same socket used for view rendering, using a synchronous request/response pattern. All services are accessed as properties on app : import nib def main ( app : nib . App ): # Battery status = app . battery . get_status () # Network info = app . connectivity . get_status () # Screen screen = app . screen . get_info () # Keychain app . keychain . set ( \"MyApp\" , \"token\" , \"secret123\" ) # Camera devices = app . camera . list_devices () # Launch at Login app . launch_at_login . set ( True ) # Permissions status = app . permissions . check ( nib . Permission . CAMERA ) nib . run ( main ) Available Services \u00b6 Service Access Description Battery app.battery Battery level, charging state, health, thermal state, and sleep prevention Connectivity app.connectivity Network connection status, type, Wi-Fi SSID, and interface info Screen app.screen Display resolution, brightness, dark mode, screenshots, and multi-display info Keychain app.keychain Secure credential storage using the macOS Keychain Camera app.camera Camera device listing, photo capture, and video frame streaming LaunchAtLogin app.launch_at_login Control whether the app starts automatically at user login Permissions app.permissions Check and request Camera, Microphone, and Notification permissions How Services Work \u00b6 Services extend the Service base class, which provides synchronous request/response communication with the Swift runtime. When you call a service method, the SDK: Sends a request message over the Unix socket to the Swift runtime Blocks the calling thread until a response arrives (default timeout: 10 seconds) Parses the response into a typed Python dataclass and returns it This means service calls behave like regular synchronous function calls -- no callbacks or await needed. # Services are synchronous -- just call and use the result status = app . battery . get_status () print ( f \"Battery: { status . level } %\" ) Timeout Service requests have a default timeout of 10 seconds. If the Swift runtime does not respond within that window, a TimeoutError is raised.","title":"Index"},{"location":"reference/services/#available-services","text":"Service Access Description Battery app.battery Battery level, charging state, health, thermal state, and sleep prevention Connectivity app.connectivity Network connection status, type, Wi-Fi SSID, and interface info Screen app.screen Display resolution, brightness, dark mode, screenshots, and multi-display info Keychain app.keychain Secure credential storage using the macOS Keychain Camera app.camera Camera device listing, photo capture, and video frame streaming LaunchAtLogin app.launch_at_login Control whether the app starts automatically at user login Permissions app.permissions Check and request Camera, Microphone, and Notification permissions","title":"Available Services"},{"location":"reference/services/#how-services-work","text":"Services extend the Service base class, which provides synchronous request/response communication with the Swift runtime. When you call a service method, the SDK: Sends a request message over the Unix socket to the Swift runtime Blocks the calling thread until a response arrives (default timeout: 10 seconds) Parses the response into a typed Python dataclass and returns it This means service calls behave like regular synchronous function calls -- no callbacks or await needed. # Services are synchronous -- just call and use the result status = app . battery . get_status () print ( f \"Battery: { status . level } %\" ) Timeout Service requests have a default timeout of 10 seconds. If the Swift runtime does not respond within that window, a TimeoutError is raised.","title":"How Services Work"},{"location":"reference/services/battery/","text":"The Battery service provides access to battery level, charging state, health information, thermal state, and sleep prevention. Access it via app.battery . status = app . battery . get_status () print ( f \"Level: { status . level } %\" ) print ( f \"Charging: { status . is_charging } \" ) Methods \u00b6 get_status() \u00b6 Get current battery status including level, charging state, and time estimates. app . battery . get_status () -> BatteryInfo Returns a BatteryInfo dataclass. get_health() \u00b6 Get battery health information including cycle count, capacity, temperature, and condition. app . battery . get_health () -> BatteryHealth Returns a BatteryHealth dataclass. get_thermal_state() \u00b6 Get the current system thermal state. app . battery . get_thermal_state () -> ThermalInfo Returns a ThermalInfo dataclass. prevent_sleep(reason, sleep_type) \u00b6 Prevent the system from sleeping. Returns an assertion that must be released later with allow_sleep() . app . battery . prevent_sleep ( reason : str = \"App preventing sleep\" , sleep_type : SleepType = SleepType . IDLE , ) -> SleepAssertion Parameter Type Default Description reason str \"App preventing sleep\" Human-readable reason for preventing sleep sleep_type SleepType SleepType.IDLE Type of sleep to prevent allow_sleep(assertion) \u00b6 Release a sleep prevention assertion, allowing the system to sleep again. app . battery . allow_sleep ( assertion : SleepAssertion | None = None ) -> bool Parameter Type Default Description assertion SleepAssertion \\| None None The assertion to release. If None , releases the most recent assertion Returns True if the assertion was released successfully. Data Classes \u00b6 BatteryInfo \u00b6 Battery status information returned by get_status() . Property Type Description level float \\| None Battery level as percentage (0--100). None if not available is_charging bool Whether the battery is currently charging state BatteryState Detailed battery state enum is_low_power_mode bool Whether Low Power Mode is enabled has_battery bool Whether the device has a battery time_remaining int \\| None Estimated minutes until empty time_remaining_formatted str \\| None Human-readable time remaining (e.g., \"2:30\" ) time_to_full int \\| None Estimated minutes until fully charged time_to_full_formatted str \\| None Human-readable time to full charge is_plugged_in bool \\| None Whether connected to power is_charged bool \\| None Whether the battery is fully charged power_source str \\| None Name of the active power source thermal_state str \\| None Current thermal state string current_capacity int \\| None Current capacity in mAh max_capacity int \\| None Maximum capacity in mAh amperage int \\| None Current amperage in mA voltage float \\| None Current voltage in V wattage float \\| None Current power draw in watts BatteryHealth \u00b6 Battery health information returned by get_health() . Property Type Description cycle_count int \\| None Number of charge cycles completed health_percent float \\| None Battery health as a percentage of design capacity condition str \\| None Battery condition string ( \"Normal\" , \"Fair\" , \"Poor\" , \"Service Recommended\" ) design_capacity int \\| None Original design capacity in mAh max_capacity int \\| None Current maximum capacity in mAh temperature_celsius float \\| None Battery temperature in Celsius temperature_fahrenheit float \\| None Battery temperature in Fahrenheit manufacture_date str \\| None Battery manufacture date (YYYY-MM-DD) manufacturer str \\| None Battery manufacturer name device_name str \\| None Battery device name optimized_charging bool \\| None Whether optimized charging is engaged ThermalInfo \u00b6 Thermal state information returned by get_thermal_state() . Property Type Description state ThermalState Current thermal state enum value state_raw int \\| None Raw thermal state integer value recommendation str \\| None Recommendation based on thermal state SleepAssertion \u00b6 Sleep prevention assertion returned by prevent_sleep() . Property Type Description assertion_id int \\| None System assertion ID, used to release the assertion success bool Whether the assertion was created successfully Enums \u00b6 BatteryState \u00b6 from nib.services.battery import BatteryState Value Description BatteryState.UNKNOWN Battery state cannot be determined BatteryState.CHARGING Battery is charging BatteryState.DISCHARGING Battery is discharging (on battery power) BatteryState.FULL Battery is fully charged BatteryState.NOT_CHARGING Battery is not charging BatteryState.PLUGGED_NOT_CHARGING Plugged in but not charging BatteryState.AC_POWER Running on AC power ThermalState \u00b6 from nib.services.battery import ThermalState Value Description ThermalState.NOMINAL Normal operating temperature ThermalState.FAIR Slightly elevated temperature ThermalState.SERIOUS High temperature; system may throttle ThermalState.CRITICAL Very high temperature; immediate action recommended ThermalState.UNKNOWN Thermal state cannot be determined SleepType \u00b6 from nib.services.battery import SleepType Value Description SleepType.IDLE Prevent idle sleep (default) SleepType.DISPLAY Prevent display sleep SleepType.SYSTEM Prevent all system sleep Examples \u00b6 Display battery status \u00b6 import nib def main ( app : nib . App ): app . title = \"Battery\" app . icon = nib . SFSymbol ( \"battery.100\" ) app . width = 300 app . height = 200 level_text = nib . Text ( \"--\" , font = nib . Font . TITLE ) state_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) def refresh (): status = app . battery . get_status () if status . has_battery and status . level is not None : level_text . content = f \" { status . level : .0f } %\" state_text . content = status . state . value . title () else : level_text . content = \"AC\" state_text . content = \"No Battery\" app . on_appear = refresh app . build ( nib . VStack ( controls = [ level_text , state_text ], spacing = 8 , padding = 20 , ) ) nib . run ( main ) Check battery health \u00b6 import nib def main ( app : nib . App ): app . title = \"Health\" app . icon = nib . SFSymbol ( \"heart.fill\" ) app . width = 300 app . height = 250 health_text = nib . Text ( \"--\" , font = nib . Font . TITLE ) cycles_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) temp_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) condition_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) def refresh (): health = app . battery . get_health () if health . health_percent is not None : health_text . content = f \" { health . health_percent : .0f } % health\" cycles_text . content = f \" { health . cycle_count } cycles\" if health . cycle_count else \"N/A\" temp_text . content = ( f \" { health . temperature_celsius : .1f } C\" if health . temperature_celsius else \"N/A\" ) condition_text . content = health . condition or \"N/A\" app . on_appear = refresh app . build ( nib . VStack ( controls = [ health_text , cycles_text , temp_text , condition_text ], spacing = 8 , padding = 20 , ) ) nib . run ( main ) Prevent sleep during a long operation \u00b6 import nib def main ( app : nib . App ): app . title = \"Sleep Guard\" app . icon = nib . SFSymbol ( \"moon.zzz\" ) app . width = 300 app . height = 150 status = nib . Text ( \"Sleep allowed\" , foreground_color = nib . Color . SECONDARY ) assertion = None def toggle_sleep (): nonlocal assertion if assertion is None : assertion = app . battery . prevent_sleep ( reason = \"Running long task\" , sleep_type = nib . services . battery . SleepType . IDLE , ) status . content = \"Sleep prevented\" else : app . battery . allow_sleep ( assertion ) assertion = None status . content = \"Sleep allowed\" app . build ( nib . VStack ( controls = [ status , nib . Button ( \"Toggle Sleep Prevention\" , action = toggle_sleep ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Monitor thermal state \u00b6 import nib from nib.services.battery import ThermalState def main ( app : nib . App ): app . title = \"Thermal\" app . icon = nib . SFSymbol ( \"thermometer\" ) app . width = 280 app . height = 120 thermal_text = nib . Text ( \"--\" , font = nib . Font . TITLE ) def refresh (): thermal = app . battery . get_thermal_state () thermal_text . content = thermal . state . value . title () if thermal . state == ThermalState . NOMINAL : thermal_text . foreground_color = nib . Color . GREEN elif thermal . state == ThermalState . FAIR : thermal_text . foreground_color = nib . Color . ORANGE elif thermal . state in ( ThermalState . SERIOUS , ThermalState . CRITICAL ): thermal_text . foreground_color = nib . Color . RED app . on_appear = refresh app . build ( nib . VStack ( controls = [ thermal_text ], padding = 20 , ) ) nib . run ( main )","title":"Battery"},{"location":"reference/services/battery/#methods","text":"","title":"Methods"},{"location":"reference/services/battery/#get_status","text":"Get current battery status including level, charging state, and time estimates. app . battery . get_status () -> BatteryInfo Returns a BatteryInfo dataclass.","title":"get_status()"},{"location":"reference/services/battery/#get_health","text":"Get battery health information including cycle count, capacity, temperature, and condition. app . battery . get_health () -> BatteryHealth Returns a BatteryHealth dataclass.","title":"get_health()"},{"location":"reference/services/battery/#get_thermal_state","text":"Get the current system thermal state. app . battery . get_thermal_state () -> ThermalInfo Returns a ThermalInfo dataclass.","title":"get_thermal_state()"},{"location":"reference/services/battery/#prevent_sleepreason-sleep_type","text":"Prevent the system from sleeping. Returns an assertion that must be released later with allow_sleep() . app . battery . prevent_sleep ( reason : str = \"App preventing sleep\" , sleep_type : SleepType = SleepType . IDLE , ) -> SleepAssertion Parameter Type Default Description reason str \"App preventing sleep\" Human-readable reason for preventing sleep sleep_type SleepType SleepType.IDLE Type of sleep to prevent","title":"prevent_sleep(reason, sleep_type)"},{"location":"reference/services/battery/#allow_sleepassertion","text":"Release a sleep prevention assertion, allowing the system to sleep again. app . battery . allow_sleep ( assertion : SleepAssertion | None = None ) -> bool Parameter Type Default Description assertion SleepAssertion \\| None None The assertion to release. If None , releases the most recent assertion Returns True if the assertion was released successfully.","title":"allow_sleep(assertion)"},{"location":"reference/services/battery/#data-classes","text":"","title":"Data Classes"},{"location":"reference/services/battery/#batteryinfo","text":"Battery status information returned by get_status() . Property Type Description level float \\| None Battery level as percentage (0--100). None if not available is_charging bool Whether the battery is currently charging state BatteryState Detailed battery state enum is_low_power_mode bool Whether Low Power Mode is enabled has_battery bool Whether the device has a battery time_remaining int \\| None Estimated minutes until empty time_remaining_formatted str \\| None Human-readable time remaining (e.g., \"2:30\" ) time_to_full int \\| None Estimated minutes until fully charged time_to_full_formatted str \\| None Human-readable time to full charge is_plugged_in bool \\| None Whether connected to power is_charged bool \\| None Whether the battery is fully charged power_source str \\| None Name of the active power source thermal_state str \\| None Current thermal state string current_capacity int \\| None Current capacity in mAh max_capacity int \\| None Maximum capacity in mAh amperage int \\| None Current amperage in mA voltage float \\| None Current voltage in V wattage float \\| None Current power draw in watts","title":"BatteryInfo"},{"location":"reference/services/battery/#batteryhealth","text":"Battery health information returned by get_health() . Property Type Description cycle_count int \\| None Number of charge cycles completed health_percent float \\| None Battery health as a percentage of design capacity condition str \\| None Battery condition string ( \"Normal\" , \"Fair\" , \"Poor\" , \"Service Recommended\" ) design_capacity int \\| None Original design capacity in mAh max_capacity int \\| None Current maximum capacity in mAh temperature_celsius float \\| None Battery temperature in Celsius temperature_fahrenheit float \\| None Battery temperature in Fahrenheit manufacture_date str \\| None Battery manufacture date (YYYY-MM-DD) manufacturer str \\| None Battery manufacturer name device_name str \\| None Battery device name optimized_charging bool \\| None Whether optimized charging is engaged","title":"BatteryHealth"},{"location":"reference/services/battery/#thermalinfo","text":"Thermal state information returned by get_thermal_state() . Property Type Description state ThermalState Current thermal state enum value state_raw int \\| None Raw thermal state integer value recommendation str \\| None Recommendation based on thermal state","title":"ThermalInfo"},{"location":"reference/services/battery/#sleepassertion","text":"Sleep prevention assertion returned by prevent_sleep() . Property Type Description assertion_id int \\| None System assertion ID, used to release the assertion success bool Whether the assertion was created successfully","title":"SleepAssertion"},{"location":"reference/services/battery/#enums","text":"","title":"Enums"},{"location":"reference/services/battery/#batterystate","text":"from nib.services.battery import BatteryState Value Description BatteryState.UNKNOWN Battery state cannot be determined BatteryState.CHARGING Battery is charging BatteryState.DISCHARGING Battery is discharging (on battery power) BatteryState.FULL Battery is fully charged BatteryState.NOT_CHARGING Battery is not charging BatteryState.PLUGGED_NOT_CHARGING Plugged in but not charging BatteryState.AC_POWER Running on AC power","title":"BatteryState"},{"location":"reference/services/battery/#thermalstate","text":"from nib.services.battery import ThermalState Value Description ThermalState.NOMINAL Normal operating temperature ThermalState.FAIR Slightly elevated temperature ThermalState.SERIOUS High temperature; system may throttle ThermalState.CRITICAL Very high temperature; immediate action recommended ThermalState.UNKNOWN Thermal state cannot be determined","title":"ThermalState"},{"location":"reference/services/battery/#sleeptype","text":"from nib.services.battery import SleepType Value Description SleepType.IDLE Prevent idle sleep (default) SleepType.DISPLAY Prevent display sleep SleepType.SYSTEM Prevent all system sleep","title":"SleepType"},{"location":"reference/services/battery/#examples","text":"","title":"Examples"},{"location":"reference/services/battery/#display-battery-status","text":"import nib def main ( app : nib . App ): app . title = \"Battery\" app . icon = nib . SFSymbol ( \"battery.100\" ) app . width = 300 app . height = 200 level_text = nib . Text ( \"--\" , font = nib . Font . TITLE ) state_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) def refresh (): status = app . battery . get_status () if status . has_battery and status . level is not None : level_text . content = f \" { status . level : .0f } %\" state_text . content = status . state . value . title () else : level_text . content = \"AC\" state_text . content = \"No Battery\" app . on_appear = refresh app . build ( nib . VStack ( controls = [ level_text , state_text ], spacing = 8 , padding = 20 , ) ) nib . run ( main )","title":"Display battery status"},{"location":"reference/services/battery/#check-battery-health","text":"import nib def main ( app : nib . App ): app . title = \"Health\" app . icon = nib . SFSymbol ( \"heart.fill\" ) app . width = 300 app . height = 250 health_text = nib . Text ( \"--\" , font = nib . Font . TITLE ) cycles_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) temp_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) condition_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) def refresh (): health = app . battery . get_health () if health . health_percent is not None : health_text . content = f \" { health . health_percent : .0f } % health\" cycles_text . content = f \" { health . cycle_count } cycles\" if health . cycle_count else \"N/A\" temp_text . content = ( f \" { health . temperature_celsius : .1f } C\" if health . temperature_celsius else \"N/A\" ) condition_text . content = health . condition or \"N/A\" app . on_appear = refresh app . build ( nib . VStack ( controls = [ health_text , cycles_text , temp_text , condition_text ], spacing = 8 , padding = 20 , ) ) nib . run ( main )","title":"Check battery health"},{"location":"reference/services/battery/#prevent-sleep-during-a-long-operation","text":"import nib def main ( app : nib . App ): app . title = \"Sleep Guard\" app . icon = nib . SFSymbol ( \"moon.zzz\" ) app . width = 300 app . height = 150 status = nib . Text ( \"Sleep allowed\" , foreground_color = nib . Color . SECONDARY ) assertion = None def toggle_sleep (): nonlocal assertion if assertion is None : assertion = app . battery . prevent_sleep ( reason = \"Running long task\" , sleep_type = nib . services . battery . SleepType . IDLE , ) status . content = \"Sleep prevented\" else : app . battery . allow_sleep ( assertion ) assertion = None status . content = \"Sleep allowed\" app . build ( nib . VStack ( controls = [ status , nib . Button ( \"Toggle Sleep Prevention\" , action = toggle_sleep ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Prevent sleep during a long operation"},{"location":"reference/services/battery/#monitor-thermal-state","text":"import nib from nib.services.battery import ThermalState def main ( app : nib . App ): app . title = \"Thermal\" app . icon = nib . SFSymbol ( \"thermometer\" ) app . width = 280 app . height = 120 thermal_text = nib . Text ( \"--\" , font = nib . Font . TITLE ) def refresh (): thermal = app . battery . get_thermal_state () thermal_text . content = thermal . state . value . title () if thermal . state == ThermalState . NOMINAL : thermal_text . foreground_color = nib . Color . GREEN elif thermal . state == ThermalState . FAIR : thermal_text . foreground_color = nib . Color . ORANGE elif thermal . state in ( ThermalState . SERIOUS , ThermalState . CRITICAL ): thermal_text . foreground_color = nib . Color . RED app . on_appear = refresh app . build ( nib . VStack ( controls = [ thermal_text ], padding = 20 , ) ) nib . run ( main )","title":"Monitor thermal state"},{"location":"reference/services/camera/","text":"The Camera service provides access to camera devices for listing, photo capture, and video frame streaming. Access it via app.camera . devices = app . camera . list_devices () for d in devices : print ( f \"Found camera: { d . name } \" ) frame = app . camera . capture_photo () frame . save ( \"/tmp/photo.jpg\" ) Permission Required Camera access requires the user to grant the Camera permission. Use app.permissions.check(nib.Permission.CAMERA) and app.permissions.request(nib.Permission.CAMERA) before accessing the camera. Methods \u00b6 list_devices() \u00b6 List all available camera devices on the system. app . camera . list_devices () -> list [ CameraDevice ] Returns a list of CameraDevice dataclass instances. capture_photo(device_id, format, quality) \u00b6 Capture a single photo from a camera. app . camera . capture_photo ( device_id : str | None = None , format : str = \"jpeg\" , quality : float = 0.9 , ) -> CameraFrame Parameter Type Default Description device_id str \\| None None Camera device ID from list_devices() . Uses the default camera if None format str \"jpeg\" Image format: \"jpeg\" or \"png\" quality float 0.9 JPEG compression quality from 0.0 to 1.0 . Ignored for PNG Returns a CameraFrame dataclass with the captured image data. start_stream(callback, device_id, fps) \u00b6 Start streaming video frames from a camera. Frames are delivered to the callback function at approximately the specified frame rate. Only one stream can be active at a time. app . camera . start_stream ( callback : Callable [[ CameraFrame ], None ], device_id : str | None = None , fps : int = 30 , ) -> bool Parameter Type Default Description callback Callable[[CameraFrame], None] -- Function called with each frame device_id str \\| None None Camera device ID. Uses the default camera if None fps int 30 Target frames per second (1--60) Returns True if streaming started successfully. stop_stream() \u00b6 Stop the active video frame stream. app . camera . stop_stream () -> bool Returns True if streaming stopped successfully. Data Classes \u00b6 CameraDevice \u00b6 Information about an available camera device. Property Type Description id str Unique device identifier, used in capture_photo() and start_stream() name str Human-readable device name (e.g., \"FaceTime HD Camera\" ) position CameraPosition Physical position of the camera is_built_in bool Whether the camera is built into the device CameraFrame \u00b6 A captured camera frame, either from a photo or a video stream. Property Type Description data bytes Raw image data width int Image width in pixels height int Image height in pixels format str Image format ( \"jpeg\" or \"png\" ) CameraFrame.save(path) \u00b6 Save the frame to a file. frame . save ( path : str ) -> None Parameter Type Description path str File path to save the image (e.g., \"/tmp/photo.jpg\" ) Enums \u00b6 CameraPosition \u00b6 from nib.services.camera import CameraPosition Value Description CameraPosition.FRONT Front-facing camera (e.g., FaceTime camera) CameraPosition.BACK Rear-facing camera (not typical on Macs) CameraPosition.EXTERNAL External USB or Thunderbolt camera Examples \u00b6 List cameras and capture a photo \u00b6 import nib def main ( app : nib . App ): app . title = \"Camera\" app . icon = nib . SFSymbol ( \"camera\" ) app . width = 320 app . height = 200 status = nib . Text ( \"Ready\" , foreground_color = nib . Color . SECONDARY ) device_list = nib . Text ( \"\" , foreground_color = nib . Color . SECONDARY ) def list_cameras (): devices = app . camera . list_devices () if devices : names = [ f \" { d . name } ( { d . position . value } )\" for d in devices ] device_list . content = \" \\n \" . join ( names ) else : device_list . content = \"No cameras found\" def take_photo (): status . content = \"Capturing...\" frame = app . camera . capture_photo ( format = \"jpeg\" , quality = 0.9 ) frame . save ( \"/tmp/nib_photo.jpg\" ) status . content = f \"Saved { frame . width } x { frame . height } photo\" app . on_appear = list_cameras app . build ( nib . VStack ( controls = [ nib . Text ( \"Camera\" , font = nib . Font . HEADLINE ), device_list , nib . HStack ( controls = [ nib . Button ( \"List Cameras\" , action = list_cameras ), nib . Button ( \"Take Photo\" , action = take_photo , style = nib . ButtonStyle . BORDERED_PROMINENT ), ], spacing = 8 , ), status , ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Stream video frames for processing \u00b6 import nib def main ( app : nib . App ): app . title = \"Stream\" app . icon = nib . SFSymbol ( \"video\" ) app . width = 300 app . height = 150 frame_count = nib . Text ( \"Frames: 0\" ) count = 0 def on_frame ( frame ): nonlocal count count += 1 if count % 30 == 0 : # Update display every 30 frames frame_count . content = f \"Frames: { count } ( { frame . width } x { frame . height } )\" def start (): app . camera . start_stream ( on_frame , fps = 15 ) frame_count . content = \"Streaming...\" def stop (): app . camera . stop_stream () frame_count . content = f \"Stopped at { count } frames\" app . build ( nib . VStack ( controls = [ frame_count , nib . HStack ( controls = [ nib . Button ( \"Start\" , action = start , style = nib . ButtonStyle . BORDERED_PROMINENT ), nib . Button ( \"Stop\" , action = stop , role = nib . ButtonRole . DESTRUCTIVE ), ], spacing = 8 , ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Camera"},{"location":"reference/services/camera/#methods","text":"","title":"Methods"},{"location":"reference/services/camera/#list_devices","text":"List all available camera devices on the system. app . camera . list_devices () -> list [ CameraDevice ] Returns a list of CameraDevice dataclass instances.","title":"list_devices()"},{"location":"reference/services/camera/#capture_photodevice_id-format-quality","text":"Capture a single photo from a camera. app . camera . capture_photo ( device_id : str | None = None , format : str = \"jpeg\" , quality : float = 0.9 , ) -> CameraFrame Parameter Type Default Description device_id str \\| None None Camera device ID from list_devices() . Uses the default camera if None format str \"jpeg\" Image format: \"jpeg\" or \"png\" quality float 0.9 JPEG compression quality from 0.0 to 1.0 . Ignored for PNG Returns a CameraFrame dataclass with the captured image data.","title":"capture_photo(device_id, format, quality)"},{"location":"reference/services/camera/#start_streamcallback-device_id-fps","text":"Start streaming video frames from a camera. Frames are delivered to the callback function at approximately the specified frame rate. Only one stream can be active at a time. app . camera . start_stream ( callback : Callable [[ CameraFrame ], None ], device_id : str | None = None , fps : int = 30 , ) -> bool Parameter Type Default Description callback Callable[[CameraFrame], None] -- Function called with each frame device_id str \\| None None Camera device ID. Uses the default camera if None fps int 30 Target frames per second (1--60) Returns True if streaming started successfully.","title":"start_stream(callback, device_id, fps)"},{"location":"reference/services/camera/#stop_stream","text":"Stop the active video frame stream. app . camera . stop_stream () -> bool Returns True if streaming stopped successfully.","title":"stop_stream()"},{"location":"reference/services/camera/#data-classes","text":"","title":"Data Classes"},{"location":"reference/services/camera/#cameradevice","text":"Information about an available camera device. Property Type Description id str Unique device identifier, used in capture_photo() and start_stream() name str Human-readable device name (e.g., \"FaceTime HD Camera\" ) position CameraPosition Physical position of the camera is_built_in bool Whether the camera is built into the device","title":"CameraDevice"},{"location":"reference/services/camera/#cameraframe","text":"A captured camera frame, either from a photo or a video stream. Property Type Description data bytes Raw image data width int Image width in pixels height int Image height in pixels format str Image format ( \"jpeg\" or \"png\" )","title":"CameraFrame"},{"location":"reference/services/camera/#cameraframesavepath","text":"Save the frame to a file. frame . save ( path : str ) -> None Parameter Type Description path str File path to save the image (e.g., \"/tmp/photo.jpg\" )","title":"CameraFrame.save(path)"},{"location":"reference/services/camera/#enums","text":"","title":"Enums"},{"location":"reference/services/camera/#cameraposition","text":"from nib.services.camera import CameraPosition Value Description CameraPosition.FRONT Front-facing camera (e.g., FaceTime camera) CameraPosition.BACK Rear-facing camera (not typical on Macs) CameraPosition.EXTERNAL External USB or Thunderbolt camera","title":"CameraPosition"},{"location":"reference/services/camera/#examples","text":"","title":"Examples"},{"location":"reference/services/camera/#list-cameras-and-capture-a-photo","text":"import nib def main ( app : nib . App ): app . title = \"Camera\" app . icon = nib . SFSymbol ( \"camera\" ) app . width = 320 app . height = 200 status = nib . Text ( \"Ready\" , foreground_color = nib . Color . SECONDARY ) device_list = nib . Text ( \"\" , foreground_color = nib . Color . SECONDARY ) def list_cameras (): devices = app . camera . list_devices () if devices : names = [ f \" { d . name } ( { d . position . value } )\" for d in devices ] device_list . content = \" \\n \" . join ( names ) else : device_list . content = \"No cameras found\" def take_photo (): status . content = \"Capturing...\" frame = app . camera . capture_photo ( format = \"jpeg\" , quality = 0.9 ) frame . save ( \"/tmp/nib_photo.jpg\" ) status . content = f \"Saved { frame . width } x { frame . height } photo\" app . on_appear = list_cameras app . build ( nib . VStack ( controls = [ nib . Text ( \"Camera\" , font = nib . Font . HEADLINE ), device_list , nib . HStack ( controls = [ nib . Button ( \"List Cameras\" , action = list_cameras ), nib . Button ( \"Take Photo\" , action = take_photo , style = nib . ButtonStyle . BORDERED_PROMINENT ), ], spacing = 8 , ), status , ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"List cameras and capture a photo"},{"location":"reference/services/camera/#stream-video-frames-for-processing","text":"import nib def main ( app : nib . App ): app . title = \"Stream\" app . icon = nib . SFSymbol ( \"video\" ) app . width = 300 app . height = 150 frame_count = nib . Text ( \"Frames: 0\" ) count = 0 def on_frame ( frame ): nonlocal count count += 1 if count % 30 == 0 : # Update display every 30 frames frame_count . content = f \"Frames: { count } ( { frame . width } x { frame . height } )\" def start (): app . camera . start_stream ( on_frame , fps = 15 ) frame_count . content = \"Streaming...\" def stop (): app . camera . stop_stream () frame_count . content = f \"Stopped at { count } frames\" app . build ( nib . VStack ( controls = [ frame_count , nib . HStack ( controls = [ nib . Button ( \"Start\" , action = start , style = nib . ButtonStyle . BORDERED_PROMINENT ), nib . Button ( \"Stop\" , action = stop , role = nib . ButtonRole . DESTRUCTIVE ), ], spacing = 8 , ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Stream video frames for processing"},{"location":"reference/services/connectivity/","text":"The Connectivity service provides access to network status and connection type information. Access it via app.connectivity . status = app . connectivity . get_status () print ( f \"Connected: { status . is_connected } \" ) print ( f \"Type: { status . type } \" ) Methods \u00b6 get_status() \u00b6 Get the current network connectivity status. app . connectivity . get_status () -> ConnectivityInfo Returns a ConnectivityInfo dataclass with all network details. Data Classes \u00b6 ConnectivityInfo \u00b6 Network connectivity information returned by get_status() . Property Type Description is_connected bool Whether there is an active network connection type ConnectionType The type of network connection is_expensive bool Whether the connection is metered/expensive (e.g., cellular) is_constrained bool Whether the connection is constrained (Low Data Mode) ssid str \\| None Wi-Fi network name if connected to Wi-Fi, None otherwise interface_name str \\| None Name of the active network interface (e.g., \"en0\" ) Enums \u00b6 ConnectionType \u00b6 from nib.services.connectivity import ConnectionType Value Description ConnectionType.NONE No active connection ConnectionType.WIFI Connected via Wi-Fi ConnectionType.ETHERNET Connected via Ethernet ConnectionType.CELLULAR Connected via cellular data ConnectionType.OTHER Connected via an unrecognized interface Examples \u00b6 Display network status \u00b6 import nib def main ( app : nib . App ): app . title = \"Network\" app . icon = nib . SFSymbol ( \"wifi\" ) app . width = 300 app . height = 200 status_text = nib . Text ( \"--\" , font = nib . Font . TITLE ) type_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) ssid_text = nib . Text ( \"\" , foreground_color = nib . Color . SECONDARY ) def refresh (): info = app . connectivity . get_status () if info . is_connected : status_text . content = \"Connected\" status_text . foreground_color = nib . Color . GREEN type_text . content = info . type . value . title () ssid_text . content = info . ssid or \"\" else : status_text . content = \"Offline\" status_text . foreground_color = nib . Color . RED type_text . content = \"No Connection\" ssid_text . content = \"\" app . on_appear = refresh app . build ( nib . VStack ( controls = [ status_text , type_text , ssid_text , nib . Button ( \"Refresh\" , action = refresh ), ], spacing = 8 , padding = 20 , ) ) nib . run ( main ) Warn on expensive connections \u00b6 import nib def main ( app : nib . App ): app . title = \"Net Check\" app . icon = nib . SFSymbol ( \"antenna.radiowaves.left.and.right\" ) app . width = 320 app . height = 150 label = nib . Text ( \"Checking...\" , font = nib . Font . BODY ) def check_connection (): info = app . connectivity . get_status () if not info . is_connected : label . content = \"No network connection available.\" app . notify ( \"Offline\" , \"Connect to the internet to continue.\" ) elif info . is_expensive : label . content = f \"Metered connection ( { info . type . value } ). Downloads paused.\" elif info . is_constrained : label . content = \"Low Data Mode active. Limiting bandwidth.\" else : label . content = f \"Connected via { info . type . value . title () } . All systems go.\" app . on_appear = check_connection app . build ( nib . VStack ( controls = [ label ], padding = 20 ) ) nib . run ( main )","title":"Connectivity"},{"location":"reference/services/connectivity/#methods","text":"","title":"Methods"},{"location":"reference/services/connectivity/#get_status","text":"Get the current network connectivity status. app . connectivity . get_status () -> ConnectivityInfo Returns a ConnectivityInfo dataclass with all network details.","title":"get_status()"},{"location":"reference/services/connectivity/#data-classes","text":"","title":"Data Classes"},{"location":"reference/services/connectivity/#connectivityinfo","text":"Network connectivity information returned by get_status() . Property Type Description is_connected bool Whether there is an active network connection type ConnectionType The type of network connection is_expensive bool Whether the connection is metered/expensive (e.g., cellular) is_constrained bool Whether the connection is constrained (Low Data Mode) ssid str \\| None Wi-Fi network name if connected to Wi-Fi, None otherwise interface_name str \\| None Name of the active network interface (e.g., \"en0\" )","title":"ConnectivityInfo"},{"location":"reference/services/connectivity/#enums","text":"","title":"Enums"},{"location":"reference/services/connectivity/#connectiontype","text":"from nib.services.connectivity import ConnectionType Value Description ConnectionType.NONE No active connection ConnectionType.WIFI Connected via Wi-Fi ConnectionType.ETHERNET Connected via Ethernet ConnectionType.CELLULAR Connected via cellular data ConnectionType.OTHER Connected via an unrecognized interface","title":"ConnectionType"},{"location":"reference/services/connectivity/#examples","text":"","title":"Examples"},{"location":"reference/services/connectivity/#display-network-status","text":"import nib def main ( app : nib . App ): app . title = \"Network\" app . icon = nib . SFSymbol ( \"wifi\" ) app . width = 300 app . height = 200 status_text = nib . Text ( \"--\" , font = nib . Font . TITLE ) type_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) ssid_text = nib . Text ( \"\" , foreground_color = nib . Color . SECONDARY ) def refresh (): info = app . connectivity . get_status () if info . is_connected : status_text . content = \"Connected\" status_text . foreground_color = nib . Color . GREEN type_text . content = info . type . value . title () ssid_text . content = info . ssid or \"\" else : status_text . content = \"Offline\" status_text . foreground_color = nib . Color . RED type_text . content = \"No Connection\" ssid_text . content = \"\" app . on_appear = refresh app . build ( nib . VStack ( controls = [ status_text , type_text , ssid_text , nib . Button ( \"Refresh\" , action = refresh ), ], spacing = 8 , padding = 20 , ) ) nib . run ( main )","title":"Display network status"},{"location":"reference/services/connectivity/#warn-on-expensive-connections","text":"import nib def main ( app : nib . App ): app . title = \"Net Check\" app . icon = nib . SFSymbol ( \"antenna.radiowaves.left.and.right\" ) app . width = 320 app . height = 150 label = nib . Text ( \"Checking...\" , font = nib . Font . BODY ) def check_connection (): info = app . connectivity . get_status () if not info . is_connected : label . content = \"No network connection available.\" app . notify ( \"Offline\" , \"Connect to the internet to continue.\" ) elif info . is_expensive : label . content = f \"Metered connection ( { info . type . value } ). Downloads paused.\" elif info . is_constrained : label . content = \"Low Data Mode active. Limiting bandwidth.\" else : label . content = f \"Connected via { info . type . value . title () } . All systems go.\" app . on_appear = check_connection app . build ( nib . VStack ( controls = [ label ], padding = 20 ) ) nib . run ( main )","title":"Warn on expensive connections"},{"location":"reference/services/keychain/","text":"The Keychain service provides secure storage for passwords, API tokens, and other sensitive data using the macOS Keychain. Data is encrypted at rest and protected by the system. Access it via app.keychain . # Store a credential app . keychain . set ( \"MyApp\" , \"api_token\" , \"sk-abc123\" ) # Retrieve it later token = app . keychain . get ( \"MyApp\" , \"api_token\" ) Methods \u00b6 get(service, account) \u00b6 Retrieve a password from the keychain. app . keychain . get ( service : str , account : str ) -> str | None Parameter Type Description service str Service name, typically your app identifier (e.g., \"com.myapp\" ) account str Account name (username, email, or key identifier) Returns the stored password as a string, or None if no matching entry exists. set(service, account, password) \u00b6 Store a password in the keychain. If an entry already exists for the given service/account combination, it is updated. app . keychain . set ( service : str , account : str , password : str ) -> bool Parameter Type Description service str Service name account str Account name password str The password or secret to store Returns True if stored successfully. delete(service, account) \u00b6 Delete a password from the keychain. app . keychain . delete ( service : str , account : str ) -> bool Parameter Type Description service str Service name account str Account name Returns True if deleted successfully. exists(service, account) \u00b6 Check whether a keychain entry exists without retrieving its value. app . keychain . exists ( service : str , account : str ) -> bool Parameter Type Description service str Service name account str Account name Returns True if the entry exists, False otherwise. Examples \u00b6 Store and retrieve an API token \u00b6 import nib def main ( app : nib . App ): app . title = \"Keychain\" app . icon = nib . SFSymbol ( \"key.fill\" ) app . width = 340 app . height = 250 SERVICE = \"com.myapp\" ACCOUNT = \"api_token\" token_field = nib . SecureField ( placeholder = \"Enter API token\" ) status = nib . Text ( \"\" , foreground_color = nib . Color . SECONDARY ) def save_token (): if token_field . text : success = app . keychain . set ( SERVICE , ACCOUNT , token_field . text ) status . content = \"Saved!\" if success else \"Failed to save\" else : status . content = \"Enter a token first\" def load_token (): token = app . keychain . get ( SERVICE , ACCOUNT ) if token : status . content = f \"Token: { token [: 8 ] } ...\" else : status . content = \"No token stored\" def delete_token (): success = app . keychain . delete ( SERVICE , ACCOUNT ) status . content = \"Deleted\" if success else \"Nothing to delete\" app . on_appear = load_token app . build ( nib . VStack ( controls = [ nib . Text ( \"API Token Manager\" , font = nib . Font . HEADLINE ), token_field , nib . HStack ( controls = [ nib . Button ( \"Save\" , action = save_token , style = nib . ButtonStyle . BORDERED_PROMINENT ), nib . Button ( \"Load\" , action = load_token , style = nib . ButtonStyle . BORDERED ), nib . Button ( \"Delete\" , action = delete_token , role = nib . ButtonRole . DESTRUCTIVE ), ], spacing = 8 , ), status , ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Login form with keychain persistence \u00b6 import nib def main ( app : nib . App ): app . title = \"Login\" app . icon = nib . SFSymbol ( \"person.crop.circle\" ) app . width = 320 app . height = 220 SERVICE = \"com.myapp.login\" username = nib . TextField ( placeholder = \"Username\" ) password = nib . SecureField ( placeholder = \"Password\" ) status = nib . Text ( \"\" , foreground_color = nib . Color . SECONDARY ) def login (): if username . text and password . text : # Save credentials for next session app . keychain . set ( SERVICE , \"username\" , username . text ) app . keychain . set ( SERVICE , \"password\" , password . text ) status . content = f \"Logged in as { username . text } \" def load_saved (): saved_user = app . keychain . get ( SERVICE , \"username\" ) if saved_user : username . text = saved_user status . content = \"Loaded saved credentials\" app . on_appear = load_saved app . build ( nib . Form ( controls = [ username , password , nib . Button ( \"Login\" , action = login , style = nib . ButtonStyle . BORDERED_PROMINENT ), status , ], padding = 20 , ) ) nib . run ( main )","title":"Keychain"},{"location":"reference/services/keychain/#methods","text":"","title":"Methods"},{"location":"reference/services/keychain/#getservice-account","text":"Retrieve a password from the keychain. app . keychain . get ( service : str , account : str ) -> str | None Parameter Type Description service str Service name, typically your app identifier (e.g., \"com.myapp\" ) account str Account name (username, email, or key identifier) Returns the stored password as a string, or None if no matching entry exists.","title":"get(service, account)"},{"location":"reference/services/keychain/#setservice-account-password","text":"Store a password in the keychain. If an entry already exists for the given service/account combination, it is updated. app . keychain . set ( service : str , account : str , password : str ) -> bool Parameter Type Description service str Service name account str Account name password str The password or secret to store Returns True if stored successfully.","title":"set(service, account, password)"},{"location":"reference/services/keychain/#deleteservice-account","text":"Delete a password from the keychain. app . keychain . delete ( service : str , account : str ) -> bool Parameter Type Description service str Service name account str Account name Returns True if deleted successfully.","title":"delete(service, account)"},{"location":"reference/services/keychain/#existsservice-account","text":"Check whether a keychain entry exists without retrieving its value. app . keychain . exists ( service : str , account : str ) -> bool Parameter Type Description service str Service name account str Account name Returns True if the entry exists, False otherwise.","title":"exists(service, account)"},{"location":"reference/services/keychain/#examples","text":"","title":"Examples"},{"location":"reference/services/keychain/#store-and-retrieve-an-api-token","text":"import nib def main ( app : nib . App ): app . title = \"Keychain\" app . icon = nib . SFSymbol ( \"key.fill\" ) app . width = 340 app . height = 250 SERVICE = \"com.myapp\" ACCOUNT = \"api_token\" token_field = nib . SecureField ( placeholder = \"Enter API token\" ) status = nib . Text ( \"\" , foreground_color = nib . Color . SECONDARY ) def save_token (): if token_field . text : success = app . keychain . set ( SERVICE , ACCOUNT , token_field . text ) status . content = \"Saved!\" if success else \"Failed to save\" else : status . content = \"Enter a token first\" def load_token (): token = app . keychain . get ( SERVICE , ACCOUNT ) if token : status . content = f \"Token: { token [: 8 ] } ...\" else : status . content = \"No token stored\" def delete_token (): success = app . keychain . delete ( SERVICE , ACCOUNT ) status . content = \"Deleted\" if success else \"Nothing to delete\" app . on_appear = load_token app . build ( nib . VStack ( controls = [ nib . Text ( \"API Token Manager\" , font = nib . Font . HEADLINE ), token_field , nib . HStack ( controls = [ nib . Button ( \"Save\" , action = save_token , style = nib . ButtonStyle . BORDERED_PROMINENT ), nib . Button ( \"Load\" , action = load_token , style = nib . ButtonStyle . BORDERED ), nib . Button ( \"Delete\" , action = delete_token , role = nib . ButtonRole . DESTRUCTIVE ), ], spacing = 8 , ), status , ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Store and retrieve an API token"},{"location":"reference/services/keychain/#login-form-with-keychain-persistence","text":"import nib def main ( app : nib . App ): app . title = \"Login\" app . icon = nib . SFSymbol ( \"person.crop.circle\" ) app . width = 320 app . height = 220 SERVICE = \"com.myapp.login\" username = nib . TextField ( placeholder = \"Username\" ) password = nib . SecureField ( placeholder = \"Password\" ) status = nib . Text ( \"\" , foreground_color = nib . Color . SECONDARY ) def login (): if username . text and password . text : # Save credentials for next session app . keychain . set ( SERVICE , \"username\" , username . text ) app . keychain . set ( SERVICE , \"password\" , password . text ) status . content = f \"Logged in as { username . text } \" def load_saved (): saved_user = app . keychain . get ( SERVICE , \"username\" ) if saved_user : username . text = saved_user status . content = \"Loaded saved credentials\" app . on_appear = load_saved app . build ( nib . Form ( controls = [ username , password , nib . Button ( \"Login\" , action = login , style = nib . ButtonStyle . BORDERED_PROMINENT ), status , ], padding = 20 , ) ) nib . run ( main )","title":"Login form with keychain persistence"},{"location":"reference/services/launch-at-login/","text":"The LaunchAtLogin service controls whether the app starts automatically when the user logs in. It uses SMAppService on macOS 13+ to register the app as a login item. Access it via app.launch_at_login . if app . launch_at_login . is_enabled : print ( \"App will launch at login\" ) App Store Requirement Per Mac App Store guidelines, Launch at Login should only be enabled in response to a direct user action (e.g., clicking a button or toggling a switch). Do not enable it silently or at startup. Properties \u00b6 is_enabled \u00b6 Read-only property that checks whether the app is currently set to launch at login. app . launch_at_login . is_enabled -> bool Returns True if launch at login is enabled, False otherwise. Methods \u00b6 set(enabled) \u00b6 Set the launch at login state. Call this only in response to a user action. app . launch_at_login . set ( enabled : bool ) -> bool Parameter Type Description enabled bool True to enable launch at login, False to disable Returns True if the operation was successful. Examples \u00b6 Toggle button \u00b6 import nib def main ( app : nib . App ): app . title = \"Settings\" app . icon = nib . SFSymbol ( \"gear\" ) app . width = 300 app . height = 100 status = nib . Text ( \"Checking...\" , foreground_color = nib . Color . SECONDARY ) def toggle (): current = app . launch_at_login . is_enabled app . launch_at_login . set ( not current ) status . content = \"Enabled\" if not current else \"Disabled\" def refresh (): enabled = app . launch_at_login . is_enabled status . content = \"Enabled\" if enabled else \"Disabled\" app . on_appear = refresh app . build ( nib . VStack ( controls = [ nib . HStack ( controls = [ nib . Text ( \"Launch at Login\" ), nib . Spacer (), status , ], ), nib . Button ( \"Toggle\" , action = toggle , style = nib . ButtonStyle . BORDERED ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Toggle with on_change callback \u00b6 import nib def main ( app : nib . App ): app . title = \"Preferences\" app . icon = nib . SFSymbol ( \"gear\" ) app . width = 320 app . height = 80 def on_change ( is_on ): app . launch_at_login . set ( is_on ) toggle = nib . Toggle ( is_on = False , label = \"Launch at Login\" , on_change = on_change , ) def refresh (): toggle . is_on = app . launch_at_login . is_enabled app . on_appear = refresh app . build ( nib . VStack ( controls = [ toggle ], padding = 20 , ) ) nib . run ( main )","title":"LaunchAtLogin"},{"location":"reference/services/launch-at-login/#properties","text":"","title":"Properties"},{"location":"reference/services/launch-at-login/#is_enabled","text":"Read-only property that checks whether the app is currently set to launch at login. app . launch_at_login . is_enabled -> bool Returns True if launch at login is enabled, False otherwise.","title":"is_enabled"},{"location":"reference/services/launch-at-login/#methods","text":"","title":"Methods"},{"location":"reference/services/launch-at-login/#setenabled","text":"Set the launch at login state. Call this only in response to a user action. app . launch_at_login . set ( enabled : bool ) -> bool Parameter Type Description enabled bool True to enable launch at login, False to disable Returns True if the operation was successful.","title":"set(enabled)"},{"location":"reference/services/launch-at-login/#examples","text":"","title":"Examples"},{"location":"reference/services/launch-at-login/#toggle-button","text":"import nib def main ( app : nib . App ): app . title = \"Settings\" app . icon = nib . SFSymbol ( \"gear\" ) app . width = 300 app . height = 100 status = nib . Text ( \"Checking...\" , foreground_color = nib . Color . SECONDARY ) def toggle (): current = app . launch_at_login . is_enabled app . launch_at_login . set ( not current ) status . content = \"Enabled\" if not current else \"Disabled\" def refresh (): enabled = app . launch_at_login . is_enabled status . content = \"Enabled\" if enabled else \"Disabled\" app . on_appear = refresh app . build ( nib . VStack ( controls = [ nib . HStack ( controls = [ nib . Text ( \"Launch at Login\" ), nib . Spacer (), status , ], ), nib . Button ( \"Toggle\" , action = toggle , style = nib . ButtonStyle . BORDERED ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Toggle button"},{"location":"reference/services/launch-at-login/#toggle-with-on_change-callback","text":"import nib def main ( app : nib . App ): app . title = \"Preferences\" app . icon = nib . SFSymbol ( \"gear\" ) app . width = 320 app . height = 80 def on_change ( is_on ): app . launch_at_login . set ( is_on ) toggle = nib . Toggle ( is_on = False , label = \"Launch at Login\" , on_change = on_change , ) def refresh (): toggle . is_on = app . launch_at_login . is_enabled app . on_appear = refresh app . build ( nib . VStack ( controls = [ toggle ], padding = 20 , ) ) nib . run ( main )","title":"Toggle with on_change callback"},{"location":"reference/services/permissions/","text":"The Permissions service provides a unified API for checking and requesting macOS permissions for Camera, Microphone, and Notifications. Access it via app.permissions . status = app . permissions . check ( nib . Permission . CAMERA ) if status == nib . PermissionStatus . NOT_DETERMINED : granted = app . permissions . request ( nib . Permission . CAMERA ) Methods \u00b6 check(permission) \u00b6 Check the current authorization status of a permission without prompting the user. app . permissions . check ( permission : Permission ) -> PermissionStatus Parameter Type Description permission Permission The permission to check Returns a PermissionStatus enum value. request(permission) \u00b6 Request authorization for a permission. If the permission status is NOT_DETERMINED , the system will display a permission dialog. If the permission has already been authorized or denied, the current state is returned without showing a dialog. app . permissions . request ( permission : Permission ) -> bool Parameter Type Description permission Permission The permission to request Returns True if the permission was granted, False otherwise. Enums \u00b6 Permission \u00b6 import nib # or: from nib.services.permissions import Permission Value Description nib.Permission.CAMERA Camera access nib.Permission.MICROPHONE Microphone access nib.Permission.NOTIFICATIONS Notification delivery PermissionStatus \u00b6 import nib # or: from nib.services.permissions import PermissionStatus Value Description nib.PermissionStatus.AUTHORIZED Permission has been granted nib.PermissionStatus.DENIED Permission has been denied by the user nib.PermissionStatus.NOT_DETERMINED Permission has not been requested yet nib.PermissionStatus.RESTRICTED Permission is restricted by system policy (e.g., parental controls) Examples \u00b6 Check and request camera permission \u00b6 import nib def main ( app : nib . App ): app . title = \"Permissions\" app . icon = nib . SFSymbol ( \"lock.shield\" ) app . width = 320 app . height = 200 camera_status = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) mic_status = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) notif_status = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) def refresh (): cam = app . permissions . check ( nib . Permission . CAMERA ) mic = app . permissions . check ( nib . Permission . MICROPHONE ) notif = app . permissions . check ( nib . Permission . NOTIFICATIONS ) camera_status . content = f \"Camera: { cam . value } \" mic_status . content = f \"Microphone: { mic . value } \" notif_status . content = f \"Notifications: { notif . value } \" def request_camera (): granted = app . permissions . request ( nib . Permission . CAMERA ) camera_status . content = f \"Camera: { 'authorized' if granted else 'denied' } \" def request_mic (): granted = app . permissions . request ( nib . Permission . MICROPHONE ) mic_status . content = f \"Microphone: { 'authorized' if granted else 'denied' } \" def request_notif (): granted = app . permissions . request ( nib . Permission . NOTIFICATIONS ) notif_status . content = f \"Notifications: { 'authorized' if granted else 'denied' } \" app . on_appear = refresh app . build ( nib . VStack ( controls = [ nib . Text ( \"Permissions\" , font = nib . Font . HEADLINE ), nib . HStack ( controls = [ camera_status , nib . Spacer (), nib . Button ( \"Request\" , action = request_camera )], spacing = 8 ), nib . HStack ( controls = [ mic_status , nib . Spacer (), nib . Button ( \"Request\" , action = request_mic )], spacing = 8 ), nib . HStack ( controls = [ notif_status , nib . Spacer (), nib . Button ( \"Request\" , action = request_notif )], spacing = 8 ), ], spacing = 10 , padding = 20 , ) ) nib . run ( main ) Gate a feature behind permission \u00b6 import nib def main ( app : nib . App ): app . title = \"Photo App\" app . icon = nib . SFSymbol ( \"camera\" ) app . width = 300 app . height = 150 status = nib . Text ( \"Checking camera access...\" , foreground_color = nib . Color . SECONDARY ) def check_and_capture (): perm = app . permissions . check ( nib . Permission . CAMERA ) if perm == nib . PermissionStatus . AUTHORIZED : frame = app . camera . capture_photo () frame . save ( \"/tmp/photo.jpg\" ) status . content = f \"Photo saved ( { frame . width } x { frame . height } )\" elif perm == nib . PermissionStatus . NOT_DETERMINED : granted = app . permissions . request ( nib . Permission . CAMERA ) if granted : status . content = \"Permission granted. Tap again to capture.\" else : status . content = \"Camera access denied.\" elif perm == nib . PermissionStatus . DENIED : status . content = \"Camera access denied. Enable in System Settings.\" else : status . content = \"Camera access restricted.\" app . build ( nib . VStack ( controls = [ nib . Button ( \"Take Photo\" , action = check_and_capture , style = nib . ButtonStyle . BORDERED_PROMINENT ), status , ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Permissions"},{"location":"reference/services/permissions/#methods","text":"","title":"Methods"},{"location":"reference/services/permissions/#checkpermission","text":"Check the current authorization status of a permission without prompting the user. app . permissions . check ( permission : Permission ) -> PermissionStatus Parameter Type Description permission Permission The permission to check Returns a PermissionStatus enum value.","title":"check(permission)"},{"location":"reference/services/permissions/#requestpermission","text":"Request authorization for a permission. If the permission status is NOT_DETERMINED , the system will display a permission dialog. If the permission has already been authorized or denied, the current state is returned without showing a dialog. app . permissions . request ( permission : Permission ) -> bool Parameter Type Description permission Permission The permission to request Returns True if the permission was granted, False otherwise.","title":"request(permission)"},{"location":"reference/services/permissions/#enums","text":"","title":"Enums"},{"location":"reference/services/permissions/#permission","text":"import nib # or: from nib.services.permissions import Permission Value Description nib.Permission.CAMERA Camera access nib.Permission.MICROPHONE Microphone access nib.Permission.NOTIFICATIONS Notification delivery","title":"Permission"},{"location":"reference/services/permissions/#permissionstatus","text":"import nib # or: from nib.services.permissions import PermissionStatus Value Description nib.PermissionStatus.AUTHORIZED Permission has been granted nib.PermissionStatus.DENIED Permission has been denied by the user nib.PermissionStatus.NOT_DETERMINED Permission has not been requested yet nib.PermissionStatus.RESTRICTED Permission is restricted by system policy (e.g., parental controls)","title":"PermissionStatus"},{"location":"reference/services/permissions/#examples","text":"","title":"Examples"},{"location":"reference/services/permissions/#check-and-request-camera-permission","text":"import nib def main ( app : nib . App ): app . title = \"Permissions\" app . icon = nib . SFSymbol ( \"lock.shield\" ) app . width = 320 app . height = 200 camera_status = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) mic_status = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) notif_status = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) def refresh (): cam = app . permissions . check ( nib . Permission . CAMERA ) mic = app . permissions . check ( nib . Permission . MICROPHONE ) notif = app . permissions . check ( nib . Permission . NOTIFICATIONS ) camera_status . content = f \"Camera: { cam . value } \" mic_status . content = f \"Microphone: { mic . value } \" notif_status . content = f \"Notifications: { notif . value } \" def request_camera (): granted = app . permissions . request ( nib . Permission . CAMERA ) camera_status . content = f \"Camera: { 'authorized' if granted else 'denied' } \" def request_mic (): granted = app . permissions . request ( nib . Permission . MICROPHONE ) mic_status . content = f \"Microphone: { 'authorized' if granted else 'denied' } \" def request_notif (): granted = app . permissions . request ( nib . Permission . NOTIFICATIONS ) notif_status . content = f \"Notifications: { 'authorized' if granted else 'denied' } \" app . on_appear = refresh app . build ( nib . VStack ( controls = [ nib . Text ( \"Permissions\" , font = nib . Font . HEADLINE ), nib . HStack ( controls = [ camera_status , nib . Spacer (), nib . Button ( \"Request\" , action = request_camera )], spacing = 8 ), nib . HStack ( controls = [ mic_status , nib . Spacer (), nib . Button ( \"Request\" , action = request_mic )], spacing = 8 ), nib . HStack ( controls = [ notif_status , nib . Spacer (), nib . Button ( \"Request\" , action = request_notif )], spacing = 8 ), ], spacing = 10 , padding = 20 , ) ) nib . run ( main )","title":"Check and request camera permission"},{"location":"reference/services/permissions/#gate-a-feature-behind-permission","text":"import nib def main ( app : nib . App ): app . title = \"Photo App\" app . icon = nib . SFSymbol ( \"camera\" ) app . width = 300 app . height = 150 status = nib . Text ( \"Checking camera access...\" , foreground_color = nib . Color . SECONDARY ) def check_and_capture (): perm = app . permissions . check ( nib . Permission . CAMERA ) if perm == nib . PermissionStatus . AUTHORIZED : frame = app . camera . capture_photo () frame . save ( \"/tmp/photo.jpg\" ) status . content = f \"Photo saved ( { frame . width } x { frame . height } )\" elif perm == nib . PermissionStatus . NOT_DETERMINED : granted = app . permissions . request ( nib . Permission . CAMERA ) if granted : status . content = \"Permission granted. Tap again to capture.\" else : status . content = \"Camera access denied.\" elif perm == nib . PermissionStatus . DENIED : status . content = \"Camera access denied. Enable in System Settings.\" else : status . content = \"Camera access restricted.\" app . build ( nib . VStack ( controls = [ nib . Button ( \"Take Photo\" , action = check_and_capture , style = nib . ButtonStyle . BORDERED_PROMINENT ), status , ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Gate a feature behind permission"},{"location":"reference/services/screen/","text":"The Screen service provides access to display information and control, including brightness, resolution, dark mode, screenshots, and multi-display management. Access it via app.screen . info = app . screen . get_info () print ( f \"Display: { info . name } \" ) print ( f \"Resolution: { info . width } x { info . height } @ { info . scale } x\" ) Methods \u00b6 get_info() \u00b6 Get information about the current display, including brightness, dimensions, refresh rate, color space, and native resolution. app . screen . get_info () -> ScreenInfo Returns a ScreenInfo dataclass. list_displays() \u00b6 List all connected displays with their properties. app . screen . list_displays () -> list [ dict ] Returns a list of dictionaries, each containing: Key Type Description index int Display index displayID int System display ID name str Display name (e.g., \"Built-in Retina Display\" ) width float Resolution width in points height float Resolution height in points scale float Scale factor (e.g., 2.0 for Retina) isMain bool Whether this is the main display isBuiltin bool Whether this is the built-in display refreshRate float Refresh rate in Hz colorSpace str Color space name set_brightness(brightness) \u00b6 Set the screen brightness. Only works on built-in displays. app . screen . set_brightness ( brightness : float ) -> bool Parameter Type Description brightness float Brightness level from 0.0 (darkest) to 1.0 (brightest). Values are clamped to this range. Returns True if brightness was set successfully. set_resolution(width, height) \u00b6 Change the screen resolution. The target resolution must be one of the available modes from get_info().available_resolutions . app . screen . set_resolution ( width : int , height : int ) -> bool Parameter Type Description width int Target width in points height int Target height in points Returns True if the resolution was changed successfully. get_dark_mode() \u00b6 Get the current dark mode status. app . screen . get_dark_mode () -> DarkModeInfo Returns a DarkModeInfo dataclass. set_dark_mode(enabled) \u00b6 Toggle system dark mode. Requires automation permission for System Events. app . screen . set_dark_mode ( enabled : bool ) -> bool Parameter Type Description enabled bool True for dark mode, False for light mode Returns True if the change was applied successfully. get_color_profile() \u00b6 Get the current color profile information. app . screen . get_color_profile () -> ColorProfileInfo Returns a ColorProfileInfo dataclass. screenshot(display_id, x, y, width, height) \u00b6 Capture a screenshot of the full screen or a specified region. Requires screen recording permission. app . screen . screenshot ( display_id : int | None = None , x : float | None = None , y : float | None = None , width : float | None = None , height : float | None = None , ) -> ScreenshotResult Parameter Type Default Description display_id int \\| None None Specific display ID. Uses the main display if None x float \\| None None X origin of the capture region y float \\| None None Y origin of the capture region width float \\| None None Width of the capture region height float \\| None None Height of the capture region All four region parameters ( x , y , width , height ) must be provided together or omitted entirely for a full-screen capture. Returns a ScreenshotResult dataclass. Data Classes \u00b6 ScreenInfo \u00b6 Display information returned by get_info() . Property Type Description brightness float \\| None Current brightness level (0.0--1.0). None if unavailable is_builtin bool Whether this is the built-in display width float Screen width in points height float Screen height in points scale float Display scale factor (e.g., 2.0 for Retina) visible_width float \\| None Visible width excluding dock and menu bar visible_height float \\| None Visible height excluding dock and menu bar display_id int \\| None System display identifier name str \\| None Display name (e.g., \"Built-in Retina Display\" ) refresh_rate float \\| None Display refresh rate in Hz native_width int \\| None Native pixel width native_height int \\| None Native pixel height color_space str \\| None Color space name color_depth int \\| None Bits per pixel available_resolutions list[dict] List of available display modes DarkModeInfo \u00b6 Dark mode information returned by get_dark_mode() . Property Type Description is_dark_mode bool Whether dark mode is currently enabled appearance_name str \\| None Full appearance name (e.g., \"NSAppearanceNameDarkAqua\" ) ColorProfileInfo \u00b6 Color profile information returned by get_color_profile() . Property Type Description color_space_name str \\| None Color space name color_component_count int \\| None Number of color components icc_profile_size int \\| None Size of ICC profile in bytes ScreenshotResult \u00b6 Screenshot result returned by screenshot() . Property Type Description success bool Whether the screenshot was captured successfully image_data bytes \\| None Raw PNG image data width int \\| None Image width in pixels height int \\| None Image height in pixels ScreenshotResult.save(path) \u00b6 Save the screenshot to a file. result . save ( path : str ) -> bool Parameter Type Description path str File path to save to (should end in .png ) Returns True if saved successfully, False if the screenshot was not captured or an I/O error occurred. Examples \u00b6 Display information dashboard \u00b6 import nib def main ( app : nib . App ): app . title = \"Display\" app . icon = nib . SFSymbol ( \"display\" ) app . width = 320 app . height = 250 name_text = nib . Text ( \"--\" , font = nib . Font . HEADLINE ) res_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) brightness_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) refresh_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) def refresh (): info = app . screen . get_info () name_text . content = info . name or \"Display\" res_text . content = f \" { info . width : .0f } x { info . height : .0f } @ { info . scale : .0f } x\" brightness_text . content = ( f \"Brightness: { info . brightness * 100 : .0f } %\" if info . brightness is not None else \"Brightness: N/A\" ) refresh_text . content = ( f \"Refresh rate: { info . refresh_rate : .0f } Hz\" if info . refresh_rate else \"Refresh rate: N/A\" ) app . on_appear = refresh app . build ( nib . VStack ( controls = [ name_text , res_text , brightness_text , refresh_text ], spacing = 8 , padding = 20 , ) ) nib . run ( main ) Brightness slider \u00b6 import nib def main ( app : nib . App ): app . title = \"Brightness\" app . icon = nib . SFSymbol ( \"sun.max\" ) app . width = 300 app . height = 120 label = nib . Text ( \"50%\" ) def on_change ( value ): app . screen . set_brightness ( value / 100 ) label . content = f \" { value : .0f } %\" def load_current (): info = app . screen . get_info () if info . brightness is not None : label . content = f \" { info . brightness * 100 : .0f } %\" app . on_appear = load_current app . build ( nib . VStack ( controls = [ label , nib . Slider ( value = 50 , min_value = 0 , max_value = 100 , on_change = on_change ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Dark mode toggle \u00b6 import nib def main ( app : nib . App ): app . title = \"Appearance\" app . icon = nib . SFSymbol ( \"moon.fill\" ) app . width = 280 app . height = 100 mode_text = nib . Text ( \"--\" , font = nib . Font . HEADLINE ) def refresh (): info = app . screen . get_dark_mode () mode_text . content = \"Dark Mode\" if info . is_dark_mode else \"Light Mode\" def toggle (): info = app . screen . get_dark_mode () app . screen . set_dark_mode ( not info . is_dark_mode ) refresh () app . on_appear = refresh app . build ( nib . VStack ( controls = [ mode_text , nib . Button ( \"Toggle\" , action = toggle , style = nib . ButtonStyle . BORDERED ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main ) Take a screenshot \u00b6 import nib def main ( app : nib . App ): app . title = \"Screenshot\" app . icon = nib . SFSymbol ( \"camera.viewfinder\" ) app . width = 300 app . height = 120 status = nib . Text ( \"Ready\" , foreground_color = nib . Color . SECONDARY ) def capture (): result = app . screen . screenshot () if result . success : saved = result . save ( \"/tmp/nib_screenshot.png\" ) if saved : status . content = f \"Saved { result . width } x { result . height } screenshot\" else : status . content = \"Failed to save screenshot\" else : status . content = \"Screenshot capture failed\" app . build ( nib . VStack ( controls = [ nib . Button ( \"Capture Screenshot\" , action = capture ), status , ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Screen"},{"location":"reference/services/screen/#methods","text":"","title":"Methods"},{"location":"reference/services/screen/#get_info","text":"Get information about the current display, including brightness, dimensions, refresh rate, color space, and native resolution. app . screen . get_info () -> ScreenInfo Returns a ScreenInfo dataclass.","title":"get_info()"},{"location":"reference/services/screen/#list_displays","text":"List all connected displays with their properties. app . screen . list_displays () -> list [ dict ] Returns a list of dictionaries, each containing: Key Type Description index int Display index displayID int System display ID name str Display name (e.g., \"Built-in Retina Display\" ) width float Resolution width in points height float Resolution height in points scale float Scale factor (e.g., 2.0 for Retina) isMain bool Whether this is the main display isBuiltin bool Whether this is the built-in display refreshRate float Refresh rate in Hz colorSpace str Color space name","title":"list_displays()"},{"location":"reference/services/screen/#set_brightnessbrightness","text":"Set the screen brightness. Only works on built-in displays. app . screen . set_brightness ( brightness : float ) -> bool Parameter Type Description brightness float Brightness level from 0.0 (darkest) to 1.0 (brightest). Values are clamped to this range. Returns True if brightness was set successfully.","title":"set_brightness(brightness)"},{"location":"reference/services/screen/#set_resolutionwidth-height","text":"Change the screen resolution. The target resolution must be one of the available modes from get_info().available_resolutions . app . screen . set_resolution ( width : int , height : int ) -> bool Parameter Type Description width int Target width in points height int Target height in points Returns True if the resolution was changed successfully.","title":"set_resolution(width, height)"},{"location":"reference/services/screen/#get_dark_mode","text":"Get the current dark mode status. app . screen . get_dark_mode () -> DarkModeInfo Returns a DarkModeInfo dataclass.","title":"get_dark_mode()"},{"location":"reference/services/screen/#set_dark_modeenabled","text":"Toggle system dark mode. Requires automation permission for System Events. app . screen . set_dark_mode ( enabled : bool ) -> bool Parameter Type Description enabled bool True for dark mode, False for light mode Returns True if the change was applied successfully.","title":"set_dark_mode(enabled)"},{"location":"reference/services/screen/#get_color_profile","text":"Get the current color profile information. app . screen . get_color_profile () -> ColorProfileInfo Returns a ColorProfileInfo dataclass.","title":"get_color_profile()"},{"location":"reference/services/screen/#screenshotdisplay_id-x-y-width-height","text":"Capture a screenshot of the full screen or a specified region. Requires screen recording permission. app . screen . screenshot ( display_id : int | None = None , x : float | None = None , y : float | None = None , width : float | None = None , height : float | None = None , ) -> ScreenshotResult Parameter Type Default Description display_id int \\| None None Specific display ID. Uses the main display if None x float \\| None None X origin of the capture region y float \\| None None Y origin of the capture region width float \\| None None Width of the capture region height float \\| None None Height of the capture region All four region parameters ( x , y , width , height ) must be provided together or omitted entirely for a full-screen capture. Returns a ScreenshotResult dataclass.","title":"screenshot(display_id, x, y, width, height)"},{"location":"reference/services/screen/#data-classes","text":"","title":"Data Classes"},{"location":"reference/services/screen/#screeninfo","text":"Display information returned by get_info() . Property Type Description brightness float \\| None Current brightness level (0.0--1.0). None if unavailable is_builtin bool Whether this is the built-in display width float Screen width in points height float Screen height in points scale float Display scale factor (e.g., 2.0 for Retina) visible_width float \\| None Visible width excluding dock and menu bar visible_height float \\| None Visible height excluding dock and menu bar display_id int \\| None System display identifier name str \\| None Display name (e.g., \"Built-in Retina Display\" ) refresh_rate float \\| None Display refresh rate in Hz native_width int \\| None Native pixel width native_height int \\| None Native pixel height color_space str \\| None Color space name color_depth int \\| None Bits per pixel available_resolutions list[dict] List of available display modes","title":"ScreenInfo"},{"location":"reference/services/screen/#darkmodeinfo","text":"Dark mode information returned by get_dark_mode() . Property Type Description is_dark_mode bool Whether dark mode is currently enabled appearance_name str \\| None Full appearance name (e.g., \"NSAppearanceNameDarkAqua\" )","title":"DarkModeInfo"},{"location":"reference/services/screen/#colorprofileinfo","text":"Color profile information returned by get_color_profile() . Property Type Description color_space_name str \\| None Color space name color_component_count int \\| None Number of color components icc_profile_size int \\| None Size of ICC profile in bytes","title":"ColorProfileInfo"},{"location":"reference/services/screen/#screenshotresult","text":"Screenshot result returned by screenshot() . Property Type Description success bool Whether the screenshot was captured successfully image_data bytes \\| None Raw PNG image data width int \\| None Image width in pixels height int \\| None Image height in pixels","title":"ScreenshotResult"},{"location":"reference/services/screen/#screenshotresultsavepath","text":"Save the screenshot to a file. result . save ( path : str ) -> bool Parameter Type Description path str File path to save to (should end in .png ) Returns True if saved successfully, False if the screenshot was not captured or an I/O error occurred.","title":"ScreenshotResult.save(path)"},{"location":"reference/services/screen/#examples","text":"","title":"Examples"},{"location":"reference/services/screen/#display-information-dashboard","text":"import nib def main ( app : nib . App ): app . title = \"Display\" app . icon = nib . SFSymbol ( \"display\" ) app . width = 320 app . height = 250 name_text = nib . Text ( \"--\" , font = nib . Font . HEADLINE ) res_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) brightness_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) refresh_text = nib . Text ( \"--\" , foreground_color = nib . Color . SECONDARY ) def refresh (): info = app . screen . get_info () name_text . content = info . name or \"Display\" res_text . content = f \" { info . width : .0f } x { info . height : .0f } @ { info . scale : .0f } x\" brightness_text . content = ( f \"Brightness: { info . brightness * 100 : .0f } %\" if info . brightness is not None else \"Brightness: N/A\" ) refresh_text . content = ( f \"Refresh rate: { info . refresh_rate : .0f } Hz\" if info . refresh_rate else \"Refresh rate: N/A\" ) app . on_appear = refresh app . build ( nib . VStack ( controls = [ name_text , res_text , brightness_text , refresh_text ], spacing = 8 , padding = 20 , ) ) nib . run ( main )","title":"Display information dashboard"},{"location":"reference/services/screen/#brightness-slider","text":"import nib def main ( app : nib . App ): app . title = \"Brightness\" app . icon = nib . SFSymbol ( \"sun.max\" ) app . width = 300 app . height = 120 label = nib . Text ( \"50%\" ) def on_change ( value ): app . screen . set_brightness ( value / 100 ) label . content = f \" { value : .0f } %\" def load_current (): info = app . screen . get_info () if info . brightness is not None : label . content = f \" { info . brightness * 100 : .0f } %\" app . on_appear = load_current app . build ( nib . VStack ( controls = [ label , nib . Slider ( value = 50 , min_value = 0 , max_value = 100 , on_change = on_change ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Brightness slider"},{"location":"reference/services/screen/#dark-mode-toggle","text":"import nib def main ( app : nib . App ): app . title = \"Appearance\" app . icon = nib . SFSymbol ( \"moon.fill\" ) app . width = 280 app . height = 100 mode_text = nib . Text ( \"--\" , font = nib . Font . HEADLINE ) def refresh (): info = app . screen . get_dark_mode () mode_text . content = \"Dark Mode\" if info . is_dark_mode else \"Light Mode\" def toggle (): info = app . screen . get_dark_mode () app . screen . set_dark_mode ( not info . is_dark_mode ) refresh () app . on_appear = refresh app . build ( nib . VStack ( controls = [ mode_text , nib . Button ( \"Toggle\" , action = toggle , style = nib . ButtonStyle . BORDERED ), ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Dark mode toggle"},{"location":"reference/services/screen/#take-a-screenshot","text":"import nib def main ( app : nib . App ): app . title = \"Screenshot\" app . icon = nib . SFSymbol ( \"camera.viewfinder\" ) app . width = 300 app . height = 120 status = nib . Text ( \"Ready\" , foreground_color = nib . Color . SECONDARY ) def capture (): result = app . screen . screenshot () if result . success : saved = result . save ( \"/tmp/nib_screenshot.png\" ) if saved : status . content = f \"Saved { result . width } x { result . height } screenshot\" else : status . content = \"Failed to save screenshot\" else : status . content = \"Screenshot capture failed\" app . build ( nib . VStack ( controls = [ nib . Button ( \"Capture Screenshot\" , action = capture ), status , ], spacing = 12 , padding = 20 , ) ) nib . run ( main )","title":"Take a screenshot"},{"location":"reference/types/","text":"Nib provides a set of types, dataclasses, and enums used to configure views, styling, animations, and layout. All types are importable directly from the nib module. import nib color = nib . Color ( hex = \"#4287f5\" ) font = nib . Font . system ( 16 , nib . FontWeight . BOLD ) animation = nib . Animation . spring () Type Classes \u00b6 Type Description Color Color values -- named, hex, RGB, RGBA Font Font configuration -- system fonts and custom font files Animation Animation timing curves and spring configurations Transition View appearance/disappearance animations and content transitions TextStyle & AttributedString Rich text styling and multi-segment attributed strings Offset & CornerRadius Position offsets and per-corner radius configuration Enum References \u00b6 Page Enums Style Enums ButtonStyle, ButtonRole, BorderShape, ControlSize, LabelStyle, ToggleStyle, TextFieldStyle, EditorStyle, PickerStyle, ProgressStyle, FormStyle Alignment Enums HorizontalAlignment, VerticalAlignment, Alignment, ScrollAxis Image Enums ImageRenderingMode, SymbolScale, SymbolRenderingMode, ContentMode, TruncationMode, TextCase BlendMode All layer blending modes","title":"Index"},{"location":"reference/types/#type-classes","text":"Type Description Color Color values -- named, hex, RGB, RGBA Font Font configuration -- system fonts and custom font files Animation Animation timing curves and spring configurations Transition View appearance/disappearance animations and content transitions TextStyle & AttributedString Rich text styling and multi-segment attributed strings Offset & CornerRadius Position offsets and per-corner radius configuration","title":"Type Classes"},{"location":"reference/types/#enum-references","text":"Page Enums Style Enums ButtonStyle, ButtonRole, BorderShape, ControlSize, LabelStyle, ToggleStyle, TextFieldStyle, EditorStyle, PickerStyle, ProgressStyle, FormStyle Alignment Enums HorizontalAlignment, VerticalAlignment, Alignment, ScrollAxis Image Enums ImageRenderingMode, SymbolScale, SymbolRenderingMode, ContentMode, TruncationMode, TextCase BlendMode All layer blending modes","title":"Enum References"},{"location":"reference/types/alignment-enums/","text":"Nib provides alignment enums that control how views are positioned within their containers. Each enum maps directly to a SwiftUI alignment type. HorizontalAlignment \u00b6 Controls horizontal alignment of children within a VStack . Value SwiftUI Equivalent Description HorizontalAlignment.LEADING .leading Align children to the left (LTR) or right (RTL) edge. HorizontalAlignment.CENTER .center Center children horizontally (default). HorizontalAlignment.TRAILING .trailing Align children to the right (LTR) or left (RTL) edge. import nib nib . VStack ( controls = [ nib . Text ( \"Left-aligned title\" ), nib . Text ( \"Left-aligned body\" ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 4 , ) VerticalAlignment \u00b6 Controls vertical alignment of children within an HStack . Value SwiftUI Equivalent Description VerticalAlignment.TOP .top Align children to the top edge. VerticalAlignment.CENTER .center Center children vertically (default). VerticalAlignment.BOTTOM .bottom Align children to the bottom edge. import nib nib . HStack ( controls = [ nib . Text ( \"Label\" , font = nib . Font . CAPTION ), nib . Text ( \"Value\" , font = nib . Font . TITLE ), ], alignment = nib . VerticalAlignment . BOTTOM , spacing = 8 , ) Alignment \u00b6 Combined two-dimensional alignment for ZStack and the frame modifier. Specifies both horizontal and vertical alignment simultaneously. Value SwiftUI Equivalent Description Alignment.TOP_LEADING .topLeading Top-left corner. Alignment.TOP .top Top edge, centered horizontally. Alignment.TOP_TRAILING .topTrailing Top-right corner. Alignment.LEADING .leading Left edge, centered vertically. Alignment.CENTER .center Center of the view (default). Alignment.TRAILING .trailing Right edge, centered vertically. Alignment.BOTTOM_LEADING .bottomLeading Bottom-left corner. Alignment.BOTTOM .bottom Bottom edge, centered horizontally. Alignment.BOTTOM_TRAILING .bottomTrailing Bottom-right corner. import nib # Badge in the top-right corner of a ZStack nib . ZStack ( controls = [ nib . Rectangle ( fill = \"#333\" , width = 200 , height = 100 , corner_radius = 12 ), nib . Text ( \"3\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE , background = nib . Color . RED , padding = { \"horizontal\" : 6 , \"vertical\" : 2 }, corner_radius = 8 , ), ], alignment = nib . Alignment . TOP_TRAILING , ) ScrollAxis \u00b6 Controls the scroll direction for ScrollView containers. Value SwiftUI Equivalent Description ScrollAxis.VERTICAL .vertical Scroll vertically (default). ScrollAxis.HORIZONTAL .horizontal Scroll horizontally. ScrollAxis.BOTH [.vertical, .horizontal] Scroll in both directions. import nib # Vertical scrolling list nib . ScrollView ( controls = [ nib . Text ( f \"Item { i } \" ) for i in range ( 50 )], axis = nib . ScrollAxis . VERTICAL , ) # Horizontal scrolling row nib . ScrollView ( controls = [ nib . Rectangle ( fill = \"blue\" , width = 100 , height = 100 , corner_radius = 8 ) for _ in range ( 10 ) ], axis = nib . ScrollAxis . HORIZONTAL , ) Examples \u00b6 Combining alignments in a layout \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ # Header aligned to leading edge nib . Text ( \"My App\" , font = nib . Font . LARGE_TITLE ), # Content in a ZStack with alignment nib . ZStack ( controls = [ nib . Rectangle ( fill = \"#1E1E1E\" , width = 250 , height = 150 , corner_radius = 12 , ), nib . Text ( \"Centered\" , foreground_color = nib . Color . WHITE , ), ], alignment = nib . Alignment . CENTER , ), # Footer row aligned to bottom nib . HStack ( controls = [ nib . Text ( \"v1.0\" , font = nib . Font . CAPTION ), nib . Spacer (), nib . Text ( \"Status: OK\" , font = nib . Font . CAPTION ), ], alignment = nib . VerticalAlignment . BOTTOM , ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Alignment Enums"},{"location":"reference/types/alignment-enums/#horizontalalignment","text":"Controls horizontal alignment of children within a VStack . Value SwiftUI Equivalent Description HorizontalAlignment.LEADING .leading Align children to the left (LTR) or right (RTL) edge. HorizontalAlignment.CENTER .center Center children horizontally (default). HorizontalAlignment.TRAILING .trailing Align children to the right (LTR) or left (RTL) edge. import nib nib . VStack ( controls = [ nib . Text ( \"Left-aligned title\" ), nib . Text ( \"Left-aligned body\" ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 4 , )","title":"HorizontalAlignment"},{"location":"reference/types/alignment-enums/#verticalalignment","text":"Controls vertical alignment of children within an HStack . Value SwiftUI Equivalent Description VerticalAlignment.TOP .top Align children to the top edge. VerticalAlignment.CENTER .center Center children vertically (default). VerticalAlignment.BOTTOM .bottom Align children to the bottom edge. import nib nib . HStack ( controls = [ nib . Text ( \"Label\" , font = nib . Font . CAPTION ), nib . Text ( \"Value\" , font = nib . Font . TITLE ), ], alignment = nib . VerticalAlignment . BOTTOM , spacing = 8 , )","title":"VerticalAlignment"},{"location":"reference/types/alignment-enums/#alignment","text":"Combined two-dimensional alignment for ZStack and the frame modifier. Specifies both horizontal and vertical alignment simultaneously. Value SwiftUI Equivalent Description Alignment.TOP_LEADING .topLeading Top-left corner. Alignment.TOP .top Top edge, centered horizontally. Alignment.TOP_TRAILING .topTrailing Top-right corner. Alignment.LEADING .leading Left edge, centered vertically. Alignment.CENTER .center Center of the view (default). Alignment.TRAILING .trailing Right edge, centered vertically. Alignment.BOTTOM_LEADING .bottomLeading Bottom-left corner. Alignment.BOTTOM .bottom Bottom edge, centered horizontally. Alignment.BOTTOM_TRAILING .bottomTrailing Bottom-right corner. import nib # Badge in the top-right corner of a ZStack nib . ZStack ( controls = [ nib . Rectangle ( fill = \"#333\" , width = 200 , height = 100 , corner_radius = 12 ), nib . Text ( \"3\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE , background = nib . Color . RED , padding = { \"horizontal\" : 6 , \"vertical\" : 2 }, corner_radius = 8 , ), ], alignment = nib . Alignment . TOP_TRAILING , )","title":"Alignment"},{"location":"reference/types/alignment-enums/#scrollaxis","text":"Controls the scroll direction for ScrollView containers. Value SwiftUI Equivalent Description ScrollAxis.VERTICAL .vertical Scroll vertically (default). ScrollAxis.HORIZONTAL .horizontal Scroll horizontally. ScrollAxis.BOTH [.vertical, .horizontal] Scroll in both directions. import nib # Vertical scrolling list nib . ScrollView ( controls = [ nib . Text ( f \"Item { i } \" ) for i in range ( 50 )], axis = nib . ScrollAxis . VERTICAL , ) # Horizontal scrolling row nib . ScrollView ( controls = [ nib . Rectangle ( fill = \"blue\" , width = 100 , height = 100 , corner_radius = 8 ) for _ in range ( 10 ) ], axis = nib . ScrollAxis . HORIZONTAL , )","title":"ScrollAxis"},{"location":"reference/types/alignment-enums/#examples","text":"","title":"Examples"},{"location":"reference/types/alignment-enums/#combining-alignments-in-a-layout","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ # Header aligned to leading edge nib . Text ( \"My App\" , font = nib . Font . LARGE_TITLE ), # Content in a ZStack with alignment nib . ZStack ( controls = [ nib . Rectangle ( fill = \"#1E1E1E\" , width = 250 , height = 150 , corner_radius = 12 , ), nib . Text ( \"Centered\" , foreground_color = nib . Color . WHITE , ), ], alignment = nib . Alignment . CENTER , ), # Footer row aligned to bottom nib . HStack ( controls = [ nib . Text ( \"v1.0\" , font = nib . Font . CAPTION ), nib . Spacer (), nib . Text ( \"Status: OK\" , font = nib . Font . CAPTION ), ], alignment = nib . VerticalAlignment . BOTTOM , ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Combining alignments in a layout"},{"location":"reference/types/animation/","text":"The Animation dataclass configures how property changes are animated. Animations control the timing curve and duration of transitions when view properties are mutated. import nib counter = nib . Text ( \"0\" , animation = nib . Animation . spring ()) def increment (): counter . content = str ( int ( counter . content ) + 1 ) # Change animates automatically Constructor \u00b6 Animation ( type , duration = None , delay = None , response = None , damping = None ) The Animation dataclass is not typically constructed directly. Use the factory methods below instead. Field Type Default Description type str -- Animation type: \"linear\" , \"easeIn\" , \"easeOut\" , \"easeInOut\" , or \"spring\" . duration float None Duration in seconds (for timing-curve animations). delay float None Delay before the animation starts, in seconds. response float None Spring response time -- how quickly the spring settles (spring animations only). damping float None Spring damping fraction -- how much the spring bounces (spring animations only). Factory Methods \u00b6 Animation.linear(duration=0.3) \u00b6 Create a linear animation with constant speed. anim = nib . Animation . linear ( 0.5 ) Parameter Type Default Description duration float 0.3 Duration in seconds. Animation.easeIn(duration=0.3) \u00b6 Create an ease-in animation that starts slow and accelerates. anim = nib . Animation . easeIn ( 0.3 ) Parameter Type Default Description duration float 0.3 Duration in seconds. Animation.easeOut(duration=0.3) \u00b6 Create an ease-out animation that starts fast and decelerates. anim = nib . Animation . easeOut ( 0.2 ) Parameter Type Default Description duration float 0.3 Duration in seconds. Animation.easeInOut(duration=0.3) \u00b6 Create an ease-in-out animation that starts and ends slowly with faster motion in the middle. anim = nib . Animation . easeInOut ( 0.4 ) Parameter Type Default Description duration float 0.3 Duration in seconds. Animation.spring(response=0.3, damping=0.7) \u00b6 Create a spring animation with physics-based timing. Spring animations feel more natural than timing curves. anim = nib . Animation . spring () # Default spring anim = nib . Animation . spring ( response = 0.5 , damping = 0.6 ) # Custom spring Parameter Type Default Description response float 0.3 How quickly the spring settles (lower values = faster). damping float 0.7 How much the spring bounces. 0.0 = oscillates forever, 1.0 = no bounce (critical damping). Presets \u00b6 Nib provides four built-in animation presets as class attributes: Preset Equivalent Description Animation.default Animation.easeInOut(0.3) Standard animation for most UI changes. Animation.fast Animation.easeOut(0.15) Quick animation for responsive feedback. Animation.slow Animation.easeInOut(0.5) Slower animation for emphasis. Animation.bouncy Animation.spring(0.3, 0.5) Bouncy spring animation. nib . Text ( \"Quick\" , animation = nib . Animation . fast ) nib . Text ( \"Bouncy\" , animation = nib . Animation . bouncy ) Sticky Animations \u00b6 When an animation is set on a view, it becomes \"sticky\" -- all future property changes on that view are animated using the same configuration. This means you only need to set the animation once. import nib def main ( app : nib . App ): # Animation is set once and applies to all future mutations label = nib . Text ( \"0\" , font = nib . Font . TITLE , animation = nib . Animation . spring ()) def increment (): label . content = str ( int ( label . content ) + 1 ) # Animates with spring app . build ( nib . VStack ( controls = [ label , nib . Button ( \"Increment\" , action = increment ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Examples \u00b6 Animated counter with numeric text transition \u00b6 import nib def main ( app : nib . App ): count = nib . Text ( \"0\" , font = nib . Font . system ( 48 , nib . FontWeight . BOLD ), animation = nib . Animation . spring ( response = 0.4 , damping = 0.6 ), content_transition = nib . ContentTransition . NUMERIC_TEXT , ) def increment (): count . content = str ( int ( count . content ) + 1 ) app . build ( nib . VStack ( controls = [ count , nib . Button ( \"Add\" , action = increment )], spacing = 16 , padding = 20 , ) ) nib . run ( main ) Animated opacity toggle \u00b6 import nib def main ( app : nib . App ): box = nib . Rectangle ( fill = nib . Color . BLUE , width = 100 , height = 100 , corner_radius = 12 , animation = nib . Animation . easeInOut ( 0.4 ), ) def toggle (): box . opacity = 0.2 if ( box . opacity or 1.0 ) > 0.5 else 1.0 app . build ( nib . VStack ( controls = [ box , nib . Button ( \"Toggle\" , action = toggle )], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Animation"},{"location":"reference/types/animation/#constructor","text":"Animation ( type , duration = None , delay = None , response = None , damping = None ) The Animation dataclass is not typically constructed directly. Use the factory methods below instead. Field Type Default Description type str -- Animation type: \"linear\" , \"easeIn\" , \"easeOut\" , \"easeInOut\" , or \"spring\" . duration float None Duration in seconds (for timing-curve animations). delay float None Delay before the animation starts, in seconds. response float None Spring response time -- how quickly the spring settles (spring animations only). damping float None Spring damping fraction -- how much the spring bounces (spring animations only).","title":"Constructor"},{"location":"reference/types/animation/#factory-methods","text":"","title":"Factory Methods"},{"location":"reference/types/animation/#animationlinearduration03","text":"Create a linear animation with constant speed. anim = nib . Animation . linear ( 0.5 ) Parameter Type Default Description duration float 0.3 Duration in seconds.","title":"Animation.linear(duration=0.3)"},{"location":"reference/types/animation/#animationeaseinduration03","text":"Create an ease-in animation that starts slow and accelerates. anim = nib . Animation . easeIn ( 0.3 ) Parameter Type Default Description duration float 0.3 Duration in seconds.","title":"Animation.easeIn(duration=0.3)"},{"location":"reference/types/animation/#animationeaseoutduration03","text":"Create an ease-out animation that starts fast and decelerates. anim = nib . Animation . easeOut ( 0.2 ) Parameter Type Default Description duration float 0.3 Duration in seconds.","title":"Animation.easeOut(duration=0.3)"},{"location":"reference/types/animation/#animationeaseinoutduration03","text":"Create an ease-in-out animation that starts and ends slowly with faster motion in the middle. anim = nib . Animation . easeInOut ( 0.4 ) Parameter Type Default Description duration float 0.3 Duration in seconds.","title":"Animation.easeInOut(duration=0.3)"},{"location":"reference/types/animation/#animationspringresponse03-damping07","text":"Create a spring animation with physics-based timing. Spring animations feel more natural than timing curves. anim = nib . Animation . spring () # Default spring anim = nib . Animation . spring ( response = 0.5 , damping = 0.6 ) # Custom spring Parameter Type Default Description response float 0.3 How quickly the spring settles (lower values = faster). damping float 0.7 How much the spring bounces. 0.0 = oscillates forever, 1.0 = no bounce (critical damping).","title":"Animation.spring(response=0.3, damping=0.7)"},{"location":"reference/types/animation/#presets","text":"Nib provides four built-in animation presets as class attributes: Preset Equivalent Description Animation.default Animation.easeInOut(0.3) Standard animation for most UI changes. Animation.fast Animation.easeOut(0.15) Quick animation for responsive feedback. Animation.slow Animation.easeInOut(0.5) Slower animation for emphasis. Animation.bouncy Animation.spring(0.3, 0.5) Bouncy spring animation. nib . Text ( \"Quick\" , animation = nib . Animation . fast ) nib . Text ( \"Bouncy\" , animation = nib . Animation . bouncy )","title":"Presets"},{"location":"reference/types/animation/#sticky-animations","text":"When an animation is set on a view, it becomes \"sticky\" -- all future property changes on that view are animated using the same configuration. This means you only need to set the animation once. import nib def main ( app : nib . App ): # Animation is set once and applies to all future mutations label = nib . Text ( \"0\" , font = nib . Font . TITLE , animation = nib . Animation . spring ()) def increment (): label . content = str ( int ( label . content ) + 1 ) # Animates with spring app . build ( nib . VStack ( controls = [ label , nib . Button ( \"Increment\" , action = increment ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Sticky Animations"},{"location":"reference/types/animation/#examples","text":"","title":"Examples"},{"location":"reference/types/animation/#animated-counter-with-numeric-text-transition","text":"import nib def main ( app : nib . App ): count = nib . Text ( \"0\" , font = nib . Font . system ( 48 , nib . FontWeight . BOLD ), animation = nib . Animation . spring ( response = 0.4 , damping = 0.6 ), content_transition = nib . ContentTransition . NUMERIC_TEXT , ) def increment (): count . content = str ( int ( count . content ) + 1 ) app . build ( nib . VStack ( controls = [ count , nib . Button ( \"Add\" , action = increment )], spacing = 16 , padding = 20 , ) ) nib . run ( main )","title":"Animated counter with numeric text transition"},{"location":"reference/types/animation/#animated-opacity-toggle","text":"import nib def main ( app : nib . App ): box = nib . Rectangle ( fill = nib . Color . BLUE , width = 100 , height = 100 , corner_radius = 12 , animation = nib . Animation . easeInOut ( 0.4 ), ) def toggle (): box . opacity = 0.2 if ( box . opacity or 1.0 ) > 0.5 else 1.0 app . build ( nib . VStack ( controls = [ box , nib . Button ( \"Toggle\" , action = toggle )], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Animated opacity toggle"},{"location":"reference/types/blend-mode/","text":"The BlendMode enum controls how a view is composited with the content behind it. It maps directly to SwiftUI's .blendMode() view modifier. import nib nib . Image ( source = \"overlay.png\" , blend_mode = nib . BlendMode . MULTIPLY ) Values \u00b6 Value SwiftUI Equivalent Description BlendMode.NORMAL .normal No blending (default). The source view completely covers content behind it. BlendMode.MULTIPLY .multiply Multiplies the source and destination colors. Always produces darker results. BlendMode.SCREEN .screen Inverts, multiplies, and inverts again. Always produces lighter results. BlendMode.OVERLAY .overlay Combines multiply and screen. Light areas get lighter, dark areas get darker. BlendMode.DARKEN .darken Selects the darker of the source and destination colors per channel. BlendMode.LIGHTEN .lighten Selects the lighter of the source and destination colors per channel. BlendMode.COLOR_DODGE .colorDodge Brightens the destination color to reflect the source. BlendMode.COLOR_BURN .colorBurn Darkens the destination color to reflect the source. BlendMode.SOFT_LIGHT .softLight A softer version of overlay. BlendMode.HARD_LIGHT .hardLight Similar to overlay but with the source and destination roles swapped. BlendMode.DIFFERENCE .difference Subtracts the darker color from the lighter one. BlendMode.EXCLUSION .exclusion Similar to difference but with lower contrast. BlendMode.HUE .hue Uses the hue of the source with the saturation and luminosity of the destination. BlendMode.SATURATION .saturation Uses the saturation of the source with the hue and luminosity of the destination. BlendMode.COLOR .color Uses the hue and saturation of the source with the luminosity of the destination. BlendMode.LUMINOSITY .luminosity Uses the luminosity of the source with the hue and saturation of the destination. Usage \u00b6 Pass a BlendMode value to the blend_mode parameter on any view: nib . Rectangle ( fill = nib . Color . BLUE , blend_mode = nib . BlendMode . OVERLAY ) You can also pass a string: nib . Rectangle ( fill = nib . Color . BLUE , blend_mode = \"overlay\" ) Examples \u00b6 Color overlay on an image \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Image ( source = \"photo.jpg\" , width = 300 , height = 200 ), nib . Rectangle ( fill = nib . Color . BLUE . with_opacity ( 0.4 ), width = 300 , height = 200 , blend_mode = nib . BlendMode . OVERLAY , ), ], ) ) nib . run ( main ) Layered shapes with blend modes \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Circle ( fill = nib . Color . RED , width = 120 , height = 120 ), nib . Circle ( fill = nib . Color . BLUE , width = 120 , height = 120 , offset = nib . Offset ( 40 , 0 ), blend_mode = nib . BlendMode . SCREEN , ), nib . Circle ( fill = nib . Color . GREEN , width = 120 , height = 120 , offset = nib . Offset ( 20 , 35 ), blend_mode = nib . BlendMode . SCREEN , ), ], padding = 40 , ) ) nib . run ( main )","title":"BlendMode"},{"location":"reference/types/blend-mode/#values","text":"Value SwiftUI Equivalent Description BlendMode.NORMAL .normal No blending (default). The source view completely covers content behind it. BlendMode.MULTIPLY .multiply Multiplies the source and destination colors. Always produces darker results. BlendMode.SCREEN .screen Inverts, multiplies, and inverts again. Always produces lighter results. BlendMode.OVERLAY .overlay Combines multiply and screen. Light areas get lighter, dark areas get darker. BlendMode.DARKEN .darken Selects the darker of the source and destination colors per channel. BlendMode.LIGHTEN .lighten Selects the lighter of the source and destination colors per channel. BlendMode.COLOR_DODGE .colorDodge Brightens the destination color to reflect the source. BlendMode.COLOR_BURN .colorBurn Darkens the destination color to reflect the source. BlendMode.SOFT_LIGHT .softLight A softer version of overlay. BlendMode.HARD_LIGHT .hardLight Similar to overlay but with the source and destination roles swapped. BlendMode.DIFFERENCE .difference Subtracts the darker color from the lighter one. BlendMode.EXCLUSION .exclusion Similar to difference but with lower contrast. BlendMode.HUE .hue Uses the hue of the source with the saturation and luminosity of the destination. BlendMode.SATURATION .saturation Uses the saturation of the source with the hue and luminosity of the destination. BlendMode.COLOR .color Uses the hue and saturation of the source with the luminosity of the destination. BlendMode.LUMINOSITY .luminosity Uses the luminosity of the source with the hue and saturation of the destination.","title":"Values"},{"location":"reference/types/blend-mode/#usage","text":"Pass a BlendMode value to the blend_mode parameter on any view: nib . Rectangle ( fill = nib . Color . BLUE , blend_mode = nib . BlendMode . OVERLAY ) You can also pass a string: nib . Rectangle ( fill = nib . Color . BLUE , blend_mode = \"overlay\" )","title":"Usage"},{"location":"reference/types/blend-mode/#examples","text":"","title":"Examples"},{"location":"reference/types/blend-mode/#color-overlay-on-an-image","text":"import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Image ( source = \"photo.jpg\" , width = 300 , height = 200 ), nib . Rectangle ( fill = nib . Color . BLUE . with_opacity ( 0.4 ), width = 300 , height = 200 , blend_mode = nib . BlendMode . OVERLAY , ), ], ) ) nib . run ( main )","title":"Color overlay on an image"},{"location":"reference/types/blend-mode/#layered-shapes-with-blend-modes","text":"import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Circle ( fill = nib . Color . RED , width = 120 , height = 120 ), nib . Circle ( fill = nib . Color . BLUE , width = 120 , height = 120 , offset = nib . Offset ( 40 , 0 ), blend_mode = nib . BlendMode . SCREEN , ), nib . Circle ( fill = nib . Color . GREEN , width = 120 , height = 120 , offset = nib . Offset ( 20 , 35 ), blend_mode = nib . BlendMode . SCREEN , ), ], padding = 40 , ) ) nib . run ( main )","title":"Layered shapes with blend modes"},{"location":"reference/types/color/","text":"The Color dataclass represents color values for styling views. Colors can be defined using predefined constants, hex strings, RGB values, or named system colors. import nib # Predefined color text = nib . Text ( \"Hello\" , foreground_color = nib . Color . BLUE ) # Hex color box = nib . Rectangle ( fill = nib . Color ( hex = \"#4287f5\" )) # RGB color accent = nib . Color . rgb ( 66 , 135 , 245 ) Constructor \u00b6 Color ( value = None , * , hex = None , opacity = None ) Parameter Type Default Description value str None Named color string (e.g., \"red\" , \"blue\" ). Used internally by predefined constants. hex str None Hex color string. Accepts \"#4287f5\" or \"4287f5\" (the # prefix is added automatically). Supports ARGB alpha channel: \"#7fff6666\" . opacity float None Opacity from 0.0 (fully transparent) to 1.0 (fully opaque). Either value or hex must be provided. A ValueError is raised if neither is given. Class Methods \u00b6 Color.hex(hex_value) \u00b6 Create a color from a hex string. color = nib . Color . hex ( \"#4287f5\" ) Parameter Type Description hex_value str Hex color string, with or without # prefix. Color.rgb(r, g, b) \u00b6 Create a color from RGB values in the 0--255 range. color = nib . Color . rgb ( 66 , 135 , 245 ) Parameter Type Description r int Red component (0--255). g int Green component (0--255). b int Blue component (0--255). Color.rgba(r, g, b, a) \u00b6 Create a color from RGBA values. RGB components are 0--255, alpha is 0.0--1.0. color = nib . Color . rgba ( 66 , 135 , 245 , 0.8 ) Parameter Type Description r int Red component (0--255). g int Green component (0--255). b int Blue component (0--255). a float Alpha/opacity (0.0--1.0). Instance Methods \u00b6 color.with_opacity(opacity) \u00b6 Return a new Color with the specified opacity. The original color is not modified. faded_blue = nib . Color . BLUE . with_opacity ( 0.5 ) custom = nib . Color ( hex = \"#FF5733\" ) . with_opacity ( 0.3 ) Parameter Type Description opacity float Opacity from 0.0 to 1.0 . Predefined Colors \u00b6 Basic Colors \u00b6 Constant Value Description Color.RED \"red\" System red Color.BLUE \"blue\" System blue Color.GREEN \"green\" System green Color.YELLOW \"yellow\" System yellow Color.ORANGE \"orange\" System orange Color.PINK \"pink\" System pink Color.PURPLE \"purple\" System purple Color.CYAN \"cyan\" System cyan Color.WHITE \"white\" White Color.BLACK \"black\" Black Color.GRAY \"gray\" System gray Color.CLEAR \"clear\" Fully transparent Extended Colors \u00b6 Constant Value Description Color.INDIGO \"indigo\" System indigo Color.MINT \"mint\" System mint Color.TEAL \"teal\" System teal Color.BROWN \"brown\" System brown Semantic Colors \u00b6 Constant Value Description Color.PRIMARY \"primary\" Primary label color (adapts to light/dark mode) Color.SECONDARY \"secondary\" Secondary label color (adapts to light/dark mode) Color.ACCENT \"accentColor\" System accent color String Shortcuts \u00b6 Anywhere a Color is accepted, you can also pass a plain string. Nib resolves named color strings and hex strings automatically. # These are equivalent: nib . Text ( \"Hello\" , foreground_color = nib . Color . RED ) nib . Text ( \"Hello\" , foreground_color = \"red\" ) # Hex strings work too: nib . Text ( \"Hello\" , foreground_color = \"#FF5733\" ) nib . Rectangle ( fill = \"#262626\" , stroke = \"#383837\" ) Examples \u00b6 Combining colors with opacity \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Solid\" , foreground_color = nib . Color . BLUE ), nib . Text ( \"Faded\" , foreground_color = nib . Color . BLUE . with_opacity ( 0.4 )), nib . Rectangle ( fill = nib . Color . rgba ( 255 , 100 , 50 , 0.6 ), width = 100 , height = 50 , ), ], spacing = 8 , ) ) nib . run ( main ) Using hex colors for custom themes \u00b6 import nib DARK_BG = nib . Color ( hex = \"#1E1E2E\" ) SURFACE = nib . Color ( hex = \"#313244\" ) TEXT_PRIMARY = nib . Color ( hex = \"#CDD6F4\" ) ACCENT = nib . Color ( hex = \"#89B4FA\" ) def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Dashboard\" , font = nib . Font . TITLE , foreground_color = TEXT_PRIMARY ), nib . Text ( \"Welcome back\" , foreground_color = ACCENT ), ], spacing = 12 , padding = 20 , background = DARK_BG , ) ) nib . run ( main )","title":"Color"},{"location":"reference/types/color/#constructor","text":"Color ( value = None , * , hex = None , opacity = None ) Parameter Type Default Description value str None Named color string (e.g., \"red\" , \"blue\" ). Used internally by predefined constants. hex str None Hex color string. Accepts \"#4287f5\" or \"4287f5\" (the # prefix is added automatically). Supports ARGB alpha channel: \"#7fff6666\" . opacity float None Opacity from 0.0 (fully transparent) to 1.0 (fully opaque). Either value or hex must be provided. A ValueError is raised if neither is given.","title":"Constructor"},{"location":"reference/types/color/#class-methods","text":"","title":"Class Methods"},{"location":"reference/types/color/#colorhexhex_value","text":"Create a color from a hex string. color = nib . Color . hex ( \"#4287f5\" ) Parameter Type Description hex_value str Hex color string, with or without # prefix.","title":"Color.hex(hex_value)"},{"location":"reference/types/color/#colorrgbr-g-b","text":"Create a color from RGB values in the 0--255 range. color = nib . Color . rgb ( 66 , 135 , 245 ) Parameter Type Description r int Red component (0--255). g int Green component (0--255). b int Blue component (0--255).","title":"Color.rgb(r, g, b)"},{"location":"reference/types/color/#colorrgbar-g-b-a","text":"Create a color from RGBA values. RGB components are 0--255, alpha is 0.0--1.0. color = nib . Color . rgba ( 66 , 135 , 245 , 0.8 ) Parameter Type Description r int Red component (0--255). g int Green component (0--255). b int Blue component (0--255). a float Alpha/opacity (0.0--1.0).","title":"Color.rgba(r, g, b, a)"},{"location":"reference/types/color/#instance-methods","text":"","title":"Instance Methods"},{"location":"reference/types/color/#colorwith_opacityopacity","text":"Return a new Color with the specified opacity. The original color is not modified. faded_blue = nib . Color . BLUE . with_opacity ( 0.5 ) custom = nib . Color ( hex = \"#FF5733\" ) . with_opacity ( 0.3 ) Parameter Type Description opacity float Opacity from 0.0 to 1.0 .","title":"color.with_opacity(opacity)"},{"location":"reference/types/color/#predefined-colors","text":"","title":"Predefined Colors"},{"location":"reference/types/color/#basic-colors","text":"Constant Value Description Color.RED \"red\" System red Color.BLUE \"blue\" System blue Color.GREEN \"green\" System green Color.YELLOW \"yellow\" System yellow Color.ORANGE \"orange\" System orange Color.PINK \"pink\" System pink Color.PURPLE \"purple\" System purple Color.CYAN \"cyan\" System cyan Color.WHITE \"white\" White Color.BLACK \"black\" Black Color.GRAY \"gray\" System gray Color.CLEAR \"clear\" Fully transparent","title":"Basic Colors"},{"location":"reference/types/color/#extended-colors","text":"Constant Value Description Color.INDIGO \"indigo\" System indigo Color.MINT \"mint\" System mint Color.TEAL \"teal\" System teal Color.BROWN \"brown\" System brown","title":"Extended Colors"},{"location":"reference/types/color/#semantic-colors","text":"Constant Value Description Color.PRIMARY \"primary\" Primary label color (adapts to light/dark mode) Color.SECONDARY \"secondary\" Secondary label color (adapts to light/dark mode) Color.ACCENT \"accentColor\" System accent color","title":"Semantic Colors"},{"location":"reference/types/color/#string-shortcuts","text":"Anywhere a Color is accepted, you can also pass a plain string. Nib resolves named color strings and hex strings automatically. # These are equivalent: nib . Text ( \"Hello\" , foreground_color = nib . Color . RED ) nib . Text ( \"Hello\" , foreground_color = \"red\" ) # Hex strings work too: nib . Text ( \"Hello\" , foreground_color = \"#FF5733\" ) nib . Rectangle ( fill = \"#262626\" , stroke = \"#383837\" )","title":"String Shortcuts"},{"location":"reference/types/color/#examples","text":"","title":"Examples"},{"location":"reference/types/color/#combining-colors-with-opacity","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Solid\" , foreground_color = nib . Color . BLUE ), nib . Text ( \"Faded\" , foreground_color = nib . Color . BLUE . with_opacity ( 0.4 )), nib . Rectangle ( fill = nib . Color . rgba ( 255 , 100 , 50 , 0.6 ), width = 100 , height = 50 , ), ], spacing = 8 , ) ) nib . run ( main )","title":"Combining colors with opacity"},{"location":"reference/types/color/#using-hex-colors-for-custom-themes","text":"import nib DARK_BG = nib . Color ( hex = \"#1E1E2E\" ) SURFACE = nib . Color ( hex = \"#313244\" ) TEXT_PRIMARY = nib . Color ( hex = \"#CDD6F4\" ) ACCENT = nib . Color ( hex = \"#89B4FA\" ) def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Dashboard\" , font = nib . Font . TITLE , foreground_color = TEXT_PRIMARY ), nib . Text ( \"Welcome back\" , foreground_color = ACCENT ), ], spacing = 12 , padding = 20 , background = DARK_BG , ) ) nib . run ( main )","title":"Using hex colors for custom themes"},{"location":"reference/types/font/","text":"The Font dataclass configures typography for text views. It supports system semantic fonts, custom font sizes, custom font families, and font file loading. import nib # System semantic font title = nib . Text ( \"Welcome\" , font = nib . Font . TITLE ) # Custom size with weight label = nib . Text ( \"Label\" , font = nib . Font . system ( 14 , nib . FontWeight . MEDIUM )) # Custom font family from file code = nib . Text ( \"code\" , font = nib . Font . custom ( \"Iosevka\" , 13 , path = \"fonts/Iosevka.ttf\" )) System Fonts \u00b6 System fonts use Apple's semantic sizing, which adapts to accessibility and platform settings. Constant Description Font.LARGE_TITLE Large title text (largest semantic size) Font.TITLE Title text Font.TITLE2 Secondary title text Font.TITLE3 Tertiary title text Font.HEADLINE Headline text (semibold by default) Font.SUBHEADLINE Subheadline text Font.BODY Body text (default reading size) Font.CALLOUT Callout text (slightly smaller than body) Font.FOOTNOTE Footnote text Font.CAPTION Caption text Font.CAPTION2 Secondary caption text (smallest semantic size) nib . Text ( \"Title\" , font = nib . Font . TITLE ) nib . Text ( \"Body text\" , font = nib . Font . BODY ) nib . Text ( \"Fine print\" , font = nib . Font . CAPTION ) Factory Methods \u00b6 Font.system(size, weight=None) \u00b6 Create a system font with a specific point size and optional weight. font = nib . Font . system ( 18 ) font = nib . Font . system ( 16 , nib . FontWeight . BOLD ) font = nib . Font . system ( 14 , \"semibold\" ) Parameter Type Default Description size float -- Font size in points. weight FontWeight \\| str None Optional font weight. Font.custom(name, size, weight=None, path=None) \u00b6 Create a custom font by family name. Optionally provide a path to a .ttf or .otf file for runtime font loading. # System-installed font font = nib . Font . custom ( \"Helvetica Neue\" , 16 ) # Font from a bundled file font = nib . Font . custom ( \"Inter\" , 14 , weight = nib . FontWeight . MEDIUM , path = \"fonts/Inter.ttf\" ) Parameter Type Default Description name str -- Font family name (e.g., \"Inter\" , \"Roboto\" ). size float -- Font size in points. weight FontWeight \\| str None Optional font weight. path str None Path to .ttf or .otf file for runtime loading. FontWeight \u00b6 The FontWeight enum specifies text thickness. It can be used with Font.system() , Font.custom() , or the font_weight view modifier parameter. Value SwiftUI Equivalent Description FontWeight.ULTRA_LIGHT .ultraLight Thinnest weight FontWeight.THIN .thin Very thin FontWeight.LIGHT .light Light weight FontWeight.REGULAR .regular Standard weight (default) FontWeight.MEDIUM .medium Medium weight FontWeight.SEMIBOLD .semibold Semi-bold weight FontWeight.BOLD .bold Bold weight FontWeight.HEAVY .heavy Heavy weight FontWeight.BLACK .black Heaviest weight nib . Text ( \"Light\" , font_weight = nib . FontWeight . LIGHT ) nib . Text ( \"Bold\" , font_weight = nib . FontWeight . BOLD ) nib . Text ( \"Heavy\" , font = nib . Font . system ( 20 , nib . FontWeight . HEAVY )) String Shortcut \u00b6 When a string is passed to the font parameter, it is treated as a font family name. # These are equivalent: nib . Text ( \"Hello\" , font = nib . Font . custom ( \"Helvetica Neue\" , 16 )) nib . Text ( \"Hello\" , font = \"Helvetica Neue\" ) Note that the string shortcut does not allow specifying a size -- the system default size is used. Use Font.custom() when you need to control the size. Examples \u00b6 Combining font and weight \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Large Title\" , font = nib . Font . LARGE_TITLE ), nib . Text ( \"Bold Headline\" , font = nib . Font . HEADLINE , font_weight = nib . FontWeight . BOLD ), nib . Text ( \"Custom Size\" , font = nib . Font . system ( 22 , nib . FontWeight . SEMIBOLD )), nib . Text ( \"Caption\" , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Loading a custom font file \u00b6 import nib mono_font = nib . Font . custom ( \"JetBrains Mono\" , 13 , path = \"fonts/JetBrainsMono-Regular.ttf\" ) def main ( app : nib . App ): app . build ( nib . Text ( \"fn main() { println!( \\\" Hello \\\" ); }\" , font = mono_font ) ) nib . run ( main )","title":"Font"},{"location":"reference/types/font/#system-fonts","text":"System fonts use Apple's semantic sizing, which adapts to accessibility and platform settings. Constant Description Font.LARGE_TITLE Large title text (largest semantic size) Font.TITLE Title text Font.TITLE2 Secondary title text Font.TITLE3 Tertiary title text Font.HEADLINE Headline text (semibold by default) Font.SUBHEADLINE Subheadline text Font.BODY Body text (default reading size) Font.CALLOUT Callout text (slightly smaller than body) Font.FOOTNOTE Footnote text Font.CAPTION Caption text Font.CAPTION2 Secondary caption text (smallest semantic size) nib . Text ( \"Title\" , font = nib . Font . TITLE ) nib . Text ( \"Body text\" , font = nib . Font . BODY ) nib . Text ( \"Fine print\" , font = nib . Font . CAPTION )","title":"System Fonts"},{"location":"reference/types/font/#factory-methods","text":"","title":"Factory Methods"},{"location":"reference/types/font/#fontsystemsize-weightnone","text":"Create a system font with a specific point size and optional weight. font = nib . Font . system ( 18 ) font = nib . Font . system ( 16 , nib . FontWeight . BOLD ) font = nib . Font . system ( 14 , \"semibold\" ) Parameter Type Default Description size float -- Font size in points. weight FontWeight \\| str None Optional font weight.","title":"Font.system(size, weight=None)"},{"location":"reference/types/font/#fontcustomname-size-weightnone-pathnone","text":"Create a custom font by family name. Optionally provide a path to a .ttf or .otf file for runtime font loading. # System-installed font font = nib . Font . custom ( \"Helvetica Neue\" , 16 ) # Font from a bundled file font = nib . Font . custom ( \"Inter\" , 14 , weight = nib . FontWeight . MEDIUM , path = \"fonts/Inter.ttf\" ) Parameter Type Default Description name str -- Font family name (e.g., \"Inter\" , \"Roboto\" ). size float -- Font size in points. weight FontWeight \\| str None Optional font weight. path str None Path to .ttf or .otf file for runtime loading.","title":"Font.custom(name, size, weight=None, path=None)"},{"location":"reference/types/font/#fontweight","text":"The FontWeight enum specifies text thickness. It can be used with Font.system() , Font.custom() , or the font_weight view modifier parameter. Value SwiftUI Equivalent Description FontWeight.ULTRA_LIGHT .ultraLight Thinnest weight FontWeight.THIN .thin Very thin FontWeight.LIGHT .light Light weight FontWeight.REGULAR .regular Standard weight (default) FontWeight.MEDIUM .medium Medium weight FontWeight.SEMIBOLD .semibold Semi-bold weight FontWeight.BOLD .bold Bold weight FontWeight.HEAVY .heavy Heavy weight FontWeight.BLACK .black Heaviest weight nib . Text ( \"Light\" , font_weight = nib . FontWeight . LIGHT ) nib . Text ( \"Bold\" , font_weight = nib . FontWeight . BOLD ) nib . Text ( \"Heavy\" , font = nib . Font . system ( 20 , nib . FontWeight . HEAVY ))","title":"FontWeight"},{"location":"reference/types/font/#string-shortcut","text":"When a string is passed to the font parameter, it is treated as a font family name. # These are equivalent: nib . Text ( \"Hello\" , font = nib . Font . custom ( \"Helvetica Neue\" , 16 )) nib . Text ( \"Hello\" , font = \"Helvetica Neue\" ) Note that the string shortcut does not allow specifying a size -- the system default size is used. Use Font.custom() when you need to control the size.","title":"String Shortcut"},{"location":"reference/types/font/#examples","text":"","title":"Examples"},{"location":"reference/types/font/#combining-font-and-weight","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Large Title\" , font = nib . Font . LARGE_TITLE ), nib . Text ( \"Bold Headline\" , font = nib . Font . HEADLINE , font_weight = nib . FontWeight . BOLD ), nib . Text ( \"Custom Size\" , font = nib . Font . system ( 22 , nib . FontWeight . SEMIBOLD )), nib . Text ( \"Caption\" , font = nib . Font . CAPTION , foreground_color = nib . Color . SECONDARY ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Combining font and weight"},{"location":"reference/types/font/#loading-a-custom-font-file","text":"import nib mono_font = nib . Font . custom ( \"JetBrains Mono\" , 13 , path = \"fonts/JetBrainsMono-Regular.ttf\" ) def main ( app : nib . App ): app . build ( nib . Text ( \"fn main() { println!( \\\" Hello \\\" ); }\" , font = mono_font ) ) nib . run ( main )","title":"Loading a custom font file"},{"location":"reference/types/geometry/","text":"Nib provides two geometry dataclasses for positioning views and controlling corner rounding. Offset \u00b6 The Offset dataclass shifts a view from its natural position by the specified x and y amounts. The view still occupies its original space in the layout but is rendered at the offset position. Constructor \u00b6 Offset ( x = 0 , y = 0 ) Parameter Type Default Description x float 0 Horizontal offset in points. Positive values move right. y float 0 Vertical offset in points. Positive values move down. Usage \u00b6 Pass an Offset to the offset modifier parameter on any view. import nib # Shift a view 10 points right and 20 points down nib . Circle ( fill = nib . Color . BLUE , width = 50 , height = 50 , offset = nib . Offset ( 10 , 20 ), ) Example: Overlapping circles in a ZStack \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Circle ( fill = nib . Color . RED , width = 60 , height = 60 ), nib . Circle ( fill = nib . Color . BLUE . with_opacity ( 0.7 ), width = 60 , height = 60 , offset = nib . Offset ( 25 , 0 ), ), nib . Circle ( fill = nib . Color . GREEN . with_opacity ( 0.7 ), width = 60 , height = 60 , offset = nib . Offset ( 12 , 22 ), ), ], padding = 40 , ) ) nib . run ( main ) CornerRadius \u00b6 The CornerRadius dataclass configures different radii for each corner of a rectangle. It is used with shape views like Rectangle , as well as the corner_radius modifier on any view. Constructor \u00b6 CornerRadius ( top_left = 0 , top_right = 0 , bottom_left = 0 , bottom_right = 0 ) Parameter Type Default Description top_left float 0 Radius of the top-left corner in points. top_right float 0 Radius of the top-right corner in points. bottom_left float 0 Radius of the bottom-left corner in points. bottom_right float 0 Radius of the bottom-right corner in points. Factory Methods \u00b6 CornerRadius.all(radius) \u00b6 Create a CornerRadius where all four corners have the same radius. cr = nib . CornerRadius . all ( 10 ) Parameter Type Description radius float Radius to apply to all corners. CornerRadius.only(top_left=0, top_right=0, bottom_left=0, bottom_right=0) \u00b6 Create a CornerRadius with only the specified corners rounded. Unspecified corners default to zero. cr = nib . CornerRadius . only ( top_left = 20 , top_right = 20 ) Parameter Type Default Description top_left float 0 Top-left corner radius. top_right float 0 Top-right corner radius. bottom_left float 0 Bottom-left corner radius. bottom_right float 0 Bottom-right corner radius. CornerRadius.horizontal(left=0, right=0) \u00b6 Create a horizontally symmetric CornerRadius . The left side corners share one radius and the right side corners share another. cr = nib . CornerRadius . horizontal ( left = 10 , right = 20 ) Parameter Type Default Description left float 0 Radius for top_left and bottom_left . right float 0 Radius for top_right and bottom_right . CornerRadius.vertical(top=0, bottom=0) \u00b6 Create a vertically symmetric CornerRadius . The top corners share one radius and the bottom corners share another. cr = nib . CornerRadius . vertical ( top = 15 , bottom = 0 ) Parameter Type Default Description top float 0 Radius for top_left and top_right . bottom float 0 Radius for bottom_left and bottom_right . Instance Methods \u00b6 .copy(top_left=None, top_right=None, bottom_left=None, bottom_right=None) \u00b6 Return a new CornerRadius with specified properties overridden. Unspecified values keep their current value. base = nib . CornerRadius . all ( 10 ) modified = base . copy ( bottom_left = 0 , bottom_right = 0 ) # Result: top_left=10, top_right=10, bottom_left=0, bottom_right=0 .is_uniform() \u00b6 Check if all corners have the same radius. Returns True if all four values are equal. nib . CornerRadius . all ( 10 ) . is_uniform () # True nib . CornerRadius . only ( top_left = 10 ) . is_uniform () # False Examples \u00b6 Card with rounded top corners only \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Card Header\" , font = nib . Font . HEADLINE , padding = 12 ), nib . Divider (), nib . Text ( \"Card body content goes here.\" , padding = 12 ), ], background = nib . Rectangle ( corner_radius = nib . CornerRadius . vertical ( top = 12 , bottom = 0 ), fill = \"#2A2A2A\" , ), width = 280 , ) ) nib . run ( main ) Asymmetric tab shape \u00b6 import nib tab_shape = nib . CornerRadius . only ( top_left = 12 , top_right = 12 ) nib . Rectangle ( corner_radius = tab_shape , fill = nib . Color . ACCENT , width = 100 , height = 36 , )","title":"Offset & CornerRadius"},{"location":"reference/types/geometry/#offset","text":"The Offset dataclass shifts a view from its natural position by the specified x and y amounts. The view still occupies its original space in the layout but is rendered at the offset position.","title":"Offset"},{"location":"reference/types/geometry/#constructor","text":"Offset ( x = 0 , y = 0 ) Parameter Type Default Description x float 0 Horizontal offset in points. Positive values move right. y float 0 Vertical offset in points. Positive values move down.","title":"Constructor"},{"location":"reference/types/geometry/#usage","text":"Pass an Offset to the offset modifier parameter on any view. import nib # Shift a view 10 points right and 20 points down nib . Circle ( fill = nib . Color . BLUE , width = 50 , height = 50 , offset = nib . Offset ( 10 , 20 ), )","title":"Usage"},{"location":"reference/types/geometry/#example-overlapping-circles-in-a-zstack","text":"import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Circle ( fill = nib . Color . RED , width = 60 , height = 60 ), nib . Circle ( fill = nib . Color . BLUE . with_opacity ( 0.7 ), width = 60 , height = 60 , offset = nib . Offset ( 25 , 0 ), ), nib . Circle ( fill = nib . Color . GREEN . with_opacity ( 0.7 ), width = 60 , height = 60 , offset = nib . Offset ( 12 , 22 ), ), ], padding = 40 , ) ) nib . run ( main )","title":"Example: Overlapping circles in a ZStack"},{"location":"reference/types/geometry/#cornerradius","text":"The CornerRadius dataclass configures different radii for each corner of a rectangle. It is used with shape views like Rectangle , as well as the corner_radius modifier on any view.","title":"CornerRadius"},{"location":"reference/types/geometry/#constructor_1","text":"CornerRadius ( top_left = 0 , top_right = 0 , bottom_left = 0 , bottom_right = 0 ) Parameter Type Default Description top_left float 0 Radius of the top-left corner in points. top_right float 0 Radius of the top-right corner in points. bottom_left float 0 Radius of the bottom-left corner in points. bottom_right float 0 Radius of the bottom-right corner in points.","title":"Constructor"},{"location":"reference/types/geometry/#factory-methods","text":"","title":"Factory Methods"},{"location":"reference/types/geometry/#cornerradiusallradius","text":"Create a CornerRadius where all four corners have the same radius. cr = nib . CornerRadius . all ( 10 ) Parameter Type Description radius float Radius to apply to all corners.","title":"CornerRadius.all(radius)"},{"location":"reference/types/geometry/#cornerradiusonlytop_left0-top_right0-bottom_left0-bottom_right0","text":"Create a CornerRadius with only the specified corners rounded. Unspecified corners default to zero. cr = nib . CornerRadius . only ( top_left = 20 , top_right = 20 ) Parameter Type Default Description top_left float 0 Top-left corner radius. top_right float 0 Top-right corner radius. bottom_left float 0 Bottom-left corner radius. bottom_right float 0 Bottom-right corner radius.","title":"CornerRadius.only(top_left=0, top_right=0, bottom_left=0, bottom_right=0)"},{"location":"reference/types/geometry/#cornerradiushorizontalleft0-right0","text":"Create a horizontally symmetric CornerRadius . The left side corners share one radius and the right side corners share another. cr = nib . CornerRadius . horizontal ( left = 10 , right = 20 ) Parameter Type Default Description left float 0 Radius for top_left and bottom_left . right float 0 Radius for top_right and bottom_right .","title":"CornerRadius.horizontal(left=0, right=0)"},{"location":"reference/types/geometry/#cornerradiusverticaltop0-bottom0","text":"Create a vertically symmetric CornerRadius . The top corners share one radius and the bottom corners share another. cr = nib . CornerRadius . vertical ( top = 15 , bottom = 0 ) Parameter Type Default Description top float 0 Radius for top_left and top_right . bottom float 0 Radius for bottom_left and bottom_right .","title":"CornerRadius.vertical(top=0, bottom=0)"},{"location":"reference/types/geometry/#instance-methods","text":"","title":"Instance Methods"},{"location":"reference/types/geometry/#copytop_leftnone-top_rightnone-bottom_leftnone-bottom_rightnone","text":"Return a new CornerRadius with specified properties overridden. Unspecified values keep their current value. base = nib . CornerRadius . all ( 10 ) modified = base . copy ( bottom_left = 0 , bottom_right = 0 ) # Result: top_left=10, top_right=10, bottom_left=0, bottom_right=0","title":".copy(top_left=None, top_right=None, bottom_left=None, bottom_right=None)"},{"location":"reference/types/geometry/#is_uniform","text":"Check if all corners have the same radius. Returns True if all four values are equal. nib . CornerRadius . all ( 10 ) . is_uniform () # True nib . CornerRadius . only ( top_left = 10 ) . is_uniform () # False","title":".is_uniform()"},{"location":"reference/types/geometry/#examples","text":"","title":"Examples"},{"location":"reference/types/geometry/#card-with-rounded-top-corners-only","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Card Header\" , font = nib . Font . HEADLINE , padding = 12 ), nib . Divider (), nib . Text ( \"Card body content goes here.\" , padding = 12 ), ], background = nib . Rectangle ( corner_radius = nib . CornerRadius . vertical ( top = 12 , bottom = 0 ), fill = \"#2A2A2A\" , ), width = 280 , ) ) nib . run ( main )","title":"Card with rounded top corners only"},{"location":"reference/types/geometry/#asymmetric-tab-shape","text":"import nib tab_shape = nib . CornerRadius . only ( top_left = 12 , top_right = 12 ) nib . Rectangle ( corner_radius = tab_shape , fill = nib . Color . ACCENT , width = 100 , height = 36 , )","title":"Asymmetric tab shape"},{"location":"reference/types/image-enums/","text":"Nib provides several enums that control how images, SF Symbols, and text content are displayed. ImageRenderingMode \u00b6 Controls how an Image view renders its content. Value SwiftUI Equivalent Description ImageRenderingMode.ORIGINAL .original Render the image with its original colors. ImageRenderingMode.TEMPLATE .template Render the image as a template, using the foreground color. import nib # Original colors preserved nib . Image ( source = \"photo.png\" , rendering_mode = nib . ImageRenderingMode . ORIGINAL ) # Tinted with foreground color nib . Image ( source = \"icon.png\" , rendering_mode = nib . ImageRenderingMode . TEMPLATE , foreground_color = nib . Color . BLUE , ) SymbolScale \u00b6 Controls the scale of SF Symbols relative to surrounding text. Value SwiftUI Equivalent Description SymbolScale.SMALL .small Smaller than surrounding text. SymbolScale.MEDIUM .medium Matches surrounding text size (default). SymbolScale.LARGE .large Larger than surrounding text. import nib nib . Image ( system_name = \"star.fill\" , symbol_scale = nib . SymbolScale . LARGE , foreground_color = nib . Color . YELLOW , ) SymbolRenderingMode \u00b6 Controls how SF Symbols render their colors. Value SwiftUI Equivalent Description SymbolRenderingMode.MONOCHROME .monochrome Single color using the foreground color. SymbolRenderingMode.HIERARCHICAL .hierarchical Multiple layers with varying opacity of the foreground color. SymbolRenderingMode.PALETTE .palette Custom colors for each layer. SymbolRenderingMode.MULTICOLOR .multicolor System-defined multicolor rendering. import nib # Hierarchical rendering (depth through opacity) nib . Image ( system_name = \"cloud.sun.rain.fill\" , symbol_rendering_mode = nib . SymbolRenderingMode . HIERARCHICAL , foreground_color = nib . Color . BLUE , ) # Multicolor rendering (system colors) nib . Image ( system_name = \"cloud.sun.rain.fill\" , symbol_rendering_mode = nib . SymbolRenderingMode . MULTICOLOR , ) ContentMode \u00b6 Controls how an image is scaled to fit its frame. Used with the content_mode parameter on Image views. Value SwiftUI Equivalent Description ContentMode.FIT .fit Scale to fit within bounds while maintaining aspect ratio. The entire image is visible. ContentMode.FILL .fill Scale to fill bounds while maintaining aspect ratio. Parts of the image may be clipped. import nib # Fit within frame (may have empty space) nib . Image ( source = \"photo.png\" , content_mode = nib . ContentMode . FIT , width = 200 , height = 150 ) # Fill frame (may clip edges) nib . Image ( source = \"photo.png\" , content_mode = nib . ContentMode . FILL , width = 200 , height = 150 , clip_shape = \"circle\" , ) TruncationMode \u00b6 Controls where text is truncated when it exceeds the available space. Value SwiftUI Equivalent Description TruncationMode.HEAD .head Truncate at the beginning: \"...end of text\" . TruncationMode.MIDDLE .middle Truncate in the middle: \"start...end\" . TruncationMode.TAIL .tail Truncate at the end: \"start of text...\" (default). import nib nib . Text ( \"This is a very long text that will be truncated\" , truncation_mode = nib . TruncationMode . MIDDLE , line_limit = 1 , ) TextCase \u00b6 Transforms the case of displayed text without modifying the underlying value. Value SwiftUI Equivalent Description TextCase.UPPERCASE .uppercase Display text in all uppercase letters. TextCase.LOWERCASE .lowercase Display text in all lowercase letters. import nib nib . Text ( \"section header\" , text_case = nib . TextCase . UPPERCASE ) # Displays: \"SECTION HEADER\" Examples \u00b6 Avatar image with circular clipping \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Image ( source = \"avatar.jpg\" , content_mode = nib . ContentMode . FILL , width = 80 , height = 80 , clip_shape = \"circle\" , ), nib . Text ( \"Jane Doe\" , font = nib . Font . HEADLINE ), nib . Text ( \"Online\" , font = nib . Font . CAPTION , foreground_color = nib . Color . GREEN ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) SF Symbol with different rendering modes \u00b6 import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Image ( system_name = \"heart.fill\" , symbol_rendering_mode = nib . SymbolRenderingMode . MONOCHROME , foreground_color = nib . Color . RED , symbol_scale = nib . SymbolScale . LARGE , ), nib . Image ( system_name = \"heart.fill\" , symbol_rendering_mode = nib . SymbolRenderingMode . HIERARCHICAL , foreground_color = nib . Color . PINK , symbol_scale = nib . SymbolScale . LARGE , ), nib . Image ( system_name = \"heart.fill\" , symbol_rendering_mode = nib . SymbolRenderingMode . MULTICOLOR , symbol_scale = nib . SymbolScale . LARGE , ), ], spacing = 20 , padding = 16 , ) ) nib . run ( main )","title":"Image Enums"},{"location":"reference/types/image-enums/#imagerenderingmode","text":"Controls how an Image view renders its content. Value SwiftUI Equivalent Description ImageRenderingMode.ORIGINAL .original Render the image with its original colors. ImageRenderingMode.TEMPLATE .template Render the image as a template, using the foreground color. import nib # Original colors preserved nib . Image ( source = \"photo.png\" , rendering_mode = nib . ImageRenderingMode . ORIGINAL ) # Tinted with foreground color nib . Image ( source = \"icon.png\" , rendering_mode = nib . ImageRenderingMode . TEMPLATE , foreground_color = nib . Color . BLUE , )","title":"ImageRenderingMode"},{"location":"reference/types/image-enums/#symbolscale","text":"Controls the scale of SF Symbols relative to surrounding text. Value SwiftUI Equivalent Description SymbolScale.SMALL .small Smaller than surrounding text. SymbolScale.MEDIUM .medium Matches surrounding text size (default). SymbolScale.LARGE .large Larger than surrounding text. import nib nib . Image ( system_name = \"star.fill\" , symbol_scale = nib . SymbolScale . LARGE , foreground_color = nib . Color . YELLOW , )","title":"SymbolScale"},{"location":"reference/types/image-enums/#symbolrenderingmode","text":"Controls how SF Symbols render their colors. Value SwiftUI Equivalent Description SymbolRenderingMode.MONOCHROME .monochrome Single color using the foreground color. SymbolRenderingMode.HIERARCHICAL .hierarchical Multiple layers with varying opacity of the foreground color. SymbolRenderingMode.PALETTE .palette Custom colors for each layer. SymbolRenderingMode.MULTICOLOR .multicolor System-defined multicolor rendering. import nib # Hierarchical rendering (depth through opacity) nib . Image ( system_name = \"cloud.sun.rain.fill\" , symbol_rendering_mode = nib . SymbolRenderingMode . HIERARCHICAL , foreground_color = nib . Color . BLUE , ) # Multicolor rendering (system colors) nib . Image ( system_name = \"cloud.sun.rain.fill\" , symbol_rendering_mode = nib . SymbolRenderingMode . MULTICOLOR , )","title":"SymbolRenderingMode"},{"location":"reference/types/image-enums/#contentmode","text":"Controls how an image is scaled to fit its frame. Used with the content_mode parameter on Image views. Value SwiftUI Equivalent Description ContentMode.FIT .fit Scale to fit within bounds while maintaining aspect ratio. The entire image is visible. ContentMode.FILL .fill Scale to fill bounds while maintaining aspect ratio. Parts of the image may be clipped. import nib # Fit within frame (may have empty space) nib . Image ( source = \"photo.png\" , content_mode = nib . ContentMode . FIT , width = 200 , height = 150 ) # Fill frame (may clip edges) nib . Image ( source = \"photo.png\" , content_mode = nib . ContentMode . FILL , width = 200 , height = 150 , clip_shape = \"circle\" , )","title":"ContentMode"},{"location":"reference/types/image-enums/#truncationmode","text":"Controls where text is truncated when it exceeds the available space. Value SwiftUI Equivalent Description TruncationMode.HEAD .head Truncate at the beginning: \"...end of text\" . TruncationMode.MIDDLE .middle Truncate in the middle: \"start...end\" . TruncationMode.TAIL .tail Truncate at the end: \"start of text...\" (default). import nib nib . Text ( \"This is a very long text that will be truncated\" , truncation_mode = nib . TruncationMode . MIDDLE , line_limit = 1 , )","title":"TruncationMode"},{"location":"reference/types/image-enums/#textcase","text":"Transforms the case of displayed text without modifying the underlying value. Value SwiftUI Equivalent Description TextCase.UPPERCASE .uppercase Display text in all uppercase letters. TextCase.LOWERCASE .lowercase Display text in all lowercase letters. import nib nib . Text ( \"section header\" , text_case = nib . TextCase . UPPERCASE ) # Displays: \"SECTION HEADER\"","title":"TextCase"},{"location":"reference/types/image-enums/#examples","text":"","title":"Examples"},{"location":"reference/types/image-enums/#avatar-image-with-circular-clipping","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Image ( source = \"avatar.jpg\" , content_mode = nib . ContentMode . FILL , width = 80 , height = 80 , clip_shape = \"circle\" , ), nib . Text ( \"Jane Doe\" , font = nib . Font . HEADLINE ), nib . Text ( \"Online\" , font = nib . Font . CAPTION , foreground_color = nib . Color . GREEN ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Avatar image with circular clipping"},{"location":"reference/types/image-enums/#sf-symbol-with-different-rendering-modes","text":"import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Image ( system_name = \"heart.fill\" , symbol_rendering_mode = nib . SymbolRenderingMode . MONOCHROME , foreground_color = nib . Color . RED , symbol_scale = nib . SymbolScale . LARGE , ), nib . Image ( system_name = \"heart.fill\" , symbol_rendering_mode = nib . SymbolRenderingMode . HIERARCHICAL , foreground_color = nib . Color . PINK , symbol_scale = nib . SymbolScale . LARGE , ), nib . Image ( system_name = \"heart.fill\" , symbol_rendering_mode = nib . SymbolRenderingMode . MULTICOLOR , symbol_scale = nib . SymbolScale . LARGE , ), ], spacing = 20 , padding = 16 , ) ) nib . run ( main )","title":"SF Symbol with different rendering modes"},{"location":"reference/types/style-enums/","text":"Nib provides style enums that control the visual appearance of interactive controls. Each enum maps directly to a SwiftUI style protocol. All enums use UPPERCASE names (preferred). Lowercase aliases exist for backwards compatibility but are deprecated. ButtonStyle \u00b6 Controls the visual appearance of Button views. nib . Button ( \"Click\" , style = nib . ButtonStyle . BORDERED_PROMINENT ) Value SwiftUI Equivalent Description ButtonStyle.AUTOMATIC .automatic System default style. ButtonStyle.BORDERED .bordered Button with a visible border. ButtonStyle.BORDERED_PROMINENT .borderedProminent Bordered button with accent color fill. ButtonStyle.BORDERLESS .borderless No visible border (text only). ButtonStyle.PLAIN .plain Minimal styling with no visual effects. ButtonStyle.LINK .link Appears as a clickable link. nib . VStack ( controls = [ nib . Button ( \"Primary\" , action = do_save , style = nib . ButtonStyle . BORDERED_PROMINENT ), nib . Button ( \"Secondary\" , action = do_cancel , style = nib . ButtonStyle . BORDERED ), nib . Button ( \"Learn More\" , action = do_help , style = nib . ButtonStyle . LINK ), ]) ButtonRole \u00b6 Assigns a semantic role to a Button , which affects its appearance. Value SwiftUI Equivalent Description ButtonRole.DESTRUCTIVE .destructive Indicates a destructive action (typically red). ButtonRole.CANCEL .cancel Indicates a cancel action. nib . Button ( \"Delete\" , action = delete_item , role = nib . ButtonRole . DESTRUCTIVE ) BorderShape \u00b6 Controls the border shape of buttons and other controls. Value SwiftUI Equivalent Description BorderShape.AUTOMATIC .automatic System default shape. BorderShape.CAPSULE .capsule Pill-shaped border. BorderShape.ROUNDED_RECTANGLE .roundedRectangle Rounded rectangle border. BorderShape.CIRCLE .circle Circular border. ControlSize \u00b6 Controls the size of interactive controls. Value SwiftUI Equivalent Description ControlSize.MINI .mini Smallest size. ControlSize.SMALL .small Small size. ControlSize.REGULAR .regular Default size. ControlSize.LARGE .large Large size. ControlSize.EXTRA_LARGE .extraLarge Largest size. nib . Button ( \"Compact\" , action = do_action , control_size = nib . ControlSize . SMALL ) LabelStyle \u00b6 Controls how Label views display their title and icon. Value SwiftUI Equivalent Description LabelStyle.AUTOMATIC .automatic System default (shows both title and icon). LabelStyle.TITLE_ONLY .titleOnly Show only the text title. LabelStyle.ICON_ONLY .iconOnly Show only the icon. LabelStyle.TITLE_AND_ICON .titleAndIcon Show both title and icon. nib . Label ( \"Settings\" , icon = \"gear\" , style = nib . LabelStyle . TITLE_AND_ICON ) ToggleStyle \u00b6 Controls the visual appearance of Toggle views. Value SwiftUI Equivalent Description ToggleStyle.AUTOMATIC .automatic System default style. ToggleStyle.SWITCH .switch macOS-style toggle switch. ToggleStyle.BUTTON .button Toggle that looks like a button. ToggleStyle.CHECKBOX .checkbox Checkbox style (macOS native). nib . Toggle ( \"Dark Mode\" , is_on = True , style = nib . ToggleStyle . SWITCH ) nib . Toggle ( \"Enable Notifications\" , is_on = False , style = nib . ToggleStyle . CHECKBOX ) TextFieldStyle \u00b6 Controls the visual appearance of TextField views. Value SwiftUI Equivalent Description TextFieldStyle.AUTOMATIC .automatic System default style. TextFieldStyle.PLAIN .plain No border or background. TextFieldStyle.ROUNDED_BORDER .roundedBorder Rounded border with background. TextFieldStyle.SQUARE_BORDER .squareBorder Square border with background. nib . TextField ( \"Search...\" , text = \"\" , style = nib . TextFieldStyle . ROUNDED_BORDER ) EditorStyle \u00b6 Controls the visual appearance of TextEditor views (macOS 14+). Value SwiftUI Equivalent Description EditorStyle.AUTOMATIC .automatic System default style. EditorStyle.PLAIN .plain No border or background styling. nib . TextEditor ( text = \"\" , editor_style = nib . EditorStyle . PLAIN ) PickerStyle \u00b6 Controls the visual appearance of Picker views. Value SwiftUI Equivalent Description PickerStyle.AUTOMATIC .automatic System default style. PickerStyle.MENU .menu Dropdown menu (compact). PickerStyle.SEGMENTED .segmented Segmented control (horizontal tabs). PickerStyle.WHEEL .wheel Scrolling wheel picker. PickerStyle.INLINE .inline Inline list of options. nib . Picker ( \"Color\" , options = [ \"Red\" , \"Green\" , \"Blue\" ], selection = \"Red\" , style = nib . PickerStyle . SEGMENTED , ) ProgressStyle \u00b6 Controls the visual appearance of ProgressView views. Value SwiftUI Equivalent Description ProgressStyle.AUTOMATIC .automatic System default style. ProgressStyle.LINEAR .linear Horizontal progress bar. ProgressStyle.CIRCULAR .circular Spinning circle indicator. nib . ProgressView ( value = 0.65 , style = nib . ProgressStyle . LINEAR ) nib . ProgressView ( style = nib . ProgressStyle . CIRCULAR ) # Indeterminate spinner FormStyle \u00b6 Controls the visual layout of Form containers. Value SwiftUI Equivalent Description FormStyle.AUTOMATIC .automatic Platform default style. FormStyle.COLUMNS .columns Two-column layout with labels left and controls right (macOS default). FormStyle.GROUPED .grouped Grouped sections with visual separation. nib . Form ( controls = [ nib . TextField ( \"Name\" , text = \"\" ), nib . Toggle ( \"Notifications\" , is_on = True ), ], style = nib . FormStyle . GROUPED , )","title":"Style Enums"},{"location":"reference/types/style-enums/#buttonstyle","text":"Controls the visual appearance of Button views. nib . Button ( \"Click\" , style = nib . ButtonStyle . BORDERED_PROMINENT ) Value SwiftUI Equivalent Description ButtonStyle.AUTOMATIC .automatic System default style. ButtonStyle.BORDERED .bordered Button with a visible border. ButtonStyle.BORDERED_PROMINENT .borderedProminent Bordered button with accent color fill. ButtonStyle.BORDERLESS .borderless No visible border (text only). ButtonStyle.PLAIN .plain Minimal styling with no visual effects. ButtonStyle.LINK .link Appears as a clickable link. nib . VStack ( controls = [ nib . Button ( \"Primary\" , action = do_save , style = nib . ButtonStyle . BORDERED_PROMINENT ), nib . Button ( \"Secondary\" , action = do_cancel , style = nib . ButtonStyle . BORDERED ), nib . Button ( \"Learn More\" , action = do_help , style = nib . ButtonStyle . LINK ), ])","title":"ButtonStyle"},{"location":"reference/types/style-enums/#buttonrole","text":"Assigns a semantic role to a Button , which affects its appearance. Value SwiftUI Equivalent Description ButtonRole.DESTRUCTIVE .destructive Indicates a destructive action (typically red). ButtonRole.CANCEL .cancel Indicates a cancel action. nib . Button ( \"Delete\" , action = delete_item , role = nib . ButtonRole . DESTRUCTIVE )","title":"ButtonRole"},{"location":"reference/types/style-enums/#bordershape","text":"Controls the border shape of buttons and other controls. Value SwiftUI Equivalent Description BorderShape.AUTOMATIC .automatic System default shape. BorderShape.CAPSULE .capsule Pill-shaped border. BorderShape.ROUNDED_RECTANGLE .roundedRectangle Rounded rectangle border. BorderShape.CIRCLE .circle Circular border.","title":"BorderShape"},{"location":"reference/types/style-enums/#controlsize","text":"Controls the size of interactive controls. Value SwiftUI Equivalent Description ControlSize.MINI .mini Smallest size. ControlSize.SMALL .small Small size. ControlSize.REGULAR .regular Default size. ControlSize.LARGE .large Large size. ControlSize.EXTRA_LARGE .extraLarge Largest size. nib . Button ( \"Compact\" , action = do_action , control_size = nib . ControlSize . SMALL )","title":"ControlSize"},{"location":"reference/types/style-enums/#labelstyle","text":"Controls how Label views display their title and icon. Value SwiftUI Equivalent Description LabelStyle.AUTOMATIC .automatic System default (shows both title and icon). LabelStyle.TITLE_ONLY .titleOnly Show only the text title. LabelStyle.ICON_ONLY .iconOnly Show only the icon. LabelStyle.TITLE_AND_ICON .titleAndIcon Show both title and icon. nib . Label ( \"Settings\" , icon = \"gear\" , style = nib . LabelStyle . TITLE_AND_ICON )","title":"LabelStyle"},{"location":"reference/types/style-enums/#togglestyle","text":"Controls the visual appearance of Toggle views. Value SwiftUI Equivalent Description ToggleStyle.AUTOMATIC .automatic System default style. ToggleStyle.SWITCH .switch macOS-style toggle switch. ToggleStyle.BUTTON .button Toggle that looks like a button. ToggleStyle.CHECKBOX .checkbox Checkbox style (macOS native). nib . Toggle ( \"Dark Mode\" , is_on = True , style = nib . ToggleStyle . SWITCH ) nib . Toggle ( \"Enable Notifications\" , is_on = False , style = nib . ToggleStyle . CHECKBOX )","title":"ToggleStyle"},{"location":"reference/types/style-enums/#textfieldstyle","text":"Controls the visual appearance of TextField views. Value SwiftUI Equivalent Description TextFieldStyle.AUTOMATIC .automatic System default style. TextFieldStyle.PLAIN .plain No border or background. TextFieldStyle.ROUNDED_BORDER .roundedBorder Rounded border with background. TextFieldStyle.SQUARE_BORDER .squareBorder Square border with background. nib . TextField ( \"Search...\" , text = \"\" , style = nib . TextFieldStyle . ROUNDED_BORDER )","title":"TextFieldStyle"},{"location":"reference/types/style-enums/#editorstyle","text":"Controls the visual appearance of TextEditor views (macOS 14+). Value SwiftUI Equivalent Description EditorStyle.AUTOMATIC .automatic System default style. EditorStyle.PLAIN .plain No border or background styling. nib . TextEditor ( text = \"\" , editor_style = nib . EditorStyle . PLAIN )","title":"EditorStyle"},{"location":"reference/types/style-enums/#pickerstyle","text":"Controls the visual appearance of Picker views. Value SwiftUI Equivalent Description PickerStyle.AUTOMATIC .automatic System default style. PickerStyle.MENU .menu Dropdown menu (compact). PickerStyle.SEGMENTED .segmented Segmented control (horizontal tabs). PickerStyle.WHEEL .wheel Scrolling wheel picker. PickerStyle.INLINE .inline Inline list of options. nib . Picker ( \"Color\" , options = [ \"Red\" , \"Green\" , \"Blue\" ], selection = \"Red\" , style = nib . PickerStyle . SEGMENTED , )","title":"PickerStyle"},{"location":"reference/types/style-enums/#progressstyle","text":"Controls the visual appearance of ProgressView views. Value SwiftUI Equivalent Description ProgressStyle.AUTOMATIC .automatic System default style. ProgressStyle.LINEAR .linear Horizontal progress bar. ProgressStyle.CIRCULAR .circular Spinning circle indicator. nib . ProgressView ( value = 0.65 , style = nib . ProgressStyle . LINEAR ) nib . ProgressView ( style = nib . ProgressStyle . CIRCULAR ) # Indeterminate spinner","title":"ProgressStyle"},{"location":"reference/types/style-enums/#formstyle","text":"Controls the visual layout of Form containers. Value SwiftUI Equivalent Description FormStyle.AUTOMATIC .automatic Platform default style. FormStyle.COLUMNS .columns Two-column layout with labels left and controls right (macOS default). FormStyle.GROUPED .grouped Grouped sections with visual separation. nib . Form ( controls = [ nib . TextField ( \"Name\" , text = \"\" ), nib . Toggle ( \"Notifications\" , is_on = True ), ], style = nib . FormStyle . GROUPED , )","title":"FormStyle"},{"location":"reference/types/text-style/","text":"TextStyle is a dataclass that groups all text-related styling options into a single object. AttributedString allows creating rich text with different styles for different segments. import nib # TextStyle preset title = nib . Text ( \"Welcome\" , style = nib . TextStyle . TITLE ) # Custom TextStyle styled = nib . Text ( \"Custom\" , style = nib . TextStyle ( bold = True , underline = True , color = \"red\" )) # Rich text with AttributedString rich = nib . Text ( strings = [ nib . AttributedString ( \"Hello \" , style = nib . TextStyle ( color = \"blue\" )), nib . AttributedString ( \"World\" , style = nib . TextStyle ( bold = True )), ]) TextStyle \u00b6 The TextStyle dataclass combines font, decoration, and spacing properties into a single configuration object. Pass it to a Text view using the style parameter. Constructor \u00b6 TextStyle ( font = None , color = None , weight = None , bold = False , italic = False , strikethrough = False , strikethrough_color = None , underline = False , underline_color = None , monospaced = False , monospaced_digit = False , kerning = None , tracking = None , baseline_offset = None , ) Parameters \u00b6 Font Settings Parameter Type Default Description font Font None Font configuration (e.g., Font.BODY , Font.system(16) ). color str None Text color (hex string or named color). weight str None Font weight string (e.g., \"bold\" , \"medium\" ). Text Decorations Parameter Type Default Description bold bool False Apply bold formatting. italic bool False Apply italic formatting. strikethrough bool False Apply strikethrough decoration. strikethrough_color str None Color of the strikethrough line. underline bool False Apply underline decoration. underline_color str None Color of the underline. Font Variations Parameter Type Default Description monospaced bool False Use monospaced font variant. monospaced_digit bool False Use monospaced digits (useful for tabular numbers). Spacing Parameter Type Default Description kerning float None Spacing between character pairs in points. tracking float None Uniform spacing between all characters in points. baseline_offset float None Vertical offset from the text baseline in points. Presets \u00b6 TextStyle provides predefined presets that match the system semantic font styles: Preset Font Used TextStyle.LARGE_TITLE Font.LARGE_TITLE TextStyle.TITLE Font.TITLE TextStyle.TITLE2 Font.TITLE2 TextStyle.TITLE3 Font.TITLE3 TextStyle.HEADLINE Font.HEADLINE TextStyle.SUBHEADLINE Font.SUBHEADLINE TextStyle.BODY Font.BODY TextStyle.CALLOUT Font.CALLOUT TextStyle.CAPTION Font.CAPTION TextStyle.CAPTION2 Font.CAPTION2 TextStyle.FOOTNOTE Font.FOOTNOTE nib . Text ( \"Title\" , style = nib . TextStyle . TITLE ) nib . Text ( \"Body text\" , style = nib . TextStyle . BODY ) AttributedString \u00b6 The AttributedString dataclass represents a single styled segment of text. Use it with Text(strings=[...]) to create rich text with multiple styles. Constructor \u00b6 AttributedString ( content , style = None , color = None , font = None ) Parameter Type Default Description content str -- The text content for this segment. style TextStyle None Full text style configuration. color Color \\| str None Color override (takes precedence over style.color ). font Font None Font override (takes precedence over style.font ). When both style and direct overrides ( color , font ) are provided, the direct overrides take precedence. Examples \u00b6 Custom TextStyle with decorations \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Bold & Italic\" , style = nib . TextStyle ( bold = True , italic = True )), nib . Text ( \"Underlined\" , style = nib . TextStyle ( underline = True , underline_color = \"blue\" ), ), nib . Text ( \"Deleted\" , style = nib . TextStyle ( strikethrough = True , color = \"gray\" ), ), nib . Text ( \"W I D E\" , style = nib . TextStyle ( tracking = 4.0 , font = nib . Font . HEADLINE ), ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Rich text with AttributedString \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( strings = [ nib . AttributedString ( \"Warning: \" , style = nib . TextStyle ( bold = True , color = \"red\" ), ), nib . AttributedString ( \"This action cannot be undone.\" , style = nib . TextStyle . BODY , ), ]), nib . Text ( strings = [ nib . AttributedString ( \"Price: \" , font = nib . Font . BODY ), nib . AttributedString ( \"$9.99\" , style = nib . TextStyle ( font = nib . Font . system ( 20 ), bold = True , monospaced_digit = True , ), color = nib . Color . GREEN , ), ]), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Monospaced digits for tabular data \u00b6 import nib def main ( app : nib . App ): items = [( \"Apples\" , 12 ), ( \"Oranges\" , 8 ), ( \"Bananas\" , 145 )] mono_digit = nib . TextStyle ( monospaced_digit = True ) app . build ( nib . VStack ( controls = [ nib . HStack ( controls = [ nib . Text ( name , font = nib . Font . BODY ), nib . Spacer (), nib . Text ( str ( count ), style = mono_digit ), ], ) for name , count in items ], spacing = 4 , padding = 16 , ) ) nib . run ( main )","title":"TextStyle & AttributedString"},{"location":"reference/types/text-style/#textstyle","text":"The TextStyle dataclass combines font, decoration, and spacing properties into a single configuration object. Pass it to a Text view using the style parameter.","title":"TextStyle"},{"location":"reference/types/text-style/#constructor","text":"TextStyle ( font = None , color = None , weight = None , bold = False , italic = False , strikethrough = False , strikethrough_color = None , underline = False , underline_color = None , monospaced = False , monospaced_digit = False , kerning = None , tracking = None , baseline_offset = None , )","title":"Constructor"},{"location":"reference/types/text-style/#parameters","text":"Font Settings Parameter Type Default Description font Font None Font configuration (e.g., Font.BODY , Font.system(16) ). color str None Text color (hex string or named color). weight str None Font weight string (e.g., \"bold\" , \"medium\" ). Text Decorations Parameter Type Default Description bold bool False Apply bold formatting. italic bool False Apply italic formatting. strikethrough bool False Apply strikethrough decoration. strikethrough_color str None Color of the strikethrough line. underline bool False Apply underline decoration. underline_color str None Color of the underline. Font Variations Parameter Type Default Description monospaced bool False Use monospaced font variant. monospaced_digit bool False Use monospaced digits (useful for tabular numbers). Spacing Parameter Type Default Description kerning float None Spacing between character pairs in points. tracking float None Uniform spacing between all characters in points. baseline_offset float None Vertical offset from the text baseline in points.","title":"Parameters"},{"location":"reference/types/text-style/#presets","text":"TextStyle provides predefined presets that match the system semantic font styles: Preset Font Used TextStyle.LARGE_TITLE Font.LARGE_TITLE TextStyle.TITLE Font.TITLE TextStyle.TITLE2 Font.TITLE2 TextStyle.TITLE3 Font.TITLE3 TextStyle.HEADLINE Font.HEADLINE TextStyle.SUBHEADLINE Font.SUBHEADLINE TextStyle.BODY Font.BODY TextStyle.CALLOUT Font.CALLOUT TextStyle.CAPTION Font.CAPTION TextStyle.CAPTION2 Font.CAPTION2 TextStyle.FOOTNOTE Font.FOOTNOTE nib . Text ( \"Title\" , style = nib . TextStyle . TITLE ) nib . Text ( \"Body text\" , style = nib . TextStyle . BODY )","title":"Presets"},{"location":"reference/types/text-style/#attributedstring","text":"The AttributedString dataclass represents a single styled segment of text. Use it with Text(strings=[...]) to create rich text with multiple styles.","title":"AttributedString"},{"location":"reference/types/text-style/#constructor_1","text":"AttributedString ( content , style = None , color = None , font = None ) Parameter Type Default Description content str -- The text content for this segment. style TextStyle None Full text style configuration. color Color \\| str None Color override (takes precedence over style.color ). font Font None Font override (takes precedence over style.font ). When both style and direct overrides ( color , font ) are provided, the direct overrides take precedence.","title":"Constructor"},{"location":"reference/types/text-style/#examples","text":"","title":"Examples"},{"location":"reference/types/text-style/#custom-textstyle-with-decorations","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Bold & Italic\" , style = nib . TextStyle ( bold = True , italic = True )), nib . Text ( \"Underlined\" , style = nib . TextStyle ( underline = True , underline_color = \"blue\" ), ), nib . Text ( \"Deleted\" , style = nib . TextStyle ( strikethrough = True , color = \"gray\" ), ), nib . Text ( \"W I D E\" , style = nib . TextStyle ( tracking = 4.0 , font = nib . Font . HEADLINE ), ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Custom TextStyle with decorations"},{"location":"reference/types/text-style/#rich-text-with-attributedstring","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( strings = [ nib . AttributedString ( \"Warning: \" , style = nib . TextStyle ( bold = True , color = \"red\" ), ), nib . AttributedString ( \"This action cannot be undone.\" , style = nib . TextStyle . BODY , ), ]), nib . Text ( strings = [ nib . AttributedString ( \"Price: \" , font = nib . Font . BODY ), nib . AttributedString ( \"$9.99\" , style = nib . TextStyle ( font = nib . Font . system ( 20 ), bold = True , monospaced_digit = True , ), color = nib . Color . GREEN , ), ]), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Rich text with AttributedString"},{"location":"reference/types/text-style/#monospaced-digits-for-tabular-data","text":"import nib def main ( app : nib . App ): items = [( \"Apples\" , 12 ), ( \"Oranges\" , 8 ), ( \"Bananas\" , 145 )] mono_digit = nib . TextStyle ( monospaced_digit = True ) app . build ( nib . VStack ( controls = [ nib . HStack ( controls = [ nib . Text ( name , font = nib . Font . BODY ), nib . Spacer (), nib . Text ( str ( count ), style = mono_digit ), ], ) for name , count in items ], spacing = 4 , padding = 16 , ) ) nib . run ( main )","title":"Monospaced digits for tabular data"},{"location":"reference/types/transition/","text":"The Transition enum and TransitionConfig dataclass control how views animate when they appear in or disappear from the view hierarchy. The related ContentTransition enum controls how a view's content animates when it changes. import nib # Simple transition label = nib . Text ( \"Hello\" , transition = nib . Transition . OPACITY ) # Asymmetric transition panel = nib . VStack ( controls = [ ... ], transition = nib . Transition . asymmetric ( insertion = nib . Transition . SLIDE , removal = nib . Transition . OPACITY , ), ) Transition Enum \u00b6 The Transition enum defines built-in transition animations. Value SwiftUI Equivalent Description Transition.IDENTITY .identity No animation (instant appear/disappear). Transition.OPACITY .opacity Fade in/out. Transition.SCALE .scale Scale up from zero / shrink to zero. Transition.SLIDE .slide Slide in from the leading edge / out to the trailing edge. Transition.MOVE_LEADING .move(edge: .leading) Move in from the leading edge. Transition.MOVE_TRAILING .move(edge: .trailing) Move in from the trailing edge. Transition.MOVE_TOP .move(edge: .top) Move in from the top edge. Transition.MOVE_BOTTOM .move(edge: .bottom) Move in from the bottom edge. Transition.PUSH .push Push transition (content slides in, replacing previous). nib . Text ( \"Fade\" , transition = nib . Transition . OPACITY ) nib . Text ( \"Scale\" , transition = nib . Transition . SCALE ) nib . Text ( \"Slide In\" , transition = nib . Transition . MOVE_LEADING ) Static Methods \u00b6 Transition.asymmetric(insertion, removal) \u00b6 Create a transition with different animations for insertion (appearing) and removal (disappearing). transition = nib . Transition . asymmetric ( insertion = nib . Transition . SCALE , removal = nib . Transition . OPACITY , ) Parameter Type Description insertion Transition \\| str Transition used when the view appears. removal Transition \\| str Transition used when the view disappears. Returns: A TransitionConfig object. Transition.combined(*transitions) \u00b6 Create a transition that combines multiple transition effects simultaneously. transition = nib . Transition . combined ( nib . Transition . OPACITY , nib . Transition . SCALE ) Parameter Type Description *transitions Transition \\| str Two or more transition types to combine. Returns: A TransitionConfig object. Transition.custom(name) \u00b6 Start building a custom keyframe-based transition. Returns a CustomTransitionBuilder for method chaining. transition = ( nib . Transition . custom ( \"swoosh\" ) . at ( 0.0 , opacity = 0 , scale = 0.5 , offset_x =- 50 ) . at ( 0.5 , opacity = 1 , scale = 1.1 , offset_x = 10 ) . at ( 1.0 , opacity = 1 , scale = 1.0 , offset_x = 0 ) . build () ) Parameter Type Description name str Name for the custom transition (used for debugging). Returns: A CustomTransitionBuilder . Transition.pop_fade() \u00b6 Pre-built transition that scales up slightly while fading in. panel = nib . VStack ( controls = [ ... ], transition = nib . Transition . pop_fade ()) Transition.bounce_in() \u00b6 Pre-built transition that overshoots then settles into place. badge = nib . Text ( \"New\" , transition = nib . Transition . bounce_in ()) TransitionConfig \u00b6 The TransitionConfig dataclass represents advanced transition configurations that cannot be expressed as a single enum value. Field Type Description config_type str \"simple\" , \"asymmetric\" , \"combined\" , or \"custom\" . value str Transition value for \"simple\" type. insertion str Insertion transition for \"asymmetric\" type. removal str Removal transition for \"asymmetric\" type. transitions list[str] List of transitions for \"combined\" type. keyframes list[dict] Keyframe data for \"custom\" type. Class Methods \u00b6 TransitionConfig . simple ( \"opacity\" ) TransitionConfig . asymmetric ( \"scale\" , \"opacity\" ) TransitionConfig . combined ( \"opacity\" , \"scale\" ) You typically do not construct TransitionConfig directly. Use Transition.asymmetric() , Transition.combined() , or Transition.custom() instead. CustomTransitionBuilder \u00b6 The builder class for creating keyframe-based custom transitions. .at(progress, *, opacity=None, scale=None, blur=None, offset_x=None, offset_y=None) \u00b6 Add a keyframe at the given progress point. Parameter Type Default Description progress float -- Progress value from 0.0 (start) to 1.0 (end). opacity float None Opacity at this keyframe (0.0--1.0). scale float None Scale at this keyframe (1.0 = normal). blur float None Blur radius at this keyframe. offset_x float None Horizontal offset at this keyframe. offset_y float None Vertical offset at this keyframe. Returns: self (for method chaining). .build() \u00b6 Build and return the final TransitionConfig . Raises ValueError if no keyframes have been defined. ContentTransition \u00b6 The ContentTransition enum controls how a view's content animates when it changes. This is separate from the view transition -- it affects the content within a view that remains visible. Value SwiftUI Equivalent Description ContentTransition.IDENTITY .identity No content animation. ContentTransition.INTERPOLATE .interpolate Smooth interpolation between old and new content. ContentTransition.NUMERIC_TEXT .numericText() Digits roll upward when increasing. ContentTransition.NUMERIC_TEXT_DOWN .numericText(countsDown: true) Digits roll downward when decreasing. ContentTransition.OPACITY .opacity Old content fades out, new content fades in. # Counter with rolling digits counter = nib . Text ( \"0\" , content_transition = nib . ContentTransition . NUMERIC_TEXT ) # Fading content changes status = nib . Text ( \"Ready\" , content_transition = nib . ContentTransition . OPACITY ) Examples \u00b6 Asymmetric slide transition \u00b6 import nib def main ( app : nib . App ): panel = nib . VStack ( controls = [ nib . Text ( \"Panel Content\" , padding = 20 )], background = \"#262626\" , corner_radius = 12 , transition = nib . Transition . asymmetric ( insertion = nib . Transition . MOVE_TRAILING , removal = nib . Transition . MOVE_LEADING , ), animation = nib . Animation . spring (), ) app . build ( panel ) nib . run ( main ) Combined fade-and-scale \u00b6 import nib def main ( app : nib . App ): badge = nib . Text ( \"New\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE , background = nib . Color . RED , padding = { \"horizontal\" : 8 , \"vertical\" : 4 }, corner_radius = 8 , transition = nib . Transition . combined ( nib . Transition . OPACITY , nib . Transition . SCALE , ), animation = nib . Animation . spring ( response = 0.4 , damping = 0.6 ), ) app . build ( badge ) nib . run ( main ) Custom keyframe transition \u00b6 import nib slide_fade = ( nib . Transition . custom ( \"slideFade\" ) . at ( 0.0 , opacity = 0 , offset_x =- 100 ) . at ( 0.3 , opacity = 0.5 , offset_x =- 20 ) . at ( 1.0 , opacity = 1 , offset_x = 0 ) . build () ) def main ( app : nib . App ): app . build ( nib . Text ( \"Animated Entry\" , transition = slide_fade , animation = nib . Animation . easeOut ( 0.5 )) ) nib . run ( main )","title":"Transition"},{"location":"reference/types/transition/#transition-enum","text":"The Transition enum defines built-in transition animations. Value SwiftUI Equivalent Description Transition.IDENTITY .identity No animation (instant appear/disappear). Transition.OPACITY .opacity Fade in/out. Transition.SCALE .scale Scale up from zero / shrink to zero. Transition.SLIDE .slide Slide in from the leading edge / out to the trailing edge. Transition.MOVE_LEADING .move(edge: .leading) Move in from the leading edge. Transition.MOVE_TRAILING .move(edge: .trailing) Move in from the trailing edge. Transition.MOVE_TOP .move(edge: .top) Move in from the top edge. Transition.MOVE_BOTTOM .move(edge: .bottom) Move in from the bottom edge. Transition.PUSH .push Push transition (content slides in, replacing previous). nib . Text ( \"Fade\" , transition = nib . Transition . OPACITY ) nib . Text ( \"Scale\" , transition = nib . Transition . SCALE ) nib . Text ( \"Slide In\" , transition = nib . Transition . MOVE_LEADING )","title":"Transition Enum"},{"location":"reference/types/transition/#static-methods","text":"","title":"Static Methods"},{"location":"reference/types/transition/#transitionasymmetricinsertion-removal","text":"Create a transition with different animations for insertion (appearing) and removal (disappearing). transition = nib . Transition . asymmetric ( insertion = nib . Transition . SCALE , removal = nib . Transition . OPACITY , ) Parameter Type Description insertion Transition \\| str Transition used when the view appears. removal Transition \\| str Transition used when the view disappears. Returns: A TransitionConfig object.","title":"Transition.asymmetric(insertion, removal)"},{"location":"reference/types/transition/#transitioncombinedtransitions","text":"Create a transition that combines multiple transition effects simultaneously. transition = nib . Transition . combined ( nib . Transition . OPACITY , nib . Transition . SCALE ) Parameter Type Description *transitions Transition \\| str Two or more transition types to combine. Returns: A TransitionConfig object.","title":"Transition.combined(*transitions)"},{"location":"reference/types/transition/#transitioncustomname","text":"Start building a custom keyframe-based transition. Returns a CustomTransitionBuilder for method chaining. transition = ( nib . Transition . custom ( \"swoosh\" ) . at ( 0.0 , opacity = 0 , scale = 0.5 , offset_x =- 50 ) . at ( 0.5 , opacity = 1 , scale = 1.1 , offset_x = 10 ) . at ( 1.0 , opacity = 1 , scale = 1.0 , offset_x = 0 ) . build () ) Parameter Type Description name str Name for the custom transition (used for debugging). Returns: A CustomTransitionBuilder .","title":"Transition.custom(name)"},{"location":"reference/types/transition/#transitionpop_fade","text":"Pre-built transition that scales up slightly while fading in. panel = nib . VStack ( controls = [ ... ], transition = nib . Transition . pop_fade ())","title":"Transition.pop_fade()"},{"location":"reference/types/transition/#transitionbounce_in","text":"Pre-built transition that overshoots then settles into place. badge = nib . Text ( \"New\" , transition = nib . Transition . bounce_in ())","title":"Transition.bounce_in()"},{"location":"reference/types/transition/#transitionconfig","text":"The TransitionConfig dataclass represents advanced transition configurations that cannot be expressed as a single enum value. Field Type Description config_type str \"simple\" , \"asymmetric\" , \"combined\" , or \"custom\" . value str Transition value for \"simple\" type. insertion str Insertion transition for \"asymmetric\" type. removal str Removal transition for \"asymmetric\" type. transitions list[str] List of transitions for \"combined\" type. keyframes list[dict] Keyframe data for \"custom\" type.","title":"TransitionConfig"},{"location":"reference/types/transition/#class-methods","text":"TransitionConfig . simple ( \"opacity\" ) TransitionConfig . asymmetric ( \"scale\" , \"opacity\" ) TransitionConfig . combined ( \"opacity\" , \"scale\" ) You typically do not construct TransitionConfig directly. Use Transition.asymmetric() , Transition.combined() , or Transition.custom() instead.","title":"Class Methods"},{"location":"reference/types/transition/#customtransitionbuilder","text":"The builder class for creating keyframe-based custom transitions.","title":"CustomTransitionBuilder"},{"location":"reference/types/transition/#atprogress-opacitynone-scalenone-blurnone-offset_xnone-offset_ynone","text":"Add a keyframe at the given progress point. Parameter Type Default Description progress float -- Progress value from 0.0 (start) to 1.0 (end). opacity float None Opacity at this keyframe (0.0--1.0). scale float None Scale at this keyframe (1.0 = normal). blur float None Blur radius at this keyframe. offset_x float None Horizontal offset at this keyframe. offset_y float None Vertical offset at this keyframe. Returns: self (for method chaining).","title":".at(progress, *, opacity=None, scale=None, blur=None, offset_x=None, offset_y=None)"},{"location":"reference/types/transition/#build","text":"Build and return the final TransitionConfig . Raises ValueError if no keyframes have been defined.","title":".build()"},{"location":"reference/types/transition/#contenttransition","text":"The ContentTransition enum controls how a view's content animates when it changes. This is separate from the view transition -- it affects the content within a view that remains visible. Value SwiftUI Equivalent Description ContentTransition.IDENTITY .identity No content animation. ContentTransition.INTERPOLATE .interpolate Smooth interpolation between old and new content. ContentTransition.NUMERIC_TEXT .numericText() Digits roll upward when increasing. ContentTransition.NUMERIC_TEXT_DOWN .numericText(countsDown: true) Digits roll downward when decreasing. ContentTransition.OPACITY .opacity Old content fades out, new content fades in. # Counter with rolling digits counter = nib . Text ( \"0\" , content_transition = nib . ContentTransition . NUMERIC_TEXT ) # Fading content changes status = nib . Text ( \"Ready\" , content_transition = nib . ContentTransition . OPACITY )","title":"ContentTransition"},{"location":"reference/types/transition/#examples","text":"","title":"Examples"},{"location":"reference/types/transition/#asymmetric-slide-transition","text":"import nib def main ( app : nib . App ): panel = nib . VStack ( controls = [ nib . Text ( \"Panel Content\" , padding = 20 )], background = \"#262626\" , corner_radius = 12 , transition = nib . Transition . asymmetric ( insertion = nib . Transition . MOVE_TRAILING , removal = nib . Transition . MOVE_LEADING , ), animation = nib . Animation . spring (), ) app . build ( panel ) nib . run ( main )","title":"Asymmetric slide transition"},{"location":"reference/types/transition/#combined-fade-and-scale","text":"import nib def main ( app : nib . App ): badge = nib . Text ( \"New\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE , background = nib . Color . RED , padding = { \"horizontal\" : 8 , \"vertical\" : 4 }, corner_radius = 8 , transition = nib . Transition . combined ( nib . Transition . OPACITY , nib . Transition . SCALE , ), animation = nib . Animation . spring ( response = 0.4 , damping = 0.6 ), ) app . build ( badge ) nib . run ( main )","title":"Combined fade-and-scale"},{"location":"reference/types/transition/#custom-keyframe-transition","text":"import nib slide_fade = ( nib . Transition . custom ( \"slideFade\" ) . at ( 0.0 , opacity = 0 , offset_x =- 100 ) . at ( 0.3 , opacity = 0.5 , offset_x =- 20 ) . at ( 1.0 , opacity = 1 , offset_x = 0 ) . build () ) def main ( app : nib . App ): app . build ( nib . Text ( \"Animated Entry\" , transition = slide_fade , animation = nib . Animation . easeOut ( 0.5 )) ) nib . run ( main )","title":"Custom keyframe transition"},{"location":"reference/views/","text":"Views are the building blocks of Nib user interfaces. Every visible element on screen is a view. All views inherit from a common View base class and accept constructor parameters for layout, appearance, typography, animation, and other modifiers. Views are organized into the following categories: Category Description Controls Interactive UI elements for displaying content and capturing input: Text, Button, TextField, Toggle, Slider, Picker, Image, Video, Table, Map, WebView, and more. Layout Container views that arrange children: VStack, HStack, ZStack, ScrollView, List, Form, NavigationStack, Grid, and more. Shapes Geometric shape views: Rectangle, Circle, Ellipse, Capsule. Charts Data visualization powered by Swift Charts: Chart, LineMark, BarMark, AreaMark, PointMark, RuleMark, RectMark, SectorMark. Effects Visual effect views: VisualEffectBlur for macOS frosted-glass blur, and Canvas for freeform Core Graphics drawing. Common modifiers \u00b6 All views accept these constructor parameters for styling and layout: # Layout width , height , min_width , min_height , max_width , max_height padding # float or dict: {\"top\": 8, \"horizontal\": 16} # Appearance background , foreground_color , fill , stroke , stroke_width opacity , corner_radius , clip_shape # Shadow & Border shadow_color , shadow_radius , shadow_x , shadow_y border_color , border_width # Typography font , font_weight # Animation animation , content_transition , transition # Transform scale , blend_mode","title":"Index"},{"location":"reference/views/#common-modifiers","text":"All views accept these constructor parameters for styling and layout: # Layout width , height , min_width , min_height , max_width , max_height padding # float or dict: {\"top\": 8, \"horizontal\": 16} # Appearance background , foreground_color , fill , stroke , stroke_width opacity , corner_radius , clip_shape # Shadow & Border shadow_color , shadow_radius , shadow_x , shadow_y border_color , border_width # Typography font , font_weight # Animation animation , content_transition , transition # Transform scale , blend_mode","title":"Common modifiers"},{"location":"reference/views/charts/","text":"Chart views provide data visualization powered by Swift Charts. The Chart container renders one or more mark types against a shared dataset, with optional axis and legend configuration. All chart marks accept data field references as strings (e.g., x=\"month\" ) or typed PlottableField objects for explicit data type hints. Colors can be static (hex strings, named colors) or data-driven via PlottableField for automatic palette assignment. Container \u00b6 View Description Chart The main container that holds data, marks, axes, and legend configuration. Marks \u00b6 View Description LineMark Connects data points with a continuous line. Supports symbols and interpolation. BarMark Displays data as rectangular bars with stacking and grouping support. AreaMark Fills the region between a line and a baseline for cumulative visualizations. PointMark Renders individual data points as symbols for scatter plots. RuleMark Draws reference lines (horizontal or vertical) across the chart. RectMark Draws filled rectangles for heatmaps, Gantt charts, and range visualizations. SectorMark Creates pie and donut chart segments from angular data. Configuration \u00b6 Class Description ChartAxis & ChartLegend Axis and legend configuration, plus supporting types like PlottableField , InterpolationMethod , StackingMethod , and SymbolShape . Quick example \u00b6 import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"month\" : \"Jan\" , \"sales\" : 100 }, { \"month\" : \"Feb\" , \"sales\" : 150 }, { \"month\" : \"Mar\" , \"sales\" : 200 }, { \"month\" : \"Apr\" , \"sales\" : 180 }, ], marks = [ nib . LineMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" )], x_axis = nib . ChartAxis ( label = \"Month\" ), y_axis = nib . ChartAxis ( label = \"Sales\" , grid_lines = True ), width = 350 , height = 250 , padding = 16 , ) app . build ( chart ) nib . run ( main )","title":"Index"},{"location":"reference/views/charts/#container","text":"View Description Chart The main container that holds data, marks, axes, and legend configuration.","title":"Container"},{"location":"reference/views/charts/#marks","text":"View Description LineMark Connects data points with a continuous line. Supports symbols and interpolation. BarMark Displays data as rectangular bars with stacking and grouping support. AreaMark Fills the region between a line and a baseline for cumulative visualizations. PointMark Renders individual data points as symbols for scatter plots. RuleMark Draws reference lines (horizontal or vertical) across the chart. RectMark Draws filled rectangles for heatmaps, Gantt charts, and range visualizations. SectorMark Creates pie and donut chart segments from angular data.","title":"Marks"},{"location":"reference/views/charts/#configuration","text":"Class Description ChartAxis & ChartLegend Axis and legend configuration, plus supporting types like PlottableField , InterpolationMethod , StackingMethod , and SymbolShape .","title":"Configuration"},{"location":"reference/views/charts/#quick-example","text":"import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"month\" : \"Jan\" , \"sales\" : 100 }, { \"month\" : \"Feb\" , \"sales\" : 150 }, { \"month\" : \"Mar\" , \"sales\" : 200 }, { \"month\" : \"Apr\" , \"sales\" : 180 }, ], marks = [ nib . LineMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" )], x_axis = nib . ChartAxis ( label = \"Month\" ), y_axis = nib . ChartAxis ( label = \"Sales\" , grid_lines = True ), width = 350 , height = 250 , padding = 16 , ) app . build ( chart ) nib . run ( main )","title":"Quick example"},{"location":"reference/views/charts/areamark/","text":"Fills the region between a line and a baseline, creating a visual representation of cumulative values or ranges. Area charts are effective for showing magnitude over time, and they support stacking for multi-series data. By default, the area extends from zero to the y value. Use y_start to create range areas or band charts. AreaMark is used inside a Chart container as one of the marks entries. Constructor \u00b6 nib . AreaMark ( x , y , y_start = None , foreground_style = None , interpolation = None , stacking = None , opacity = None , ) Parameters \u00b6 Parameter Type Default Description x str \\| PlottableField required Data field for the x-axis position. y str \\| PlottableField required Data field for the upper boundary of the area (y-axis). y_start str \\| PlottableField None Data field for the lower boundary of the area. If omitted, the area extends from zero to the y value. Use this for range or band visualizations. foreground_style str \\| PlottableField None Fill color. Accepts hex strings, named colors, or a PlottableField for multi-series coloring with automatic palette assignment. interpolation InterpolationMethod \\| str None Curve interpolation method. Options: LINEAR , MONOTONE , CATMULL_ROM , CARDINAL , STEP_START , STEP_CENTER , STEP_END . stacking StackingMethod \\| str None Stacking mode for multi-series areas. Options: STANDARD (stacked), NORMALIZED (100% stacked), CENTER (stream graph). opacity float None Fill opacity from 0.0 to 1.0. Consider lower values (0.3--0.7) for overlapping areas. Examples \u00b6 Basic area chart \u00b6 import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"date\" : \"Jan\" , \"revenue\" : 100 }, { \"date\" : \"Feb\" , \"revenue\" : 150 }, { \"date\" : \"Mar\" , \"revenue\" : 200 }, { \"date\" : \"Apr\" , \"revenue\" : 180 }, ], marks = [ nib . AreaMark ( x = \"date\" , y = \"revenue\" , foreground_style = \"#3B82F6\" , opacity = 0.5 ), ], width = 350 , height = 200 , ) app . build ( chart ) nib . run ( main ) Stacked area chart \u00b6 import nib data = [ { \"month\" : \"Jan\" , \"value\" : 30 , \"category\" : \"A\" }, { \"month\" : \"Jan\" , \"value\" : 20 , \"category\" : \"B\" }, { \"month\" : \"Feb\" , \"value\" : 35 , \"category\" : \"A\" }, { \"month\" : \"Feb\" , \"value\" : 25 , \"category\" : \"B\" }, { \"month\" : \"Mar\" , \"value\" : 40 , \"category\" : \"A\" }, { \"month\" : \"Mar\" , \"value\" : 30 , \"category\" : \"B\" }, ] chart = nib . Chart ( data = data , marks = [ nib . AreaMark ( x = \"month\" , y = \"value\" , foreground_style = nib . PlottableField ( \"category\" ), stacking = nib . StackingMethod . STANDARD , ), ], legend = nib . ChartLegend ( position = \"bottom\" ), width = 400 , height = 250 , ) Range/band area \u00b6 import nib chart = nib . Chart ( data = [ { \"date\" : \"Jan\" , \"high\" : 15 , \"low\" : 2 }, { \"date\" : \"Feb\" , \"high\" : 18 , \"low\" : 5 }, { \"date\" : \"Mar\" , \"high\" : 22 , \"low\" : 10 }, ], marks = [ nib . AreaMark ( x = \"date\" , y = \"high\" , y_start = \"low\" , foreground_style = \"#3B82F6\" , opacity = 0.3 , ), ], width = 350 , height = 200 , ) Smooth area with interpolation \u00b6 import nib chart = nib . Chart ( data = time_series , marks = [ nib . AreaMark ( x = \"date\" , y = \"value\" , foreground_style = \"#8B5CF6\" , interpolation = nib . InterpolationMethod . MONOTONE , opacity = 0.4 , ), ], width = 400 , height = 200 , )","title":"AreaMark"},{"location":"reference/views/charts/areamark/#constructor","text":"nib . AreaMark ( x , y , y_start = None , foreground_style = None , interpolation = None , stacking = None , opacity = None , )","title":"Constructor"},{"location":"reference/views/charts/areamark/#parameters","text":"Parameter Type Default Description x str \\| PlottableField required Data field for the x-axis position. y str \\| PlottableField required Data field for the upper boundary of the area (y-axis). y_start str \\| PlottableField None Data field for the lower boundary of the area. If omitted, the area extends from zero to the y value. Use this for range or band visualizations. foreground_style str \\| PlottableField None Fill color. Accepts hex strings, named colors, or a PlottableField for multi-series coloring with automatic palette assignment. interpolation InterpolationMethod \\| str None Curve interpolation method. Options: LINEAR , MONOTONE , CATMULL_ROM , CARDINAL , STEP_START , STEP_CENTER , STEP_END . stacking StackingMethod \\| str None Stacking mode for multi-series areas. Options: STANDARD (stacked), NORMALIZED (100% stacked), CENTER (stream graph). opacity float None Fill opacity from 0.0 to 1.0. Consider lower values (0.3--0.7) for overlapping areas.","title":"Parameters"},{"location":"reference/views/charts/areamark/#examples","text":"","title":"Examples"},{"location":"reference/views/charts/areamark/#basic-area-chart","text":"import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"date\" : \"Jan\" , \"revenue\" : 100 }, { \"date\" : \"Feb\" , \"revenue\" : 150 }, { \"date\" : \"Mar\" , \"revenue\" : 200 }, { \"date\" : \"Apr\" , \"revenue\" : 180 }, ], marks = [ nib . AreaMark ( x = \"date\" , y = \"revenue\" , foreground_style = \"#3B82F6\" , opacity = 0.5 ), ], width = 350 , height = 200 , ) app . build ( chart ) nib . run ( main )","title":"Basic area chart"},{"location":"reference/views/charts/areamark/#stacked-area-chart","text":"import nib data = [ { \"month\" : \"Jan\" , \"value\" : 30 , \"category\" : \"A\" }, { \"month\" : \"Jan\" , \"value\" : 20 , \"category\" : \"B\" }, { \"month\" : \"Feb\" , \"value\" : 35 , \"category\" : \"A\" }, { \"month\" : \"Feb\" , \"value\" : 25 , \"category\" : \"B\" }, { \"month\" : \"Mar\" , \"value\" : 40 , \"category\" : \"A\" }, { \"month\" : \"Mar\" , \"value\" : 30 , \"category\" : \"B\" }, ] chart = nib . Chart ( data = data , marks = [ nib . AreaMark ( x = \"month\" , y = \"value\" , foreground_style = nib . PlottableField ( \"category\" ), stacking = nib . StackingMethod . STANDARD , ), ], legend = nib . ChartLegend ( position = \"bottom\" ), width = 400 , height = 250 , )","title":"Stacked area chart"},{"location":"reference/views/charts/areamark/#rangeband-area","text":"import nib chart = nib . Chart ( data = [ { \"date\" : \"Jan\" , \"high\" : 15 , \"low\" : 2 }, { \"date\" : \"Feb\" , \"high\" : 18 , \"low\" : 5 }, { \"date\" : \"Mar\" , \"high\" : 22 , \"low\" : 10 }, ], marks = [ nib . AreaMark ( x = \"date\" , y = \"high\" , y_start = \"low\" , foreground_style = \"#3B82F6\" , opacity = 0.3 , ), ], width = 350 , height = 200 , )","title":"Range/band area"},{"location":"reference/views/charts/areamark/#smooth-area-with-interpolation","text":"import nib chart = nib . Chart ( data = time_series , marks = [ nib . AreaMark ( x = \"date\" , y = \"value\" , foreground_style = \"#8B5CF6\" , interpolation = nib . InterpolationMethod . MONOTONE , opacity = 0.4 , ), ], width = 400 , height = 200 , )","title":"Smooth area with interpolation"},{"location":"reference/views/charts/axis-legend/","text":"Configuration objects for chart axes and legends. These are passed to the Chart constructor via the x_axis , y_axis , and legend parameters. They do not render anything on their own. This page also documents the supporting types used for chart data encoding: PlottableField , PlottableValue , InterpolationMethod , StackingMethod , SymbolShape , AxisPosition , LegendPosition , and PlottableType . ChartAxis \u00b6 Controls the appearance and behavior of a chart axis, including position, labels, grid lines, value formatting, and colors. Constructor \u00b6 nib . ChartAxis ( position = None , label = None , grid_lines = None , hidden = None , format = None , values = None , label_color = None , grid_color = None , ) Parameters \u00b6 Parameter Type Default Description position str \\| AxisPosition None Position of the axis. For x-axis: \"bottom\" (default) or \"top\" . For y-axis: \"leading\" (default, left in LTR) or \"trailing\" . label str None Text label displayed alongside the axis (e.g., \"Temperature (F)\" ). grid_lines bool None Whether to display grid lines extending from tick marks across the plot area. hidden bool None Whether to completely hide the axis, including tick marks and labels. format str None Format for axis values: \"number\" , \"currency\" , or \"percent\" . Defaults to automatic formatting. values list None Explicit list of values to show as tick marks. Only these values appear on the axis. label_color str None Color for axis labels and tick text. Accepts hex strings or named colors. grid_color str None Color for grid lines (when grid_lines=True ). Accepts hex strings or named colors. Examples \u00b6 # Basic axis with label nib . ChartAxis ( label = \"Revenue ($)\" ) # Axis with grid lines and formatting nib . ChartAxis ( label = \"Sales\" , grid_lines = True , format = \"currency\" , label_color = \"#666666\" , grid_color = \"#333333\" , ) # Custom tick values nib . ChartAxis ( label = \"Rating\" , values = [ 1 , 2 , 3 , 4 , 5 ]) # Hidden axis nib . ChartAxis ( hidden = True ) # Axis positioned at top nib . ChartAxis ( position = nib . AxisPosition . TOP , label = \"Date\" ) ChartLegend \u00b6 Controls the position and visibility of the chart legend. The legend is automatically generated from foreground_style mappings in marks. Constructor \u00b6 nib . ChartLegend ( position = None , hidden = None , title = None , ) Parameters \u00b6 Parameter Type Default Description position str None Legend position: \"top\" , \"bottom\" , \"leading\" , \"trailing\" , or \"automatic\" . hidden bool None Whether to hide the legend entirely. title str None Optional title text displayed above the legend items (e.g., \"Region\" ). Examples \u00b6 # Bottom-positioned legend with title nib . ChartLegend ( position = \"bottom\" , title = \"Product Category\" ) # Hide the legend nib . ChartLegend ( hidden = True ) # Or use the shorthand on Chart nib . Chart ( data = data , marks = [ ... ], legend = False ) PlottableField \u00b6 A reference to a data column with optional type information. While field names can usually be passed as plain strings, PlottableField is useful when you need explicit data type hints or data-driven color/symbol encoding. Constructor \u00b6 nib . PlottableField ( field , type = None ) Parameters \u00b6 Parameter Type Default Description field str required Name of the data column. Must match a key in the chart's data dictionaries. type PlottableType \\| str None Data type hint: \"quantitative\" , \"nominal\" , or \"temporal\" . Inferred automatically when omitted. Examples \u00b6 # Simple field reference (same as using the string \"sales\" directly) nib . PlottableField ( \"sales\" ) # Typed temporal field nib . PlottableField ( \"date\" , type = nib . PlottableType . TEMPORAL ) # Color encoding by category nib . LineMark ( x = \"date\" , y = \"value\" , foreground_style = nib . PlottableField ( \"category\" ), ) PlottableValue \u00b6 A static value for chart encoding, primarily used with RuleMark to create reference lines at fixed positions with optional labels. Constructor \u00b6 nib . PlottableValue ( value , label = None ) Parameters \u00b6 Parameter Type Default Description value int \\| float \\| str required The static value. A number for quantitative axes, or a string for categorical axes. label str None Optional label text displayed alongside the value (e.g., \"Target\" , \"Average\" ). Examples \u00b6 # Reference line at a fixed value with label nib . RuleMark ( y = nib . PlottableValue ( 100 , label = \"Target\" )) # Simple numeric value (equivalent shorthand) nib . RuleMark ( y = 100 ) Enumerations \u00b6 InterpolationMethod \u00b6 Curve interpolation methods for LineMark and AreaMark . Value Description LINEAR Straight lines between points. Default. MONOTONE Smooth curve preserving monotonicity. No artificial peaks between points. CATMULL_ROM Smooth cubic spline through all points. May overshoot. CARDINAL Smooth curve with adjustable tension. STEP_START Horizontal step, transitioning at interval start. STEP_CENTER Horizontal step, transitioning at interval midpoint. STEP_END Horizontal step, transitioning at interval end. nib . LineMark ( x = \"date\" , y = \"temp\" , interpolation = nib . InterpolationMethod . MONOTONE ) StackingMethod \u00b6 Stacking modes for BarMark and AreaMark . Value Description STANDARD Values stacked on top of each other. Y-axis reflects cumulative total. NORMALIZED Values scaled to 100% at each x position. Shows relative proportions. CENTER Values centered around the middle axis (stream graph effect). nib . BarMark ( x = \"q\" , y = \"rev\" , foreground_style = nib . PlottableField ( \"region\" ), stacking = nib . StackingMethod . STANDARD ) SymbolShape \u00b6 Point marker shapes for PointMark and LineMark . Value Description CIRCLE Filled circle. Default and most common. SQUARE Filled square. TRIANGLE Filled upward-pointing triangle. DIAMOND Filled diamond (rotated square). CROSS X-shaped cross. Lighter visual weight. PLUS Plus sign. Axis-aligned. PENTAGON Filled five-sided polygon. HEXAGON Filled six-sided polygon. nib . PointMark ( x = \"x\" , y = \"y\" , symbol = nib . SymbolShape . DIAMOND , symbol_size = 100 ) AxisPosition \u00b6 Axis placement relative to the plot area. Value Description BOTTOM Below the plot area. Default for x-axis. TOP Above the plot area. LEADING Left side (LTR). Default for y-axis. TRAILING Right side (LTR). LegendPosition \u00b6 Legend placement relative to the chart. Value Description TOP Above the chart. BOTTOM Below the chart. LEADING Left side (LTR). TRAILING Right side (LTR). AUTOMATIC System chooses based on available space. HIDDEN Legend is not displayed. PlottableType \u00b6 Data type hints for plottable values. Value Description QUANTITATIVE Numeric data on a continuous linear scale. NOMINAL Categorical data with no inherent order. Discrete band scale. TEMPORAL Date/time data. Time-aware scale with intelligent tick formatting. nib . PlottableField ( \"date\" , type = nib . PlottableType . TEMPORAL )","title":"ChartAxis & ChartLegend"},{"location":"reference/views/charts/axis-legend/#chartaxis","text":"Controls the appearance and behavior of a chart axis, including position, labels, grid lines, value formatting, and colors.","title":"ChartAxis"},{"location":"reference/views/charts/axis-legend/#constructor","text":"nib . ChartAxis ( position = None , label = None , grid_lines = None , hidden = None , format = None , values = None , label_color = None , grid_color = None , )","title":"Constructor"},{"location":"reference/views/charts/axis-legend/#parameters","text":"Parameter Type Default Description position str \\| AxisPosition None Position of the axis. For x-axis: \"bottom\" (default) or \"top\" . For y-axis: \"leading\" (default, left in LTR) or \"trailing\" . label str None Text label displayed alongside the axis (e.g., \"Temperature (F)\" ). grid_lines bool None Whether to display grid lines extending from tick marks across the plot area. hidden bool None Whether to completely hide the axis, including tick marks and labels. format str None Format for axis values: \"number\" , \"currency\" , or \"percent\" . Defaults to automatic formatting. values list None Explicit list of values to show as tick marks. Only these values appear on the axis. label_color str None Color for axis labels and tick text. Accepts hex strings or named colors. grid_color str None Color for grid lines (when grid_lines=True ). Accepts hex strings or named colors.","title":"Parameters"},{"location":"reference/views/charts/axis-legend/#examples","text":"# Basic axis with label nib . ChartAxis ( label = \"Revenue ($)\" ) # Axis with grid lines and formatting nib . ChartAxis ( label = \"Sales\" , grid_lines = True , format = \"currency\" , label_color = \"#666666\" , grid_color = \"#333333\" , ) # Custom tick values nib . ChartAxis ( label = \"Rating\" , values = [ 1 , 2 , 3 , 4 , 5 ]) # Hidden axis nib . ChartAxis ( hidden = True ) # Axis positioned at top nib . ChartAxis ( position = nib . AxisPosition . TOP , label = \"Date\" )","title":"Examples"},{"location":"reference/views/charts/axis-legend/#chartlegend","text":"Controls the position and visibility of the chart legend. The legend is automatically generated from foreground_style mappings in marks.","title":"ChartLegend"},{"location":"reference/views/charts/axis-legend/#constructor_1","text":"nib . ChartLegend ( position = None , hidden = None , title = None , )","title":"Constructor"},{"location":"reference/views/charts/axis-legend/#parameters_1","text":"Parameter Type Default Description position str None Legend position: \"top\" , \"bottom\" , \"leading\" , \"trailing\" , or \"automatic\" . hidden bool None Whether to hide the legend entirely. title str None Optional title text displayed above the legend items (e.g., \"Region\" ).","title":"Parameters"},{"location":"reference/views/charts/axis-legend/#examples_1","text":"# Bottom-positioned legend with title nib . ChartLegend ( position = \"bottom\" , title = \"Product Category\" ) # Hide the legend nib . ChartLegend ( hidden = True ) # Or use the shorthand on Chart nib . Chart ( data = data , marks = [ ... ], legend = False )","title":"Examples"},{"location":"reference/views/charts/axis-legend/#plottablefield","text":"A reference to a data column with optional type information. While field names can usually be passed as plain strings, PlottableField is useful when you need explicit data type hints or data-driven color/symbol encoding.","title":"PlottableField"},{"location":"reference/views/charts/axis-legend/#constructor_2","text":"nib . PlottableField ( field , type = None )","title":"Constructor"},{"location":"reference/views/charts/axis-legend/#parameters_2","text":"Parameter Type Default Description field str required Name of the data column. Must match a key in the chart's data dictionaries. type PlottableType \\| str None Data type hint: \"quantitative\" , \"nominal\" , or \"temporal\" . Inferred automatically when omitted.","title":"Parameters"},{"location":"reference/views/charts/axis-legend/#examples_2","text":"# Simple field reference (same as using the string \"sales\" directly) nib . PlottableField ( \"sales\" ) # Typed temporal field nib . PlottableField ( \"date\" , type = nib . PlottableType . TEMPORAL ) # Color encoding by category nib . LineMark ( x = \"date\" , y = \"value\" , foreground_style = nib . PlottableField ( \"category\" ), )","title":"Examples"},{"location":"reference/views/charts/axis-legend/#plottablevalue","text":"A static value for chart encoding, primarily used with RuleMark to create reference lines at fixed positions with optional labels.","title":"PlottableValue"},{"location":"reference/views/charts/axis-legend/#constructor_3","text":"nib . PlottableValue ( value , label = None )","title":"Constructor"},{"location":"reference/views/charts/axis-legend/#parameters_3","text":"Parameter Type Default Description value int \\| float \\| str required The static value. A number for quantitative axes, or a string for categorical axes. label str None Optional label text displayed alongside the value (e.g., \"Target\" , \"Average\" ).","title":"Parameters"},{"location":"reference/views/charts/axis-legend/#examples_3","text":"# Reference line at a fixed value with label nib . RuleMark ( y = nib . PlottableValue ( 100 , label = \"Target\" )) # Simple numeric value (equivalent shorthand) nib . RuleMark ( y = 100 )","title":"Examples"},{"location":"reference/views/charts/axis-legend/#enumerations","text":"","title":"Enumerations"},{"location":"reference/views/charts/axis-legend/#interpolationmethod","text":"Curve interpolation methods for LineMark and AreaMark . Value Description LINEAR Straight lines between points. Default. MONOTONE Smooth curve preserving monotonicity. No artificial peaks between points. CATMULL_ROM Smooth cubic spline through all points. May overshoot. CARDINAL Smooth curve with adjustable tension. STEP_START Horizontal step, transitioning at interval start. STEP_CENTER Horizontal step, transitioning at interval midpoint. STEP_END Horizontal step, transitioning at interval end. nib . LineMark ( x = \"date\" , y = \"temp\" , interpolation = nib . InterpolationMethod . MONOTONE )","title":"InterpolationMethod"},{"location":"reference/views/charts/axis-legend/#stackingmethod","text":"Stacking modes for BarMark and AreaMark . Value Description STANDARD Values stacked on top of each other. Y-axis reflects cumulative total. NORMALIZED Values scaled to 100% at each x position. Shows relative proportions. CENTER Values centered around the middle axis (stream graph effect). nib . BarMark ( x = \"q\" , y = \"rev\" , foreground_style = nib . PlottableField ( \"region\" ), stacking = nib . StackingMethod . STANDARD )","title":"StackingMethod"},{"location":"reference/views/charts/axis-legend/#symbolshape","text":"Point marker shapes for PointMark and LineMark . Value Description CIRCLE Filled circle. Default and most common. SQUARE Filled square. TRIANGLE Filled upward-pointing triangle. DIAMOND Filled diamond (rotated square). CROSS X-shaped cross. Lighter visual weight. PLUS Plus sign. Axis-aligned. PENTAGON Filled five-sided polygon. HEXAGON Filled six-sided polygon. nib . PointMark ( x = \"x\" , y = \"y\" , symbol = nib . SymbolShape . DIAMOND , symbol_size = 100 )","title":"SymbolShape"},{"location":"reference/views/charts/axis-legend/#axisposition","text":"Axis placement relative to the plot area. Value Description BOTTOM Below the plot area. Default for x-axis. TOP Above the plot area. LEADING Left side (LTR). Default for y-axis. TRAILING Right side (LTR).","title":"AxisPosition"},{"location":"reference/views/charts/axis-legend/#legendposition","text":"Legend placement relative to the chart. Value Description TOP Above the chart. BOTTOM Below the chart. LEADING Left side (LTR). TRAILING Right side (LTR). AUTOMATIC System chooses based on available space. HIDDEN Legend is not displayed.","title":"LegendPosition"},{"location":"reference/views/charts/axis-legend/#plottabletype","text":"Data type hints for plottable values. Value Description QUANTITATIVE Numeric data on a continuous linear scale. NOMINAL Categorical data with no inherent order. Discrete band scale. TEMPORAL Date/time data. Time-aware scale with intelligent tick formatting. nib . PlottableField ( \"date\" , type = nib . PlottableType . TEMPORAL )","title":"PlottableType"},{"location":"reference/views/charts/barmark/","text":"Displays data as rectangular bars, ideal for comparing discrete categories or showing distributions. Bars can be oriented vertically or horizontally and support stacking for multi-series comparisons. The orientation is determined by which fields are categorical versus quantitative. For vertical bars, x is typically categorical and y is quantitative. Swap the fields for horizontal bars. BarMark is used inside a Chart container as one of the marks entries. Constructor \u00b6 nib . BarMark ( x = None , y = None , width = None , height = None , foreground_style = None , stacking = None , corner_radius = None , opacity = None , ) Parameters \u00b6 Parameter Type Default Description x str \\| PlottableField None Data field for the x-axis. For vertical bars, this is typically the categorical field. y str \\| PlottableField None Data field for the y-axis. For vertical bars, this is the quantitative field (bar height). width float None Fixed bar width in points. If not specified, bars are sized automatically. height float None Fixed bar height in points. If not specified, bars are sized by y data values. foreground_style str \\| PlottableField None Bar fill color. Accepts hex strings, named colors, or a PlottableField to color bars by category (creates grouped or stacked bars). stacking StackingMethod \\| str None How to stack bars when multiple series overlap. Options: STANDARD (stacked), NORMALIZED (100% stacked), CENTER (centered). Default is no stacking (bars are grouped side by side). corner_radius float None Radius for rounded bar corners in points. opacity float None Opacity from 0.0 to 1.0. Examples \u00b6 Simple vertical bar chart \u00b6 import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"product\" : \"A\" , \"sales\" : 120 }, { \"product\" : \"B\" , \"sales\" : 200 }, { \"product\" : \"C\" , \"sales\" : 150 }, ], marks = [ nib . BarMark ( x = \"product\" , y = \"sales\" , foreground_style = \"#10B981\" )], width = 300 , height = 200 , ) app . build ( chart ) nib . run ( main ) Horizontal bar chart \u00b6 import nib chart = nib . Chart ( data = [ { \"lang\" : \"Python\" , \"users\" : 45 }, { \"lang\" : \"JavaScript\" , \"users\" : 38 }, { \"lang\" : \"Rust\" , \"users\" : 12 }, ], marks = [ nib . BarMark ( x = \"users\" , y = \"lang\" )], width = 350 , height = 200 , ) Stacked bar chart \u00b6 import nib data = [ { \"quarter\" : \"Q1\" , \"revenue\" : 100 , \"region\" : \"US\" }, { \"quarter\" : \"Q1\" , \"revenue\" : 80 , \"region\" : \"EU\" }, { \"quarter\" : \"Q2\" , \"revenue\" : 120 , \"region\" : \"US\" }, { \"quarter\" : \"Q2\" , \"revenue\" : 90 , \"region\" : \"EU\" }, ] chart = nib . Chart ( data = data , marks = [ nib . BarMark ( x = \"quarter\" , y = \"revenue\" , foreground_style = nib . PlottableField ( \"region\" ), stacking = nib . StackingMethod . STANDARD , ), ], legend = nib . ChartLegend ( position = \"bottom\" ), width = 400 , height = 250 , ) Styled bars with rounded corners \u00b6 import nib chart = nib . Chart ( data = product_data , marks = [ nib . BarMark ( x = \"product\" , y = \"revenue\" , foreground_style = \"#8B5CF6\" , corner_radius = 4 , ), ], width = 300 , height = 200 , )","title":"BarMark"},{"location":"reference/views/charts/barmark/#constructor","text":"nib . BarMark ( x = None , y = None , width = None , height = None , foreground_style = None , stacking = None , corner_radius = None , opacity = None , )","title":"Constructor"},{"location":"reference/views/charts/barmark/#parameters","text":"Parameter Type Default Description x str \\| PlottableField None Data field for the x-axis. For vertical bars, this is typically the categorical field. y str \\| PlottableField None Data field for the y-axis. For vertical bars, this is the quantitative field (bar height). width float None Fixed bar width in points. If not specified, bars are sized automatically. height float None Fixed bar height in points. If not specified, bars are sized by y data values. foreground_style str \\| PlottableField None Bar fill color. Accepts hex strings, named colors, or a PlottableField to color bars by category (creates grouped or stacked bars). stacking StackingMethod \\| str None How to stack bars when multiple series overlap. Options: STANDARD (stacked), NORMALIZED (100% stacked), CENTER (centered). Default is no stacking (bars are grouped side by side). corner_radius float None Radius for rounded bar corners in points. opacity float None Opacity from 0.0 to 1.0.","title":"Parameters"},{"location":"reference/views/charts/barmark/#examples","text":"","title":"Examples"},{"location":"reference/views/charts/barmark/#simple-vertical-bar-chart","text":"import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"product\" : \"A\" , \"sales\" : 120 }, { \"product\" : \"B\" , \"sales\" : 200 }, { \"product\" : \"C\" , \"sales\" : 150 }, ], marks = [ nib . BarMark ( x = \"product\" , y = \"sales\" , foreground_style = \"#10B981\" )], width = 300 , height = 200 , ) app . build ( chart ) nib . run ( main )","title":"Simple vertical bar chart"},{"location":"reference/views/charts/barmark/#horizontal-bar-chart","text":"import nib chart = nib . Chart ( data = [ { \"lang\" : \"Python\" , \"users\" : 45 }, { \"lang\" : \"JavaScript\" , \"users\" : 38 }, { \"lang\" : \"Rust\" , \"users\" : 12 }, ], marks = [ nib . BarMark ( x = \"users\" , y = \"lang\" )], width = 350 , height = 200 , )","title":"Horizontal bar chart"},{"location":"reference/views/charts/barmark/#stacked-bar-chart","text":"import nib data = [ { \"quarter\" : \"Q1\" , \"revenue\" : 100 , \"region\" : \"US\" }, { \"quarter\" : \"Q1\" , \"revenue\" : 80 , \"region\" : \"EU\" }, { \"quarter\" : \"Q2\" , \"revenue\" : 120 , \"region\" : \"US\" }, { \"quarter\" : \"Q2\" , \"revenue\" : 90 , \"region\" : \"EU\" }, ] chart = nib . Chart ( data = data , marks = [ nib . BarMark ( x = \"quarter\" , y = \"revenue\" , foreground_style = nib . PlottableField ( \"region\" ), stacking = nib . StackingMethod . STANDARD , ), ], legend = nib . ChartLegend ( position = \"bottom\" ), width = 400 , height = 250 , )","title":"Stacked bar chart"},{"location":"reference/views/charts/barmark/#styled-bars-with-rounded-corners","text":"import nib chart = nib . Chart ( data = product_data , marks = [ nib . BarMark ( x = \"product\" , y = \"revenue\" , foreground_style = \"#8B5CF6\" , corner_radius = 4 , ), ], width = 300 , height = 200 , )","title":"Styled bars with rounded corners"},{"location":"reference/views/charts/chart/","text":"The main container for displaying data visualizations using Swift Charts. Chart manages the dataset, one or more marks, axis configuration, and legend settings. Data is provided as a list of dictionaries (row-based) and is automatically converted to an efficient columnar format for the Swift runtime. Charts are reactive -- updating the data property or calling helper methods like append_data() triggers an automatic re-render. Constructor \u00b6 nib . Chart ( data , marks , x_axis = None , y_axis = None , legend = None , chart_background = None , plot_background = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description data list[dict[str, Any]] required Data points as a list of dictionaries. Each dictionary is a row with column names as keys. Keys must match the field names referenced in your marks. marks list[BaseMark] required Chart marks that define how data is visualized. Supports LineMark , BarMark , AreaMark , PointMark , RuleMark , RectMark , and SectorMark . Multiple marks can be combined for layered visualizations. x_axis ChartAxis None Configuration for the X-axis. Controls label, grid lines, position, and formatting. y_axis ChartAxis None Configuration for the Y-axis. Controls label, grid lines, position, and formatting. legend ChartLegend \\| bool None Legend configuration. Pass a ChartLegend instance for custom positioning, False to hide the legend, or None for automatic behavior. chart_background str None Background color for the entire chart container including axes and legend. Accepts hex strings (e.g., \"#1a1a1a\" ) or named colors. plot_background str None Background color for the plot area only (where data is rendered). Accepts hex strings or named colors. **modifiers Common view modifiers: width , height , padding , opacity , corner_radius , border_color , border_width , shadow_radius , etc. Mutable Properties \u00b6 Property Type Description data list[dict[str, Any]] Get or set the chart data. Setting triggers a full re-render. Methods \u00b6 Method Signature Description append_data append_data(row: dict) Appends a single row and re-renders. Useful for real-time charts. update_data update_data(index: int, row: dict) Replaces the row at index with new values and re-renders. Silently ignored if the index is out of bounds. clear_data clear_data() Removes all data points and re-renders. Examples \u00b6 Basic line chart \u00b6 import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"month\" : \"Jan\" , \"sales\" : 100 }, { \"month\" : \"Feb\" , \"sales\" : 150 }, { \"month\" : \"Mar\" , \"sales\" : 200 }, ], marks = [ nib . LineMark ( x = \"month\" , y = \"sales\" )], width = 300 , height = 200 , ) app . build ( chart ) nib . run ( main ) Chart with axes and legend \u00b6 import nib def main ( app : nib . App ): sales_data = [ { \"category\" : \"Electronics\" , \"value\" : 420 }, { \"category\" : \"Clothing\" , \"value\" : 310 }, { \"category\" : \"Food\" , \"value\" : 280 }, { \"category\" : \"Books\" , \"value\" : 190 }, ] chart = nib . Chart ( data = sales_data , marks = [ nib . BarMark ( x = \"category\" , y = \"value\" , foreground_style = \"#10B981\" )], x_axis = nib . ChartAxis ( label = \"Category\" ), y_axis = nib . ChartAxis ( label = \"Sales ($)\" , grid_lines = True ), legend = nib . ChartLegend ( position = \"bottom\" ), width = 400 , height = 300 , padding = 16 , ) app . build ( chart ) nib . run ( main ) Multi-series chart \u00b6 import nib def main ( app : nib . App ): data = [ { \"month\" : \"Jan\" , \"revenue\" : 100 , \"expenses\" : 80 }, { \"month\" : \"Feb\" , \"revenue\" : 150 , \"expenses\" : 90 }, { \"month\" : \"Mar\" , \"revenue\" : 200 , \"expenses\" : 110 }, ] chart = nib . Chart ( data = data , marks = [ nib . LineMark ( x = \"month\" , y = \"revenue\" , foreground_style = \"blue\" ), nib . LineMark ( x = \"month\" , y = \"expenses\" , foreground_style = \"red\" ), ], width = 400 , height = 250 , ) app . build ( chart ) nib . run ( main ) Styled chart with backgrounds \u00b6 import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"x\" : 1 , \"y\" : 10 }, { \"x\" : 2 , \"y\" : 25 }, { \"x\" : 3 , \"y\" : 18 }, { \"x\" : 4 , \"y\" : 32 }, ], marks = [ nib . LineMark ( x = \"x\" , y = \"y\" , foreground_style = \"#8B5CF6\" )], chart_background = \"#1a1a1a\" , plot_background = \"#262626\" , x_axis = nib . ChartAxis ( label_color = \"#999999\" ), y_axis = nib . ChartAxis ( grid_lines = True , grid_color = \"#333333\" ), width = 400 , height = 300 , padding = 16 , corner_radius = 12 , ) app . build ( chart ) nib . run ( main ) Real-time data updates \u00b6 import nib import time import random import threading def main ( app : nib . App ): chart = nib . Chart ( data = [], marks = [ nib . LineMark ( x = \"t\" , y = \"value\" , foreground_style = \"#3B82F6\" )], width = 400 , height = 200 , ) app . build ( chart ) def stream (): for t in range ( 100 ): chart . append_data ({ \"t\" : t , \"value\" : random . randint ( 0 , 100 )}) time . sleep ( 0.5 ) threading . Thread ( target = stream , daemon = True ) . start () nib . run ( main )","title":"Chart"},{"location":"reference/views/charts/chart/#constructor","text":"nib . Chart ( data , marks , x_axis = None , y_axis = None , legend = None , chart_background = None , plot_background = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/charts/chart/#parameters","text":"Parameter Type Default Description data list[dict[str, Any]] required Data points as a list of dictionaries. Each dictionary is a row with column names as keys. Keys must match the field names referenced in your marks. marks list[BaseMark] required Chart marks that define how data is visualized. Supports LineMark , BarMark , AreaMark , PointMark , RuleMark , RectMark , and SectorMark . Multiple marks can be combined for layered visualizations. x_axis ChartAxis None Configuration for the X-axis. Controls label, grid lines, position, and formatting. y_axis ChartAxis None Configuration for the Y-axis. Controls label, grid lines, position, and formatting. legend ChartLegend \\| bool None Legend configuration. Pass a ChartLegend instance for custom positioning, False to hide the legend, or None for automatic behavior. chart_background str None Background color for the entire chart container including axes and legend. Accepts hex strings (e.g., \"#1a1a1a\" ) or named colors. plot_background str None Background color for the plot area only (where data is rendered). Accepts hex strings or named colors. **modifiers Common view modifiers: width , height , padding , opacity , corner_radius , border_color , border_width , shadow_radius , etc.","title":"Parameters"},{"location":"reference/views/charts/chart/#mutable-properties","text":"Property Type Description data list[dict[str, Any]] Get or set the chart data. Setting triggers a full re-render.","title":"Mutable Properties"},{"location":"reference/views/charts/chart/#methods","text":"Method Signature Description append_data append_data(row: dict) Appends a single row and re-renders. Useful for real-time charts. update_data update_data(index: int, row: dict) Replaces the row at index with new values and re-renders. Silently ignored if the index is out of bounds. clear_data clear_data() Removes all data points and re-renders.","title":"Methods"},{"location":"reference/views/charts/chart/#examples","text":"","title":"Examples"},{"location":"reference/views/charts/chart/#basic-line-chart","text":"import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"month\" : \"Jan\" , \"sales\" : 100 }, { \"month\" : \"Feb\" , \"sales\" : 150 }, { \"month\" : \"Mar\" , \"sales\" : 200 }, ], marks = [ nib . LineMark ( x = \"month\" , y = \"sales\" )], width = 300 , height = 200 , ) app . build ( chart ) nib . run ( main )","title":"Basic line chart"},{"location":"reference/views/charts/chart/#chart-with-axes-and-legend","text":"import nib def main ( app : nib . App ): sales_data = [ { \"category\" : \"Electronics\" , \"value\" : 420 }, { \"category\" : \"Clothing\" , \"value\" : 310 }, { \"category\" : \"Food\" , \"value\" : 280 }, { \"category\" : \"Books\" , \"value\" : 190 }, ] chart = nib . Chart ( data = sales_data , marks = [ nib . BarMark ( x = \"category\" , y = \"value\" , foreground_style = \"#10B981\" )], x_axis = nib . ChartAxis ( label = \"Category\" ), y_axis = nib . ChartAxis ( label = \"Sales ($)\" , grid_lines = True ), legend = nib . ChartLegend ( position = \"bottom\" ), width = 400 , height = 300 , padding = 16 , ) app . build ( chart ) nib . run ( main )","title":"Chart with axes and legend"},{"location":"reference/views/charts/chart/#multi-series-chart","text":"import nib def main ( app : nib . App ): data = [ { \"month\" : \"Jan\" , \"revenue\" : 100 , \"expenses\" : 80 }, { \"month\" : \"Feb\" , \"revenue\" : 150 , \"expenses\" : 90 }, { \"month\" : \"Mar\" , \"revenue\" : 200 , \"expenses\" : 110 }, ] chart = nib . Chart ( data = data , marks = [ nib . LineMark ( x = \"month\" , y = \"revenue\" , foreground_style = \"blue\" ), nib . LineMark ( x = \"month\" , y = \"expenses\" , foreground_style = \"red\" ), ], width = 400 , height = 250 , ) app . build ( chart ) nib . run ( main )","title":"Multi-series chart"},{"location":"reference/views/charts/chart/#styled-chart-with-backgrounds","text":"import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"x\" : 1 , \"y\" : 10 }, { \"x\" : 2 , \"y\" : 25 }, { \"x\" : 3 , \"y\" : 18 }, { \"x\" : 4 , \"y\" : 32 }, ], marks = [ nib . LineMark ( x = \"x\" , y = \"y\" , foreground_style = \"#8B5CF6\" )], chart_background = \"#1a1a1a\" , plot_background = \"#262626\" , x_axis = nib . ChartAxis ( label_color = \"#999999\" ), y_axis = nib . ChartAxis ( grid_lines = True , grid_color = \"#333333\" ), width = 400 , height = 300 , padding = 16 , corner_radius = 12 , ) app . build ( chart ) nib . run ( main )","title":"Styled chart with backgrounds"},{"location":"reference/views/charts/chart/#real-time-data-updates","text":"import nib import time import random import threading def main ( app : nib . App ): chart = nib . Chart ( data = [], marks = [ nib . LineMark ( x = \"t\" , y = \"value\" , foreground_style = \"#3B82F6\" )], width = 400 , height = 200 , ) app . build ( chart ) def stream (): for t in range ( 100 ): chart . append_data ({ \"t\" : t , \"value\" : random . randint ( 0 , 100 )}) time . sleep ( 0.5 ) threading . Thread ( target = stream , daemon = True ) . start () nib . run ( main )","title":"Real-time data updates"},{"location":"reference/views/charts/linemark/","text":"Connects data points with a continuous line, ideal for showing trends over time or continuous relationships between variables. Lines can be styled with different colors, widths, and interpolation methods. Optional symbols (markers) can be placed at each data point for individual value visibility. LineMark is used inside a Chart container as one of the marks entries. Constructor \u00b6 nib . LineMark ( x , y , foreground_style = None , symbol = None , interpolation = None , line_width = None , opacity = None , ) Parameters \u00b6 Parameter Type Default Description x str \\| PlottableField required Data field name for the x-axis position. Can be a string or a PlottableField with explicit type information. y str \\| PlottableField required Data field name for the y-axis position. Can be a string or a PlottableField with explicit type information. foreground_style str \\| PlottableField None Line color. Accepts hex strings ( \"#3B82F6\" ), named colors ( \"blue\" ), or a PlottableField to color lines by a data category (automatic palette assignment). symbol SymbolShape \\| str \\| PlottableField None Shape of data point markers. Use a SymbolShape enum ( CIRCLE , SQUARE , TRIANGLE , DIAMOND , CROSS , PLUS , PENTAGON , HEXAGON ), a string, or a PlottableField to vary symbols by category. interpolation InterpolationMethod \\| str None Curve interpolation method between points. Options: LINEAR (default), MONOTONE , CATMULL_ROM , CARDINAL , STEP_START , STEP_CENTER , STEP_END . line_width float None Width of the line in points. Uses system default when not specified. opacity float None Opacity from 0.0 (transparent) to 1.0 (opaque). Examples \u00b6 Basic line chart \u00b6 import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"month\" : \"Jan\" , \"temp\" : 5 }, { \"month\" : \"Feb\" , \"temp\" : 7 }, { \"month\" : \"Mar\" , \"temp\" : 12 }, { \"month\" : \"Apr\" , \"temp\" : 17 }, ], marks = [ nib . LineMark ( x = \"month\" , y = \"temp\" )], width = 300 , height = 200 , ) app . build ( chart ) nib . run ( main ) Styled line with symbols \u00b6 import nib chart = nib . Chart ( data = monthly_data , marks = [ nib . LineMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" , symbol = nib . SymbolShape . CIRCLE , line_width = 2.0 , interpolation = nib . InterpolationMethod . MONOTONE , ), ], width = 400 , height = 250 , ) Multi-series with color encoding \u00b6 import nib data = [ { \"date\" : \"Jan\" , \"value\" : 10 , \"series\" : \"A\" }, { \"date\" : \"Feb\" , \"value\" : 20 , \"series\" : \"A\" }, { \"date\" : \"Jan\" , \"value\" : 15 , \"series\" : \"B\" }, { \"date\" : \"Feb\" , \"value\" : 25 , \"series\" : \"B\" }, ] chart = nib . Chart ( data = data , marks = [ nib . LineMark ( x = \"date\" , y = \"value\" , foreground_style = nib . PlottableField ( \"series\" ), ), ], width = 400 , height = 250 , ) Step chart for discrete events \u00b6 import nib chart = nib . Chart ( data = state_changes , marks = [ nib . LineMark ( x = \"time\" , y = \"state\" , interpolation = nib . InterpolationMethod . STEP_END , foreground_style = \"#F59E0B\" , ), ], width = 400 , height = 200 , )","title":"LineMark"},{"location":"reference/views/charts/linemark/#constructor","text":"nib . LineMark ( x , y , foreground_style = None , symbol = None , interpolation = None , line_width = None , opacity = None , )","title":"Constructor"},{"location":"reference/views/charts/linemark/#parameters","text":"Parameter Type Default Description x str \\| PlottableField required Data field name for the x-axis position. Can be a string or a PlottableField with explicit type information. y str \\| PlottableField required Data field name for the y-axis position. Can be a string or a PlottableField with explicit type information. foreground_style str \\| PlottableField None Line color. Accepts hex strings ( \"#3B82F6\" ), named colors ( \"blue\" ), or a PlottableField to color lines by a data category (automatic palette assignment). symbol SymbolShape \\| str \\| PlottableField None Shape of data point markers. Use a SymbolShape enum ( CIRCLE , SQUARE , TRIANGLE , DIAMOND , CROSS , PLUS , PENTAGON , HEXAGON ), a string, or a PlottableField to vary symbols by category. interpolation InterpolationMethod \\| str None Curve interpolation method between points. Options: LINEAR (default), MONOTONE , CATMULL_ROM , CARDINAL , STEP_START , STEP_CENTER , STEP_END . line_width float None Width of the line in points. Uses system default when not specified. opacity float None Opacity from 0.0 (transparent) to 1.0 (opaque).","title":"Parameters"},{"location":"reference/views/charts/linemark/#examples","text":"","title":"Examples"},{"location":"reference/views/charts/linemark/#basic-line-chart","text":"import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"month\" : \"Jan\" , \"temp\" : 5 }, { \"month\" : \"Feb\" , \"temp\" : 7 }, { \"month\" : \"Mar\" , \"temp\" : 12 }, { \"month\" : \"Apr\" , \"temp\" : 17 }, ], marks = [ nib . LineMark ( x = \"month\" , y = \"temp\" )], width = 300 , height = 200 , ) app . build ( chart ) nib . run ( main )","title":"Basic line chart"},{"location":"reference/views/charts/linemark/#styled-line-with-symbols","text":"import nib chart = nib . Chart ( data = monthly_data , marks = [ nib . LineMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" , symbol = nib . SymbolShape . CIRCLE , line_width = 2.0 , interpolation = nib . InterpolationMethod . MONOTONE , ), ], width = 400 , height = 250 , )","title":"Styled line with symbols"},{"location":"reference/views/charts/linemark/#multi-series-with-color-encoding","text":"import nib data = [ { \"date\" : \"Jan\" , \"value\" : 10 , \"series\" : \"A\" }, { \"date\" : \"Feb\" , \"value\" : 20 , \"series\" : \"A\" }, { \"date\" : \"Jan\" , \"value\" : 15 , \"series\" : \"B\" }, { \"date\" : \"Feb\" , \"value\" : 25 , \"series\" : \"B\" }, ] chart = nib . Chart ( data = data , marks = [ nib . LineMark ( x = \"date\" , y = \"value\" , foreground_style = nib . PlottableField ( \"series\" ), ), ], width = 400 , height = 250 , )","title":"Multi-series with color encoding"},{"location":"reference/views/charts/linemark/#step-chart-for-discrete-events","text":"import nib chart = nib . Chart ( data = state_changes , marks = [ nib . LineMark ( x = \"time\" , y = \"state\" , interpolation = nib . InterpolationMethod . STEP_END , foreground_style = \"#F59E0B\" , ), ], width = 400 , height = 200 , )","title":"Step chart for discrete events"},{"location":"reference/views/charts/pointmark/","text":"Displays individual data points as symbols, ideal for scatter plots and showing relationships between two quantitative variables. Each point can be customized with different shapes, sizes, and colors. PointMark is commonly used for scatter plots, bubble charts (with size encoding), and adding data point markers to other chart types. PointMark is used inside a Chart container as one of the marks entries. Constructor \u00b6 nib . PointMark ( x , y , foreground_style = None , symbol = None , symbol_size = None , opacity = None , ) Parameters \u00b6 Parameter Type Default Description x str \\| PlottableField required Data field for the x-axis position. y str \\| PlottableField required Data field for the y-axis position. foreground_style str \\| PlottableField None Point fill color. Accepts hex strings, named colors, or a PlottableField to color points by category. symbol SymbolShape \\| str \\| PlottableField None Shape of the point marker. Use a SymbolShape enum ( CIRCLE , SQUARE , TRIANGLE , DIAMOND , CROSS , PLUS , PENTAGON , HEXAGON ), a string, or a PlottableField to vary symbols by data category. symbol_size float None Size of the symbol in square points. Larger values create bigger markers. Uses system default when not specified. opacity float None Opacity from 0.0 to 1.0. Useful for dense scatter plots where points overlap. Examples \u00b6 Basic scatter plot \u00b6 import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"height\" : 165 , \"weight\" : 60 }, { \"height\" : 170 , \"weight\" : 72 }, { \"height\" : 175 , \"weight\" : 80 }, { \"height\" : 180 , \"weight\" : 85 }, { \"height\" : 160 , \"weight\" : 55 }, ], marks = [ nib . PointMark ( x = \"height\" , y = \"weight\" )], x_axis = nib . ChartAxis ( label = \"Height (cm)\" ), y_axis = nib . ChartAxis ( label = \"Weight (kg)\" ), width = 300 , height = 250 , ) app . build ( chart ) nib . run ( main ) Colored by category \u00b6 import nib data = [ { \"x\" : 5.1 , \"y\" : 3.5 , \"species\" : \"Setosa\" }, { \"x\" : 7.0 , \"y\" : 3.2 , \"species\" : \"Versicolor\" }, { \"x\" : 6.3 , \"y\" : 3.3 , \"species\" : \"Virginica\" }, ] chart = nib . Chart ( data = data , marks = [ nib . PointMark ( x = \"x\" , y = \"y\" , foreground_style = nib . PlottableField ( \"species\" ), ), ], legend = nib . ChartLegend ( position = \"bottom\" ), width = 400 , height = 300 , ) Custom symbols and size \u00b6 import nib chart = nib . Chart ( data = measurements , marks = [ nib . PointMark ( x = \"x\" , y = \"y\" , symbol = nib . SymbolShape . DIAMOND , symbol_size = 100 , foreground_style = \"#EF4444\" , ), ], width = 350 , height = 250 , ) Symbols varying by data \u00b6 import nib chart = nib . Chart ( data = multi_category_data , marks = [ nib . PointMark ( x = \"x\" , y = \"y\" , symbol = nib . PlottableField ( \"category\" ), foreground_style = nib . PlottableField ( \"category\" ), ), ], width = 400 , height = 300 , )","title":"PointMark"},{"location":"reference/views/charts/pointmark/#constructor","text":"nib . PointMark ( x , y , foreground_style = None , symbol = None , symbol_size = None , opacity = None , )","title":"Constructor"},{"location":"reference/views/charts/pointmark/#parameters","text":"Parameter Type Default Description x str \\| PlottableField required Data field for the x-axis position. y str \\| PlottableField required Data field for the y-axis position. foreground_style str \\| PlottableField None Point fill color. Accepts hex strings, named colors, or a PlottableField to color points by category. symbol SymbolShape \\| str \\| PlottableField None Shape of the point marker. Use a SymbolShape enum ( CIRCLE , SQUARE , TRIANGLE , DIAMOND , CROSS , PLUS , PENTAGON , HEXAGON ), a string, or a PlottableField to vary symbols by data category. symbol_size float None Size of the symbol in square points. Larger values create bigger markers. Uses system default when not specified. opacity float None Opacity from 0.0 to 1.0. Useful for dense scatter plots where points overlap.","title":"Parameters"},{"location":"reference/views/charts/pointmark/#examples","text":"","title":"Examples"},{"location":"reference/views/charts/pointmark/#basic-scatter-plot","text":"import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"height\" : 165 , \"weight\" : 60 }, { \"height\" : 170 , \"weight\" : 72 }, { \"height\" : 175 , \"weight\" : 80 }, { \"height\" : 180 , \"weight\" : 85 }, { \"height\" : 160 , \"weight\" : 55 }, ], marks = [ nib . PointMark ( x = \"height\" , y = \"weight\" )], x_axis = nib . ChartAxis ( label = \"Height (cm)\" ), y_axis = nib . ChartAxis ( label = \"Weight (kg)\" ), width = 300 , height = 250 , ) app . build ( chart ) nib . run ( main )","title":"Basic scatter plot"},{"location":"reference/views/charts/pointmark/#colored-by-category","text":"import nib data = [ { \"x\" : 5.1 , \"y\" : 3.5 , \"species\" : \"Setosa\" }, { \"x\" : 7.0 , \"y\" : 3.2 , \"species\" : \"Versicolor\" }, { \"x\" : 6.3 , \"y\" : 3.3 , \"species\" : \"Virginica\" }, ] chart = nib . Chart ( data = data , marks = [ nib . PointMark ( x = \"x\" , y = \"y\" , foreground_style = nib . PlottableField ( \"species\" ), ), ], legend = nib . ChartLegend ( position = \"bottom\" ), width = 400 , height = 300 , )","title":"Colored by category"},{"location":"reference/views/charts/pointmark/#custom-symbols-and-size","text":"import nib chart = nib . Chart ( data = measurements , marks = [ nib . PointMark ( x = \"x\" , y = \"y\" , symbol = nib . SymbolShape . DIAMOND , symbol_size = 100 , foreground_style = \"#EF4444\" , ), ], width = 350 , height = 250 , )","title":"Custom symbols and size"},{"location":"reference/views/charts/pointmark/#symbols-varying-by-data","text":"import nib chart = nib . Chart ( data = multi_category_data , marks = [ nib . PointMark ( x = \"x\" , y = \"y\" , symbol = nib . PlottableField ( \"category\" ), foreground_style = nib . PlottableField ( \"category\" ), ), ], width = 400 , height = 300 , )","title":"Symbols varying by data"},{"location":"reference/views/charts/rectmark/","text":"Draws filled rectangles defined by their bounds in data space. RectMark is ideal for heatmaps, Gantt charts, range visualizations, and other grid-based charts where each cell represents a data value. Rectangles can be positioned using center points ( x , y ) for automatic sizing, or explicit bounds ( x_start / x_end , y_start / y_end ) for precise control. RectMark is used inside a Chart container as one of the marks entries. Constructor \u00b6 nib . RectMark ( x = None , x_start = None , x_end = None , y = None , y_start = None , y_end = None , foreground_style = None , corner_radius = None , opacity = None , ) Parameters \u00b6 Parameter Type Default Description x str \\| PlottableField None Data field for the x-axis center position. Used for categorical grids where cell width is determined automatically. x_start str \\| PlottableField None Data field for the left edge of the rectangle. x_end str \\| PlottableField None Data field for the right edge of the rectangle. y str \\| PlottableField None Data field for the y-axis center position. Used for categorical grids where cell height is determined automatically. y_start str \\| PlottableField None Data field for the bottom edge of the rectangle. y_end str \\| PlottableField None Data field for the top edge of the rectangle. foreground_style str \\| PlottableField None Fill color. Accepts hex strings, named colors, or a PlottableField to encode data values as colors (essential for heatmaps). corner_radius float None Radius for rounded corners in points. opacity float None Opacity from 0.0 to 1.0. Examples \u00b6 Heatmap \u00b6 import nib data = [ { \"weekday\" : \"Mon\" , \"hour\" : \"9am\" , \"intensity\" : \"high\" }, { \"weekday\" : \"Mon\" , \"hour\" : \"12pm\" , \"intensity\" : \"medium\" }, { \"weekday\" : \"Tue\" , \"hour\" : \"9am\" , \"intensity\" : \"low\" }, { \"weekday\" : \"Tue\" , \"hour\" : \"12pm\" , \"intensity\" : \"high\" }, ] chart = nib . Chart ( data = data , marks = [ nib . RectMark ( x = \"weekday\" , y = \"hour\" , foreground_style = nib . PlottableField ( \"intensity\" ), ), ], width = 300 , height = 200 , ) Gantt chart (range chart) \u00b6 import nib tasks = [ { \"task\" : \"Design\" , \"start\" : 0 , \"end\" : 3 , \"status\" : \"complete\" }, { \"task\" : \"Develop\" , \"start\" : 2 , \"end\" : 7 , \"status\" : \"in-progress\" }, { \"task\" : \"Test\" , \"start\" : 6 , \"end\" : 9 , \"status\" : \"pending\" }, ] chart = nib . Chart ( data = tasks , marks = [ nib . RectMark ( x_start = \"start\" , x_end = \"end\" , y = \"task\" , foreground_style = nib . PlottableField ( \"status\" ), corner_radius = 4 , ), ], legend = nib . ChartLegend ( position = \"bottom\" ), width = 400 , height = 200 , ) Calendar heatmap cells \u00b6 import nib chart = nib . Chart ( data = calendar_data , marks = [ nib . RectMark ( x = \"week\" , y = \"day_of_week\" , foreground_style = nib . PlottableField ( \"contributions\" ), corner_radius = 2 , ), ], width = 500 , height = 150 , )","title":"RectMark"},{"location":"reference/views/charts/rectmark/#constructor","text":"nib . RectMark ( x = None , x_start = None , x_end = None , y = None , y_start = None , y_end = None , foreground_style = None , corner_radius = None , opacity = None , )","title":"Constructor"},{"location":"reference/views/charts/rectmark/#parameters","text":"Parameter Type Default Description x str \\| PlottableField None Data field for the x-axis center position. Used for categorical grids where cell width is determined automatically. x_start str \\| PlottableField None Data field for the left edge of the rectangle. x_end str \\| PlottableField None Data field for the right edge of the rectangle. y str \\| PlottableField None Data field for the y-axis center position. Used for categorical grids where cell height is determined automatically. y_start str \\| PlottableField None Data field for the bottom edge of the rectangle. y_end str \\| PlottableField None Data field for the top edge of the rectangle. foreground_style str \\| PlottableField None Fill color. Accepts hex strings, named colors, or a PlottableField to encode data values as colors (essential for heatmaps). corner_radius float None Radius for rounded corners in points. opacity float None Opacity from 0.0 to 1.0.","title":"Parameters"},{"location":"reference/views/charts/rectmark/#examples","text":"","title":"Examples"},{"location":"reference/views/charts/rectmark/#heatmap","text":"import nib data = [ { \"weekday\" : \"Mon\" , \"hour\" : \"9am\" , \"intensity\" : \"high\" }, { \"weekday\" : \"Mon\" , \"hour\" : \"12pm\" , \"intensity\" : \"medium\" }, { \"weekday\" : \"Tue\" , \"hour\" : \"9am\" , \"intensity\" : \"low\" }, { \"weekday\" : \"Tue\" , \"hour\" : \"12pm\" , \"intensity\" : \"high\" }, ] chart = nib . Chart ( data = data , marks = [ nib . RectMark ( x = \"weekday\" , y = \"hour\" , foreground_style = nib . PlottableField ( \"intensity\" ), ), ], width = 300 , height = 200 , )","title":"Heatmap"},{"location":"reference/views/charts/rectmark/#gantt-chart-range-chart","text":"import nib tasks = [ { \"task\" : \"Design\" , \"start\" : 0 , \"end\" : 3 , \"status\" : \"complete\" }, { \"task\" : \"Develop\" , \"start\" : 2 , \"end\" : 7 , \"status\" : \"in-progress\" }, { \"task\" : \"Test\" , \"start\" : 6 , \"end\" : 9 , \"status\" : \"pending\" }, ] chart = nib . Chart ( data = tasks , marks = [ nib . RectMark ( x_start = \"start\" , x_end = \"end\" , y = \"task\" , foreground_style = nib . PlottableField ( \"status\" ), corner_radius = 4 , ), ], legend = nib . ChartLegend ( position = \"bottom\" ), width = 400 , height = 200 , )","title":"Gantt chart (range chart)"},{"location":"reference/views/charts/rectmark/#calendar-heatmap-cells","text":"import nib chart = nib . Chart ( data = calendar_data , marks = [ nib . RectMark ( x = \"week\" , y = \"day_of_week\" , foreground_style = nib . PlottableField ( \"contributions\" ), corner_radius = 2 , ), ], width = 500 , height = 150 , )","title":"Calendar heatmap cells"},{"location":"reference/views/charts/rulemark/","text":"Draws straight reference lines across the chart. Rules are useful for showing thresholds, averages, targets, or event markers. They can be horizontal (fixed y, spanning x) or vertical (fixed x, spanning y), and optionally bounded to create line segments. Values can be static numbers or data field references. When a field name is provided, one rule is drawn per data row. RuleMark is used inside a Chart container as one of the marks entries. Constructor \u00b6 nib . RuleMark ( x = None , x_start = None , x_end = None , y = None , y_start = None , y_end = None , foreground_style = None , line_width = None , opacity = None , ) Parameters \u00b6 Parameter Type Default Description x str \\| float \\| PlottableField \\| PlottableValue None X-axis position for a vertical rule. Can be a static number, a field name, PlottableField , or PlottableValue . x_start str \\| float \\| PlottableField \\| PlottableValue None Starting x position for a bounded horizontal rule segment. x_end str \\| float \\| PlottableField \\| PlottableValue None Ending x position for a bounded horizontal rule segment. y str \\| float \\| PlottableField \\| PlottableValue None Y-axis position for a horizontal rule. Can be a static number, a field name, PlottableField , or PlottableValue . y_start str \\| float \\| PlottableField \\| PlottableValue None Starting y position for a bounded vertical rule segment. y_end str \\| float \\| PlottableField \\| PlottableValue None Ending y position for a bounded vertical rule segment. foreground_style str \\| PlottableField None Line color. Accepts hex strings, named colors, or a PlottableField . line_width float None Width of the rule line in points. opacity float None Opacity from 0.0 to 1.0. Examples \u00b6 Horizontal reference line (target) \u00b6 import nib chart = nib . Chart ( data = [ { \"month\" : \"Jan\" , \"sales\" : 80 }, { \"month\" : \"Feb\" , \"sales\" : 120 }, { \"month\" : \"Mar\" , \"sales\" : 95 }, ], marks = [ nib . BarMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" ), nib . RuleMark ( y = 100 , foreground_style = \"#EF4444\" , line_width = 2 ), ], width = 350 , height = 200 , ) Vertical reference line (event marker) \u00b6 import nib chart = nib . Chart ( data = time_series_data , marks = [ nib . LineMark ( x = \"date\" , y = \"value\" ), nib . RuleMark ( x = \"2024-06-15\" , foreground_style = \"#6366F1\" ), ], width = 400 , height = 250 , ) Bounded horizontal segment \u00b6 import nib chart = nib . Chart ( data = monthly_data , marks = [ nib . LineMark ( x = \"month\" , y = \"value\" ), nib . RuleMark ( y = 50 , x_start = \"Jan\" , x_end = \"Jun\" , foreground_style = \"#10B981\" , line_width = 1.5 , ), ], width = 400 , height = 200 , ) Labeled reference line with PlottableValue \u00b6 import nib chart = nib . Chart ( data = sales_data , marks = [ nib . BarMark ( x = \"month\" , y = \"sales\" ), nib . RuleMark ( y = nib . PlottableValue ( 100 , label = \"Target\" ), foreground_style = \"#F59E0B\" , line_width = 1.5 , ), ], width = 400 , height = 250 , )","title":"RuleMark"},{"location":"reference/views/charts/rulemark/#constructor","text":"nib . RuleMark ( x = None , x_start = None , x_end = None , y = None , y_start = None , y_end = None , foreground_style = None , line_width = None , opacity = None , )","title":"Constructor"},{"location":"reference/views/charts/rulemark/#parameters","text":"Parameter Type Default Description x str \\| float \\| PlottableField \\| PlottableValue None X-axis position for a vertical rule. Can be a static number, a field name, PlottableField , or PlottableValue . x_start str \\| float \\| PlottableField \\| PlottableValue None Starting x position for a bounded horizontal rule segment. x_end str \\| float \\| PlottableField \\| PlottableValue None Ending x position for a bounded horizontal rule segment. y str \\| float \\| PlottableField \\| PlottableValue None Y-axis position for a horizontal rule. Can be a static number, a field name, PlottableField , or PlottableValue . y_start str \\| float \\| PlottableField \\| PlottableValue None Starting y position for a bounded vertical rule segment. y_end str \\| float \\| PlottableField \\| PlottableValue None Ending y position for a bounded vertical rule segment. foreground_style str \\| PlottableField None Line color. Accepts hex strings, named colors, or a PlottableField . line_width float None Width of the rule line in points. opacity float None Opacity from 0.0 to 1.0.","title":"Parameters"},{"location":"reference/views/charts/rulemark/#examples","text":"","title":"Examples"},{"location":"reference/views/charts/rulemark/#horizontal-reference-line-target","text":"import nib chart = nib . Chart ( data = [ { \"month\" : \"Jan\" , \"sales\" : 80 }, { \"month\" : \"Feb\" , \"sales\" : 120 }, { \"month\" : \"Mar\" , \"sales\" : 95 }, ], marks = [ nib . BarMark ( x = \"month\" , y = \"sales\" , foreground_style = \"#3B82F6\" ), nib . RuleMark ( y = 100 , foreground_style = \"#EF4444\" , line_width = 2 ), ], width = 350 , height = 200 , )","title":"Horizontal reference line (target)"},{"location":"reference/views/charts/rulemark/#vertical-reference-line-event-marker","text":"import nib chart = nib . Chart ( data = time_series_data , marks = [ nib . LineMark ( x = \"date\" , y = \"value\" ), nib . RuleMark ( x = \"2024-06-15\" , foreground_style = \"#6366F1\" ), ], width = 400 , height = 250 , )","title":"Vertical reference line (event marker)"},{"location":"reference/views/charts/rulemark/#bounded-horizontal-segment","text":"import nib chart = nib . Chart ( data = monthly_data , marks = [ nib . LineMark ( x = \"month\" , y = \"value\" ), nib . RuleMark ( y = 50 , x_start = \"Jan\" , x_end = \"Jun\" , foreground_style = \"#10B981\" , line_width = 1.5 , ), ], width = 400 , height = 200 , )","title":"Bounded horizontal segment"},{"location":"reference/views/charts/rulemark/#labeled-reference-line-with-plottablevalue","text":"import nib chart = nib . Chart ( data = sales_data , marks = [ nib . BarMark ( x = \"month\" , y = \"sales\" ), nib . RuleMark ( y = nib . PlottableValue ( 100 , label = \"Target\" ), foreground_style = \"#F59E0B\" , line_width = 1.5 , ), ], width = 400 , height = 250 , )","title":"Labeled reference line with PlottableValue"},{"location":"reference/views/charts/sectormark/","text":"Creates circular segments (wedges) based on angular data, suited for pie and donut charts showing proportional relationships and part-to-whole comparisons. Setting inner_radius to a value greater than zero creates a donut chart instead of a pie chart. The angle field determines the size of each sector proportionally. Use foreground_style with a PlottableField to automatically assign colors to each category. SectorMark is used inside a Chart container as one of the marks entries. Constructor \u00b6 nib . SectorMark ( angle , foreground_style = None , inner_radius = None , outer_radius = None , angle_start = None , corner_radius = None , opacity = None , ) Parameters \u00b6 Parameter Type Default Description angle str \\| PlottableField required Data field containing values that determine sector sizes. Values are treated proportionally -- a sector with value 20 is twice as large as one with value 10. foreground_style str \\| PlottableField None Fill color for sectors. Use a PlottableField with a categorical field to automatically assign different colors to each sector. inner_radius float None Inner radius in points. Set to 0 (or omit) for a pie chart. Set to a positive value for a donut chart. outer_radius float None Outer radius in points. Defaults to automatic sizing based on available space. angle_start str \\| PlottableField None Data field or value for the starting angle of sectors. Rarely needed; use for custom sector positioning. corner_radius float None Radius for rounded sector corners in points. Creates a softer visual appearance. opacity float None Opacity from 0.0 to 1.0. Examples \u00b6 Pie chart \u00b6 import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"category\" : \"Electronics\" , \"value\" : 42 }, { \"category\" : \"Clothing\" , \"value\" : 28 }, { \"category\" : \"Food\" , \"value\" : 20 }, { \"category\" : \"Books\" , \"value\" : 10 }, ], marks = [ nib . SectorMark ( angle = \"value\" , foreground_style = nib . PlottableField ( \"category\" ), ), ], legend = nib . ChartLegend ( position = \"bottom\" ), width = 300 , height = 300 , ) app . build ( chart ) nib . run ( main ) Donut chart \u00b6 import nib chart = nib . Chart ( data = [ { \"segment\" : \"Used\" , \"percentage\" : 65 }, { \"segment\" : \"Free\" , \"percentage\" : 35 }, ], marks = [ nib . SectorMark ( angle = \"percentage\" , foreground_style = nib . PlottableField ( \"segment\" ), inner_radius = 50 , outer_radius = 100 , ), ], width = 250 , height = 250 , ) Styled donut with rounded segments \u00b6 import nib chart = nib . Chart ( data = [ { \"region\" : \"North\" , \"sales\" : 120 }, { \"region\" : \"South\" , \"sales\" : 90 }, { \"region\" : \"East\" , \"sales\" : 75 }, { \"region\" : \"West\" , \"sales\" : 110 }, ], marks = [ nib . SectorMark ( angle = \"sales\" , foreground_style = nib . PlottableField ( \"region\" ), inner_radius = 40 , outer_radius = 80 , corner_radius = 4 , ), ], legend = nib . ChartLegend ( position = \"trailing\" , title = \"Region\" ), width = 300 , height = 300 , padding = 16 , )","title":"SectorMark"},{"location":"reference/views/charts/sectormark/#constructor","text":"nib . SectorMark ( angle , foreground_style = None , inner_radius = None , outer_radius = None , angle_start = None , corner_radius = None , opacity = None , )","title":"Constructor"},{"location":"reference/views/charts/sectormark/#parameters","text":"Parameter Type Default Description angle str \\| PlottableField required Data field containing values that determine sector sizes. Values are treated proportionally -- a sector with value 20 is twice as large as one with value 10. foreground_style str \\| PlottableField None Fill color for sectors. Use a PlottableField with a categorical field to automatically assign different colors to each sector. inner_radius float None Inner radius in points. Set to 0 (or omit) for a pie chart. Set to a positive value for a donut chart. outer_radius float None Outer radius in points. Defaults to automatic sizing based on available space. angle_start str \\| PlottableField None Data field or value for the starting angle of sectors. Rarely needed; use for custom sector positioning. corner_radius float None Radius for rounded sector corners in points. Creates a softer visual appearance. opacity float None Opacity from 0.0 to 1.0.","title":"Parameters"},{"location":"reference/views/charts/sectormark/#examples","text":"","title":"Examples"},{"location":"reference/views/charts/sectormark/#pie-chart","text":"import nib def main ( app : nib . App ): chart = nib . Chart ( data = [ { \"category\" : \"Electronics\" , \"value\" : 42 }, { \"category\" : \"Clothing\" , \"value\" : 28 }, { \"category\" : \"Food\" , \"value\" : 20 }, { \"category\" : \"Books\" , \"value\" : 10 }, ], marks = [ nib . SectorMark ( angle = \"value\" , foreground_style = nib . PlottableField ( \"category\" ), ), ], legend = nib . ChartLegend ( position = \"bottom\" ), width = 300 , height = 300 , ) app . build ( chart ) nib . run ( main )","title":"Pie chart"},{"location":"reference/views/charts/sectormark/#donut-chart","text":"import nib chart = nib . Chart ( data = [ { \"segment\" : \"Used\" , \"percentage\" : 65 }, { \"segment\" : \"Free\" , \"percentage\" : 35 }, ], marks = [ nib . SectorMark ( angle = \"percentage\" , foreground_style = nib . PlottableField ( \"segment\" ), inner_radius = 50 , outer_radius = 100 , ), ], width = 250 , height = 250 , )","title":"Donut chart"},{"location":"reference/views/charts/sectormark/#styled-donut-with-rounded-segments","text":"import nib chart = nib . Chart ( data = [ { \"region\" : \"North\" , \"sales\" : 120 }, { \"region\" : \"South\" , \"sales\" : 90 }, { \"region\" : \"East\" , \"sales\" : 75 }, { \"region\" : \"West\" , \"sales\" : 110 }, ], marks = [ nib . SectorMark ( angle = \"sales\" , foreground_style = nib . PlottableField ( \"region\" ), inner_radius = 40 , outer_radius = 80 , corner_radius = 4 , ), ], legend = nib . ChartLegend ( position = \"trailing\" , title = \"Region\" ), width = 300 , height = 300 , padding = 16 , )","title":"Styled donut with rounded segments"},{"location":"reference/views/controls/","text":"Control views are interactive UI elements for displaying content, capturing user input, and triggering actions. All controls inherit from View and accept common modifiers such as width , height , padding , background , foreground_color , opacity , corner_radius , font , animation , and more as constructor parameters. Display \u00b6 View Description Text Displays one or more lines of read-only text with optional rich text support. Label Combines an SF Symbol icon with a text title. Image Displays an image from a URL, local file, asset reference, or raw bytes. Video Plays video content from a URL or local file with playback controls. Markdown Renders CommonMark/GitHub Flavored Markdown text natively. ProgressView Shows task progress as a determinate bar or indeterminate spinner. Gauge Displays a value within a bounded range using various gauge styles. Divider A thin visual separator line that adapts to its container orientation. Input \u00b6 View Description Button An interactive control that triggers a callback when tapped. TextField A single-line text input field with placeholder and change callbacks. SecureField A single-line text input that masks entered characters for passwords. TextEditor A multi-line text editing area for longer content. Toggle A binary switch for toggling between on and off states. Slider A horizontal track with a draggable thumb for selecting a numeric value. Picker A selection control for choosing one option from a set. Rich Content \u00b6 View Description Table Displays structured data in rows and columns with sorting and selection. Map An interactive MapKit map with markers, annotations, and overlays. WebView Embeds web content from a URL or raw HTML using WKWebView. CameraPreview Displays a live camera feed from a connected device. Actions \u00b6 View Description Link A clickable element that opens a URL in the default browser. ShareLink A button that presents the native macOS share sheet.","title":"Index"},{"location":"reference/views/controls/#display","text":"View Description Text Displays one or more lines of read-only text with optional rich text support. Label Combines an SF Symbol icon with a text title. Image Displays an image from a URL, local file, asset reference, or raw bytes. Video Plays video content from a URL or local file with playback controls. Markdown Renders CommonMark/GitHub Flavored Markdown text natively. ProgressView Shows task progress as a determinate bar or indeterminate spinner. Gauge Displays a value within a bounded range using various gauge styles. Divider A thin visual separator line that adapts to its container orientation.","title":"Display"},{"location":"reference/views/controls/#input","text":"View Description Button An interactive control that triggers a callback when tapped. TextField A single-line text input field with placeholder and change callbacks. SecureField A single-line text input that masks entered characters for passwords. TextEditor A multi-line text editing area for longer content. Toggle A binary switch for toggling between on and off states. Slider A horizontal track with a draggable thumb for selecting a numeric value. Picker A selection control for choosing one option from a set.","title":"Input"},{"location":"reference/views/controls/#rich-content","text":"View Description Table Displays structured data in rows and columns with sorting and selection. Map An interactive MapKit map with markers, annotations, and overlays. WebView Embeds web content from a URL or raw HTML using WKWebView. CameraPreview Displays a live camera feed from a connected device.","title":"Rich Content"},{"location":"reference/views/controls/#actions","text":"View Description Link A clickable element that opens a URL in the default browser. ShareLink A button that presents the native macOS share sheet.","title":"Actions"},{"location":"reference/views/controls/button/","text":"A control that initiates an action when tapped. Buttons can display a text label, an SF Symbol icon, or fully custom content views. Various styles and semantic roles can be applied to communicate the button's purpose. Constructor \u00b6 nib . Button ( label = None , icon = None , action = None , content = None , style = None , role = None , border_shape = None , control_size = None , label_style = None , tint = None , disabled = False , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description label str None Text displayed on the button. icon str None SF Symbol name for the button icon (e.g., \"gear\" , \"trash\" , \"star.fill\" ). Can be combined with label . action Callable None Callback function executed when the button is tapped. Should accept no arguments. content View None Custom view to use as button content. Alternative to label / icon . style ButtonStyle \\| str None Visual style. Options: ButtonStyle.automatic , ButtonStyle.bordered , ButtonStyle.borderedProminent , ButtonStyle.borderless , ButtonStyle.plain . role ButtonRole \\| str None Semantic role affecting appearance. Options: ButtonRole.destructive (red tint), ButtonRole.cancel . border_shape BorderShape \\| str None Shape of the button border. Options: BorderShape.automatic , BorderShape.capsule , BorderShape.roundedRectangle . control_size ControlSize \\| str None Size of the control. Options: ControlSize.mini , ControlSize.small , ControlSize.regular , ControlSize.large . label_style LabelStyle \\| str None Style for the label content. Options: LabelStyle.automatic , LabelStyle.titleOnly , LabelStyle.iconOnly , LabelStyle.titleAndIcon . tint Color \\| str None Tint color for the button. Accepts a Color enum, hex string, or RGB tuple. disabled bool False Whether the button is disabled and non-interactive. **modifiers Common view modifiers: padding , background , foreground_color , opacity , corner_radius , etc. Examples \u00b6 Simple text button \u00b6 import nib def main ( app : nib . App ): def greet (): print ( \"Hello!\" ) app . build ( nib . Button ( \"Say Hello\" , action = greet , padding = 16 ) ) nib . run ( main ) Styled buttons with roles \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Button ( \"Save\" , icon = \"checkmark\" , action = lambda : print ( \"Saved\" ), style = nib . ButtonStyle . borderedProminent , control_size = nib . ControlSize . large , ), nib . Button ( \"Delete\" , icon = \"trash\" , action = lambda : print ( \"Deleted\" ), role = nib . ButtonRole . destructive , style = nib . ButtonStyle . bordered , ), nib . Button ( \"Cancel\" , action = lambda : print ( \"Cancelled\" ), role = nib . ButtonRole . cancel , ), ], spacing = 8 , padding = 16 ) ) nib . run ( main ) Button with custom content \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Button ( content = nib . HStack ( controls = [ nib . Image ( system_name = \"star.fill\" ), nib . Text ( \"Favorite\" ), ], spacing = 4 ), action = lambda : print ( \"Favorited\" ), style = nib . ButtonStyle . bordered , tint = nib . Color . YELLOW , padding = 16 , ) ) nib . run ( main )","title":"Button"},{"location":"reference/views/controls/button/#constructor","text":"nib . Button ( label = None , icon = None , action = None , content = None , style = None , role = None , border_shape = None , control_size = None , label_style = None , tint = None , disabled = False , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/button/#parameters","text":"Parameter Type Default Description label str None Text displayed on the button. icon str None SF Symbol name for the button icon (e.g., \"gear\" , \"trash\" , \"star.fill\" ). Can be combined with label . action Callable None Callback function executed when the button is tapped. Should accept no arguments. content View None Custom view to use as button content. Alternative to label / icon . style ButtonStyle \\| str None Visual style. Options: ButtonStyle.automatic , ButtonStyle.bordered , ButtonStyle.borderedProminent , ButtonStyle.borderless , ButtonStyle.plain . role ButtonRole \\| str None Semantic role affecting appearance. Options: ButtonRole.destructive (red tint), ButtonRole.cancel . border_shape BorderShape \\| str None Shape of the button border. Options: BorderShape.automatic , BorderShape.capsule , BorderShape.roundedRectangle . control_size ControlSize \\| str None Size of the control. Options: ControlSize.mini , ControlSize.small , ControlSize.regular , ControlSize.large . label_style LabelStyle \\| str None Style for the label content. Options: LabelStyle.automatic , LabelStyle.titleOnly , LabelStyle.iconOnly , LabelStyle.titleAndIcon . tint Color \\| str None Tint color for the button. Accepts a Color enum, hex string, or RGB tuple. disabled bool False Whether the button is disabled and non-interactive. **modifiers Common view modifiers: padding , background , foreground_color , opacity , corner_radius , etc.","title":"Parameters"},{"location":"reference/views/controls/button/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/button/#simple-text-button","text":"import nib def main ( app : nib . App ): def greet (): print ( \"Hello!\" ) app . build ( nib . Button ( \"Say Hello\" , action = greet , padding = 16 ) ) nib . run ( main )","title":"Simple text button"},{"location":"reference/views/controls/button/#styled-buttons-with-roles","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Button ( \"Save\" , icon = \"checkmark\" , action = lambda : print ( \"Saved\" ), style = nib . ButtonStyle . borderedProminent , control_size = nib . ControlSize . large , ), nib . Button ( \"Delete\" , icon = \"trash\" , action = lambda : print ( \"Deleted\" ), role = nib . ButtonRole . destructive , style = nib . ButtonStyle . bordered , ), nib . Button ( \"Cancel\" , action = lambda : print ( \"Cancelled\" ), role = nib . ButtonRole . cancel , ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Styled buttons with roles"},{"location":"reference/views/controls/button/#button-with-custom-content","text":"import nib def main ( app : nib . App ): app . build ( nib . Button ( content = nib . HStack ( controls = [ nib . Image ( system_name = \"star.fill\" ), nib . Text ( \"Favorite\" ), ], spacing = 4 ), action = lambda : print ( \"Favorited\" ), style = nib . ButtonStyle . bordered , tint = nib . Color . YELLOW , padding = 16 , ) ) nib . run ( main )","title":"Button with custom content"},{"location":"reference/views/controls/camerapreview/","text":"A view that displays a live camera feed from a connected device. CameraPreview shows a real-time video preview, useful for camera-enabled applications, barcode scanning, or video conferencing interfaces. Constructor \u00b6 nib . CameraPreview ( device_id = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description device_id str None Camera device ID. When None , the system default camera is used. Obtain device IDs from Camera.list_devices() . **modifiers Common view modifiers: width , height , corner_radius , opacity , padding , etc. Mutable Properties \u00b6 Property Type Description device_id str Get or set the camera device ID. Examples \u00b6 Default camera preview \u00b6 import nib def main ( app : nib . App ): app . build ( nib . CameraPreview ( width = 320 , height = 240 , corner_radius = 12 , padding = 16 , ) ) nib . run ( main ) Camera preview with device selection \u00b6 import nib from nib.services import Camera def main ( app : nib . App ): preview = nib . CameraPreview ( width = 320 , height = 240 , corner_radius = 8 , ) devices = Camera . list_devices () options = [( d [ \"id\" ], d [ \"name\" ]) for d in devices ] app . build ( nib . VStack ( controls = [ nib . Picker ( \"Camera\" , selection = options [ 0 ][ 0 ] if options else \"\" , options = options , on_change = lambda device_id : setattr ( preview , \"device_id\" , device_id ), ), preview , ], spacing = 12 , padding = 16 ) ) nib . run ( main ) Camera feed with overlay \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . CameraPreview ( width = 400 , height = 300 , corner_radius = 12 , ), nib . VStack ( controls = [ nib . Spacer (), nib . Text ( \"Live\" , foreground_color = nib . Color . WHITE , font = nib . Font . CAPTION , padding = { \"horizontal\" : 8 , \"vertical\" : 4 }, background = nib . Color . RED , corner_radius = 4 , ), ], padding = 12 ), ], padding = 16 ) ) nib . run ( main )","title":"CameraPreview"},{"location":"reference/views/controls/camerapreview/#constructor","text":"nib . CameraPreview ( device_id = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/camerapreview/#parameters","text":"Parameter Type Default Description device_id str None Camera device ID. When None , the system default camera is used. Obtain device IDs from Camera.list_devices() . **modifiers Common view modifiers: width , height , corner_radius , opacity , padding , etc.","title":"Parameters"},{"location":"reference/views/controls/camerapreview/#mutable-properties","text":"Property Type Description device_id str Get or set the camera device ID.","title":"Mutable Properties"},{"location":"reference/views/controls/camerapreview/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/camerapreview/#default-camera-preview","text":"import nib def main ( app : nib . App ): app . build ( nib . CameraPreview ( width = 320 , height = 240 , corner_radius = 12 , padding = 16 , ) ) nib . run ( main )","title":"Default camera preview"},{"location":"reference/views/controls/camerapreview/#camera-preview-with-device-selection","text":"import nib from nib.services import Camera def main ( app : nib . App ): preview = nib . CameraPreview ( width = 320 , height = 240 , corner_radius = 8 , ) devices = Camera . list_devices () options = [( d [ \"id\" ], d [ \"name\" ]) for d in devices ] app . build ( nib . VStack ( controls = [ nib . Picker ( \"Camera\" , selection = options [ 0 ][ 0 ] if options else \"\" , options = options , on_change = lambda device_id : setattr ( preview , \"device_id\" , device_id ), ), preview , ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Camera preview with device selection"},{"location":"reference/views/controls/camerapreview/#camera-feed-with-overlay","text":"import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . CameraPreview ( width = 400 , height = 300 , corner_radius = 12 , ), nib . VStack ( controls = [ nib . Spacer (), nib . Text ( \"Live\" , foreground_color = nib . Color . WHITE , font = nib . Font . CAPTION , padding = { \"horizontal\" : 8 , \"vertical\" : 4 }, background = nib . Color . RED , corner_radius = 4 , ), ], padding = 12 ), ], padding = 16 ) ) nib . run ( main )","title":"Camera feed with overlay"},{"location":"reference/views/controls/divider/","text":"A thin visual separator line used to organize content into sections. In a VStack , the divider appears as a horizontal line. In an HStack , it appears as a vertical line. The divider automatically sizes itself to fit its container. Divider has no view-specific parameters -- it accepts only common view modifiers. Constructor \u00b6 nib . Divider ( ** modifiers ) Parameters \u00b6 Parameter Type Default Description **modifiers Common view modifiers. Commonly used: foreground_color (line color), padding (space around the divider), opacity (transparency). Examples \u00b6 Basic section divider \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Section 1\" ), nib . Divider (), nib . Text ( \"Section 2\" ), nib . Divider (), nib . Text ( \"Section 3\" ), ], spacing = 8 , padding = 16 ) ) nib . run ( main ) Styled divider with color and spacing \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Header\" , style = nib . TextStyle . TITLE ), nib . Divider ( foreground_color = nib . Color . BLUE , padding = { \"vertical\" : 8 }, ), nib . Text ( \"Content goes below the divider.\" ), ], spacing = 4 , padding = 16 ) ) nib . run ( main ) Subtle list separator \u00b6 import nib def main ( app : nib . App ): items = [ \"Apple\" , \"Banana\" , \"Cherry\" , \"Date\" ] controls = [] for i , item in enumerate ( items ): controls . append ( nib . Text ( item , padding = { \"vertical\" : 4 })) if i < len ( items ) - 1 : controls . append ( nib . Divider ( foreground_color = \"#E0E0E0\" , opacity = 0.6 ) ) app . build ( nib . VStack ( controls = controls , spacing = 0 , padding = 16 ) ) nib . run ( main )","title":"Divider"},{"location":"reference/views/controls/divider/#constructor","text":"nib . Divider ( ** modifiers )","title":"Constructor"},{"location":"reference/views/controls/divider/#parameters","text":"Parameter Type Default Description **modifiers Common view modifiers. Commonly used: foreground_color (line color), padding (space around the divider), opacity (transparency).","title":"Parameters"},{"location":"reference/views/controls/divider/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/divider/#basic-section-divider","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Section 1\" ), nib . Divider (), nib . Text ( \"Section 2\" ), nib . Divider (), nib . Text ( \"Section 3\" ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Basic section divider"},{"location":"reference/views/controls/divider/#styled-divider-with-color-and-spacing","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Header\" , style = nib . TextStyle . TITLE ), nib . Divider ( foreground_color = nib . Color . BLUE , padding = { \"vertical\" : 8 }, ), nib . Text ( \"Content goes below the divider.\" ), ], spacing = 4 , padding = 16 ) ) nib . run ( main )","title":"Styled divider with color and spacing"},{"location":"reference/views/controls/divider/#subtle-list-separator","text":"import nib def main ( app : nib . App ): items = [ \"Apple\" , \"Banana\" , \"Cherry\" , \"Date\" ] controls = [] for i , item in enumerate ( items ): controls . append ( nib . Text ( item , padding = { \"vertical\" : 4 })) if i < len ( items ) - 1 : controls . append ( nib . Divider ( foreground_color = \"#E0E0E0\" , opacity = 0.6 ) ) app . build ( nib . VStack ( controls = controls , spacing = 0 , padding = 16 ) ) nib . run ( main )","title":"Subtle list separator"},{"location":"reference/views/controls/gauge/","text":"A view that displays a value within a bounded range, ideal for showing battery levels, CPU usage, memory consumption, or any bounded numeric measurement. Gauge supports multiple visual styles and accepts either strings or custom views for its labels. Constructor \u00b6 nib . Gauge ( value = 0.0 , min_value = 0.0 , max_value = 1.0 , label = None , current_value_label = None , min_value_label = None , max_value_label = None , style = GaugeStyle . AUTOMATIC , tint = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description value float 0.0 Current gauge value. min_value float 0.0 Minimum value of the range. max_value float 1.0 Maximum value of the range. label str \\| View None Label describing the gauge. Accepts a plain string or a custom View . current_value_label str \\| View None Label showing the current value. Accepts a plain string or a custom View . min_value_label str \\| View None Label for the minimum end of the range. Accepts a plain string or a custom View . max_value_label str \\| View None Label for the maximum end of the range. Accepts a plain string or a custom View . style str GaugeStyle.AUTOMATIC Gauge style. Options: GaugeStyle.AUTOMATIC , GaugeStyle.LINEAR_CAPACITY , GaugeStyle.CIRCULAR_CAPACITY , GaugeStyle.ACCESSORY_LINEAR , GaugeStyle.ACCESSORY_LINEAR_CAPACITY , GaugeStyle.ACCESSORY_CIRCULAR , GaugeStyle.ACCESSORY_CIRCULAR_CAPACITY . tint Color \\| str None Tint color for the gauge fill. Accepts a Color enum or hex string. **modifiers Common view modifiers: padding , background , opacity , width , height , etc. Mutable Properties \u00b6 Property Type Description value float Get or set the current gauge value. Triggers a UI update. label str \\| View Get or set the gauge label. current_value_label str \\| View Get or set the current value label. min_value_label str \\| View Get or set the minimum value label. max_value_label str \\| View Get or set the maximum value label. style str Get or set the gauge style. tint Color \\| str Get or set the tint color. Examples \u00b6 Simple battery gauge \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Gauge ( value = 0.75 , label = \"Battery\" , current_value_label = \"75%\" , style = nib . GaugeStyle . LINEAR_CAPACITY , tint = nib . Color . GREEN , padding = 16 , ) ) nib . run ( main ) Circular gauge with view labels \u00b6 import nib def main ( app : nib . App ): cpu_usage = 62 app . build ( nib . Gauge ( value = cpu_usage / 100 , label = nib . Label ( \"CPU\" , icon = \"cpu\" ), current_value_label = nib . Text ( f \" { cpu_usage } %\" , font = nib . Font . HEADLINE ), min_value_label = nib . Image ( system_name = \"tortoise\" ), max_value_label = nib . Image ( system_name = \"hare\" ), style = nib . GaugeStyle . ACCESSORY_CIRCULAR , tint = nib . Color . BLUE , padding = 16 , ) ) nib . run ( main ) Download progress gauge \u00b6 import nib def main ( app : nib . App ): progress = 0.4 app . build ( nib . Gauge ( value = progress , label = \"Download\" , current_value_label = f \" { int ( progress * 100 ) } %\" , min_value_label = \"0%\" , max_value_label = \"100%\" , style = nib . GaugeStyle . LINEAR_CAPACITY , tint = nib . Color . BLUE , padding = 16 , width = 250 , ) ) nib . run ( main )","title":"Gauge"},{"location":"reference/views/controls/gauge/#constructor","text":"nib . Gauge ( value = 0.0 , min_value = 0.0 , max_value = 1.0 , label = None , current_value_label = None , min_value_label = None , max_value_label = None , style = GaugeStyle . AUTOMATIC , tint = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/gauge/#parameters","text":"Parameter Type Default Description value float 0.0 Current gauge value. min_value float 0.0 Minimum value of the range. max_value float 1.0 Maximum value of the range. label str \\| View None Label describing the gauge. Accepts a plain string or a custom View . current_value_label str \\| View None Label showing the current value. Accepts a plain string or a custom View . min_value_label str \\| View None Label for the minimum end of the range. Accepts a plain string or a custom View . max_value_label str \\| View None Label for the maximum end of the range. Accepts a plain string or a custom View . style str GaugeStyle.AUTOMATIC Gauge style. Options: GaugeStyle.AUTOMATIC , GaugeStyle.LINEAR_CAPACITY , GaugeStyle.CIRCULAR_CAPACITY , GaugeStyle.ACCESSORY_LINEAR , GaugeStyle.ACCESSORY_LINEAR_CAPACITY , GaugeStyle.ACCESSORY_CIRCULAR , GaugeStyle.ACCESSORY_CIRCULAR_CAPACITY . tint Color \\| str None Tint color for the gauge fill. Accepts a Color enum or hex string. **modifiers Common view modifiers: padding , background , opacity , width , height , etc.","title":"Parameters"},{"location":"reference/views/controls/gauge/#mutable-properties","text":"Property Type Description value float Get or set the current gauge value. Triggers a UI update. label str \\| View Get or set the gauge label. current_value_label str \\| View Get or set the current value label. min_value_label str \\| View Get or set the minimum value label. max_value_label str \\| View Get or set the maximum value label. style str Get or set the gauge style. tint Color \\| str Get or set the tint color.","title":"Mutable Properties"},{"location":"reference/views/controls/gauge/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/gauge/#simple-battery-gauge","text":"import nib def main ( app : nib . App ): app . build ( nib . Gauge ( value = 0.75 , label = \"Battery\" , current_value_label = \"75%\" , style = nib . GaugeStyle . LINEAR_CAPACITY , tint = nib . Color . GREEN , padding = 16 , ) ) nib . run ( main )","title":"Simple battery gauge"},{"location":"reference/views/controls/gauge/#circular-gauge-with-view-labels","text":"import nib def main ( app : nib . App ): cpu_usage = 62 app . build ( nib . Gauge ( value = cpu_usage / 100 , label = nib . Label ( \"CPU\" , icon = \"cpu\" ), current_value_label = nib . Text ( f \" { cpu_usage } %\" , font = nib . Font . HEADLINE ), min_value_label = nib . Image ( system_name = \"tortoise\" ), max_value_label = nib . Image ( system_name = \"hare\" ), style = nib . GaugeStyle . ACCESSORY_CIRCULAR , tint = nib . Color . BLUE , padding = 16 , ) ) nib . run ( main )","title":"Circular gauge with view labels"},{"location":"reference/views/controls/gauge/#download-progress-gauge","text":"import nib def main ( app : nib . App ): progress = 0.4 app . build ( nib . Gauge ( value = progress , label = \"Download\" , current_value_label = f \" { int ( progress * 100 ) } %\" , min_value_label = \"0%\" , max_value_label = \"100%\" , style = nib . GaugeStyle . LINEAR_CAPACITY , tint = nib . Color . BLUE , padding = 16 , width = 250 , ) ) nib . run ( main )","title":"Download progress gauge"},{"location":"reference/views/controls/image/","text":"A view that displays an image from various sources: remote URLs, local file paths, project asset references, or raw bytes. The src property is reactive -- changing it triggers an immediate UI update with the new image. Constructor \u00b6 nib . Image ( src = None , label = None , aspect_ratio = None , antialiased = True , blur = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description src str \\| bytes None Image source. Supports remote URLs ( \"https://...\" ), absolute file paths ( \"/path/to/image.png\" ), asset references ( \"logo.png\" resolves to assets/logo.png ), or raw bytes containing image data. label str None Accessibility label describing the image content. Important for VoiceOver and assistive technologies. aspect_ratio ContentMode \\| str None How to scale the image within its frame. Options: ContentMode.FIT (fit within bounds, may letterbox), ContentMode.FILL (fill bounds, may crop). antialiased bool True Whether to apply antialiasing for smoother edges. Set to False for pixel-art or sharp edges. blur float None Blur radius to apply to the image. Higher values create a stronger blur effect. **modifiers Common view modifiers: width , height , corner_radius , clip_shape , opacity , shadow_color , shadow_radius , padding , etc. Mutable Properties \u00b6 Property Type Description src str \\| bytes Get or set the image source. Setting triggers a UI update. label str Get or set the accessibility label. Setting triggers a UI update. Examples \u00b6 Remote image with aspect ratio \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Image ( src = \"https://example.com/photo.jpg\" , label = \"Landscape photo\" , aspect_ratio = nib . ContentMode . FIT , width = 300 , height = 200 , corner_radius = 12 , padding = 16 , ) ) nib . run ( main ) Circular avatar from asset \u00b6 import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Image ( src = \"avatar.png\" , label = \"User avatar\" , aspect_ratio = nib . ContentMode . FILL , clip_shape = nib . Circle (), width = 48 , height = 48 , ), nib . VStack ( controls = [ nib . Text ( \"Jane Doe\" , font = nib . Font . HEADLINE ), nib . Text ( \"Online\" , foreground_color = nib . Color . GREEN , font = nib . Font . CAPTION ), ], spacing = 2 ), ], spacing = 12 , padding = 16 ) ) nib . run ( main ) Reactive image switching \u00b6 import nib def main ( app : nib . App ): images = [ \"https://example.com/photo1.jpg\" , \"https://example.com/photo2.jpg\" , \"https://example.com/photo3.jpg\" , ] index = [ 0 ] photo = nib . Image ( src = images [ 0 ], label = \"Photo\" , aspect_ratio = nib . ContentMode . FIT , width = 250 , height = 180 , corner_radius = 8 , ) def next_image (): index [ 0 ] = ( index [ 0 ] + 1 ) % len ( images ) photo . src = images [ index [ 0 ]] app . build ( nib . VStack ( controls = [ photo , nib . Button ( \"Next\" , action = next_image ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Image"},{"location":"reference/views/controls/image/#constructor","text":"nib . Image ( src = None , label = None , aspect_ratio = None , antialiased = True , blur = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/image/#parameters","text":"Parameter Type Default Description src str \\| bytes None Image source. Supports remote URLs ( \"https://...\" ), absolute file paths ( \"/path/to/image.png\" ), asset references ( \"logo.png\" resolves to assets/logo.png ), or raw bytes containing image data. label str None Accessibility label describing the image content. Important for VoiceOver and assistive technologies. aspect_ratio ContentMode \\| str None How to scale the image within its frame. Options: ContentMode.FIT (fit within bounds, may letterbox), ContentMode.FILL (fill bounds, may crop). antialiased bool True Whether to apply antialiasing for smoother edges. Set to False for pixel-art or sharp edges. blur float None Blur radius to apply to the image. Higher values create a stronger blur effect. **modifiers Common view modifiers: width , height , corner_radius , clip_shape , opacity , shadow_color , shadow_radius , padding , etc.","title":"Parameters"},{"location":"reference/views/controls/image/#mutable-properties","text":"Property Type Description src str \\| bytes Get or set the image source. Setting triggers a UI update. label str Get or set the accessibility label. Setting triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/controls/image/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/image/#remote-image-with-aspect-ratio","text":"import nib def main ( app : nib . App ): app . build ( nib . Image ( src = \"https://example.com/photo.jpg\" , label = \"Landscape photo\" , aspect_ratio = nib . ContentMode . FIT , width = 300 , height = 200 , corner_radius = 12 , padding = 16 , ) ) nib . run ( main )","title":"Remote image with aspect ratio"},{"location":"reference/views/controls/image/#circular-avatar-from-asset","text":"import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Image ( src = \"avatar.png\" , label = \"User avatar\" , aspect_ratio = nib . ContentMode . FILL , clip_shape = nib . Circle (), width = 48 , height = 48 , ), nib . VStack ( controls = [ nib . Text ( \"Jane Doe\" , font = nib . Font . HEADLINE ), nib . Text ( \"Online\" , foreground_color = nib . Color . GREEN , font = nib . Font . CAPTION ), ], spacing = 2 ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Circular avatar from asset"},{"location":"reference/views/controls/image/#reactive-image-switching","text":"import nib def main ( app : nib . App ): images = [ \"https://example.com/photo1.jpg\" , \"https://example.com/photo2.jpg\" , \"https://example.com/photo3.jpg\" , ] index = [ 0 ] photo = nib . Image ( src = images [ 0 ], label = \"Photo\" , aspect_ratio = nib . ContentMode . FIT , width = 250 , height = 180 , corner_radius = 8 , ) def next_image (): index [ 0 ] = ( index [ 0 ] + 1 ) % len ( images ) photo . src = images [ index [ 0 ]] app . build ( nib . VStack ( controls = [ photo , nib . Button ( \"Next\" , action = next_image ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Reactive image switching"},{"location":"reference/views/controls/label/","text":"A view that combines an SF Symbol icon with a text title, following Apple's Human Interface Guidelines. Labels are commonly used in navigation items, list rows, and menu entries. For full control over appearance, custom views can be provided instead of strings. Constructor \u00b6 nib . Label ( title = None , icon = None , title_view = None , icon_view = None , style = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description title str None Text string displayed as the label title. For custom styling, use title_view instead. icon str None SF Symbol name for the icon (e.g., \"gear\" , \"star.fill\" , \"bell.badge\" ). For custom icons, use icon_view instead. title_view View None Custom view to use as the title. Alternative to title . icon_view View None Custom view to use as the icon. Alternative to icon . style LabelStyle \\| str None Determines which parts of the label are shown. Options: LabelStyle.automatic , LabelStyle.titleOnly , LabelStyle.iconOnly , LabelStyle.titleAndIcon . **modifiers Common view modifiers: padding , background , foreground_color , font , opacity , etc. Examples \u00b6 Basic label with icon \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Label ( \"Settings\" , icon = \"gear\" ), nib . Label ( \"Favorites\" , icon = \"star.fill\" , foreground_color = nib . Color . YELLOW ), nib . Label ( \"Notifications\" , icon = \"bell.badge\" ), ], spacing = 12 , padding = 16 ) ) nib . run ( main ) Label style variations \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Label ( \"Title and Icon\" , icon = \"person.fill\" , style = nib . LabelStyle . titleAndIcon ), nib . Label ( \"Title Only\" , icon = \"person.fill\" , style = nib . LabelStyle . titleOnly ), nib . Label ( \"Icon Only\" , icon = \"person.fill\" , style = nib . LabelStyle . iconOnly ), ], spacing = 12 , padding = 16 ) ) nib . run ( main ) Label with custom content views \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Label ( title_view = nib . Text ( \"Premium\" , font = nib . Font . HEADLINE , foreground_color = nib . Color . YELLOW ), icon_view = nib . Image ( system_name = \"crown.fill\" , foreground_color = nib . Color . YELLOW ), padding = 16 , ) ) nib . run ( main )","title":"Label"},{"location":"reference/views/controls/label/#constructor","text":"nib . Label ( title = None , icon = None , title_view = None , icon_view = None , style = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/label/#parameters","text":"Parameter Type Default Description title str None Text string displayed as the label title. For custom styling, use title_view instead. icon str None SF Symbol name for the icon (e.g., \"gear\" , \"star.fill\" , \"bell.badge\" ). For custom icons, use icon_view instead. title_view View None Custom view to use as the title. Alternative to title . icon_view View None Custom view to use as the icon. Alternative to icon . style LabelStyle \\| str None Determines which parts of the label are shown. Options: LabelStyle.automatic , LabelStyle.titleOnly , LabelStyle.iconOnly , LabelStyle.titleAndIcon . **modifiers Common view modifiers: padding , background , foreground_color , font , opacity , etc.","title":"Parameters"},{"location":"reference/views/controls/label/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/label/#basic-label-with-icon","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Label ( \"Settings\" , icon = \"gear\" ), nib . Label ( \"Favorites\" , icon = \"star.fill\" , foreground_color = nib . Color . YELLOW ), nib . Label ( \"Notifications\" , icon = \"bell.badge\" ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Basic label with icon"},{"location":"reference/views/controls/label/#label-style-variations","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Label ( \"Title and Icon\" , icon = \"person.fill\" , style = nib . LabelStyle . titleAndIcon ), nib . Label ( \"Title Only\" , icon = \"person.fill\" , style = nib . LabelStyle . titleOnly ), nib . Label ( \"Icon Only\" , icon = \"person.fill\" , style = nib . LabelStyle . iconOnly ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Label style variations"},{"location":"reference/views/controls/label/#label-with-custom-content-views","text":"import nib def main ( app : nib . App ): app . build ( nib . Label ( title_view = nib . Text ( \"Premium\" , font = nib . Font . HEADLINE , foreground_color = nib . Color . YELLOW ), icon_view = nib . Image ( system_name = \"crown.fill\" , foreground_color = nib . Color . YELLOW ), padding = 16 , ) ) nib . run ( main )","title":"Label with custom content views"},{"location":"reference/views/controls/link/","text":"A clickable element that opens a URL in the system's default web browser when tapped. Links can display a simple text title or custom content views. The URL can use any scheme supported by the system, including https:// , mailto: , and tel: . Constructor \u00b6 nib . Link ( title = None , url = \"\" , content = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description title str None Text to display as the link. For custom content, use the content parameter instead. url str \"\" The URL to open when the link is tapped. Supports http:// , https:// , mailto: , tel: , and other system URL schemes. content View None Custom view to display as the link content. Alternative to title . **modifiers Common view modifiers: foreground_color , font , padding , opacity , etc. Examples \u00b6 Simple text link \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Link ( \"Visit our website\" , url = \"https://example.com\" , foreground_color = nib . Color . BLUE , ), nib . Link ( \"Contact Support\" , url = \"mailto:support@example.com\" , foreground_color = nib . Color . BLUE , ), ], spacing = 12 , padding = 16 ) ) nib . run ( main ) Link with custom content \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Link ( url = \"https://github.com/user/repo\" , content = nib . HStack ( controls = [ nib . Image ( system_name = \"globe\" ), nib . Text ( \"View on GitHub\" , font = nib . Font . BODY ), ], spacing = 4 ), foreground_color = nib . Color . BLUE , padding = 16 , ) ) nib . run ( main ) Links in a settings list \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"About\" , style = nib . TextStyle . TITLE ), nib . Link ( \"Documentation\" , url = \"https://docs.example.com\" ), nib . Link ( \"Release Notes\" , url = \"https://example.com/releases\" ), nib . Link ( \"Privacy Policy\" , url = \"https://example.com/privacy\" ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Link"},{"location":"reference/views/controls/link/#constructor","text":"nib . Link ( title = None , url = \"\" , content = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/link/#parameters","text":"Parameter Type Default Description title str None Text to display as the link. For custom content, use the content parameter instead. url str \"\" The URL to open when the link is tapped. Supports http:// , https:// , mailto: , tel: , and other system URL schemes. content View None Custom view to display as the link content. Alternative to title . **modifiers Common view modifiers: foreground_color , font , padding , opacity , etc.","title":"Parameters"},{"location":"reference/views/controls/link/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/link/#simple-text-link","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Link ( \"Visit our website\" , url = \"https://example.com\" , foreground_color = nib . Color . BLUE , ), nib . Link ( \"Contact Support\" , url = \"mailto:support@example.com\" , foreground_color = nib . Color . BLUE , ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Simple text link"},{"location":"reference/views/controls/link/#link-with-custom-content","text":"import nib def main ( app : nib . App ): app . build ( nib . Link ( url = \"https://github.com/user/repo\" , content = nib . HStack ( controls = [ nib . Image ( system_name = \"globe\" ), nib . Text ( \"View on GitHub\" , font = nib . Font . BODY ), ], spacing = 4 ), foreground_color = nib . Color . BLUE , padding = 16 , ) ) nib . run ( main )","title":"Link with custom content"},{"location":"reference/views/controls/link/#links-in-a-settings-list","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"About\" , style = nib . TextStyle . TITLE ), nib . Link ( \"Documentation\" , url = \"https://docs.example.com\" ), nib . Link ( \"Release Notes\" , url = \"https://example.com/releases\" ), nib . Link ( \"Privacy Policy\" , url = \"https://example.com/privacy\" ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Links in a settings list"},{"location":"reference/views/controls/map/","text":"An interactive map view powered by MapKit. Map supports markers, custom annotations with arbitrary views, circle overlays, polylines, polygons, multiple map styles, and user location display. The center coordinates and zoom level are reactive. Constructor \u00b6 nib . Map ( latitude = 0.0 , longitude = 0.0 , zoom = 0.1 , markers = None , annotations = None , circles = None , polylines = None , polygons = None , style = None , elevation = None , shows_traffic = False , shows_compass = False , shows_scale = False , shows_user_location = False , interaction_modes = None , on_region_change = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description latitude float 0.0 Center latitude coordinate (-90 to 90). longitude float 0.0 Center longitude coordinate (-180 to 180). zoom float 0.1 Zoom level as coordinate span in degrees. Smaller values zoom in more. Use 0.01 for a neighborhood, 0.1 for a city, 1.0 for a country. markers list[MapMarker] None List of MapMarker objects to display as pins. annotations list[MapAnnotation] None List of MapAnnotation objects for custom view content at coordinates. circles list[MapCircle] None List of MapCircle overlays. polylines list[MapPolyline] None List of MapPolyline line paths. polygons list[MapPolygon] None List of MapPolygon filled areas. style MapStyle \\| str None Map style. Options: MapStyle.STANDARD , MapStyle.SATELLITE , MapStyle.HYBRID , MapStyle.IMAGERY . elevation str None Elevation style. Options: \"flat\" , \"realistic\" (3D terrain). shows_traffic bool False Whether to show traffic conditions overlay. shows_compass bool False Whether to show the compass control. shows_scale bool False Whether to show the scale indicator. shows_user_location bool False Whether to show the user's current location. interaction_modes list[MapInteractionMode \\| str] None Allowed interactions. If None , all are enabled. Options: \"pan\" , \"zoom\" , \"rotate\" , \"pitch\" , \"all\" . on_region_change Callable[[float, float, float], None] None Callback when the visible region changes. Receives (latitude, longitude, zoom) . **modifiers Common view modifiers: width , height , corner_radius , padding , etc. Mutable Properties \u00b6 Property Type Description latitude float Get or set the center latitude. Triggers a UI update. longitude float Get or set the center longitude. Triggers a UI update. zoom float Get or set the zoom level. Triggers a UI update. markers list[MapMarker] Get or set the markers. Triggers a UI update. Methods \u00b6 Method Description add_marker(marker) Add a single MapMarker to the map. clear_markers() Remove all markers from the map. Helper Classes \u00b6 MapMarker \u00b6 A pin marker displayed at specific coordinates. nib . MapMarker ( latitude , longitude , title = None , subtitle = None , tint = None , system_image = None , ) Parameter Type Default Description latitude float (required) Latitude coordinate. longitude float (required) Longitude coordinate. title str None Title displayed with the marker. subtitle str None Subtitle displayed below the title. tint Color \\| str None Tint color for the marker. system_image str None SF Symbol name for a custom marker icon. MapAnnotation \u00b6 A custom view displayed at specific coordinates. nib . MapAnnotation ( latitude , longitude , content , anchor = \"bottom\" , ) Parameter Type Default Description latitude float (required) Latitude coordinate. longitude float (required) Longitude coordinate. content View (required) The view to display at this location. anchor str \"bottom\" Anchor point. Options: \"center\" , \"bottom\" , \"top\" . MapCircle \u00b6 A circular overlay on the map. nib . MapCircle ( latitude , longitude , radius , fill = None , stroke = None , stroke_width = None , ) Parameter Type Default Description latitude float (required) Center latitude. longitude float (required) Center longitude. radius float (required) Radius in meters. fill Color \\| str None Fill color. stroke Color \\| str None Stroke color. stroke_width float None Stroke width. MapPolyline \u00b6 A line connecting multiple coordinates. nib . MapPolyline ( coordinates , stroke = None , stroke_width = None , ) Parameter Type Default Description coordinates list[tuple[float, float]] (required) List of (latitude, longitude) tuples. stroke Color \\| str None Stroke color. stroke_width float None Line width. MapPolygon \u00b6 A filled polygon on the map. nib . MapPolygon ( coordinates , fill = None , stroke = None , stroke_width = None , ) Parameter Type Default Description coordinates list[tuple[float, float]] (required) List of (latitude, longitude) tuples defining vertices. fill Color \\| str None Fill color. stroke Color \\| str None Stroke color. stroke_width float None Border width. Examples \u00b6 Map with markers \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Map ( latitude = 37.7749 , longitude =- 122.4194 , zoom = 0.05 , markers = [ nib . MapMarker ( 37.7749 , - 122.4194 , title = \"San Francisco\" , tint = nib . Color . RED ), nib . MapMarker ( 37.8044 , - 122.2712 , title = \"Oakland\" , tint = nib . Color . BLUE ), ], style = nib . MapStyle . STANDARD , shows_compass = True , width = 400 , height = 300 , corner_radius = 12 , padding = 16 , ) ) nib . run ( main ) Map with custom annotations \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Map ( latitude = 48.8566 , longitude = 2.3522 , zoom = 0.02 , annotations = [ nib . MapAnnotation ( latitude = 48.8584 , longitude = 2.2945 , content = nib . VStack ( controls = [ nib . Image ( system_name = \"star.fill\" , foreground_color = nib . Color . YELLOW ), nib . Text ( \"Eiffel Tower\" , font = nib . Font . CAPTION ), ], padding = 4 , background = nib . Color . WHITE , corner_radius = 6 ), ), ], style = nib . MapStyle . HYBRID , width = 400 , height = 300 , corner_radius = 12 , padding = 16 , ) ) nib . run ( main ) Map with overlays \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Map ( latitude = 37.7749 , longitude =- 122.4194 , zoom = 0.05 , circles = [ nib . MapCircle ( 37.7749 , - 122.4194 , radius = 1000 , fill = \"#0000FF33\" , stroke = nib . Color . BLUE , stroke_width = 2 ), ], polylines = [ nib . MapPolyline ( coordinates = [ ( 37.7749 , - 122.4194 ), ( 37.8044 , - 122.2712 ), ( 37.8716 , - 122.2727 ), ], stroke = nib . Color . RED , stroke_width = 3 , ), ], width = 400 , height = 300 , padding = 16 , ) ) nib . run ( main )","title":"Map"},{"location":"reference/views/controls/map/#constructor","text":"nib . Map ( latitude = 0.0 , longitude = 0.0 , zoom = 0.1 , markers = None , annotations = None , circles = None , polylines = None , polygons = None , style = None , elevation = None , shows_traffic = False , shows_compass = False , shows_scale = False , shows_user_location = False , interaction_modes = None , on_region_change = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/map/#parameters","text":"Parameter Type Default Description latitude float 0.0 Center latitude coordinate (-90 to 90). longitude float 0.0 Center longitude coordinate (-180 to 180). zoom float 0.1 Zoom level as coordinate span in degrees. Smaller values zoom in more. Use 0.01 for a neighborhood, 0.1 for a city, 1.0 for a country. markers list[MapMarker] None List of MapMarker objects to display as pins. annotations list[MapAnnotation] None List of MapAnnotation objects for custom view content at coordinates. circles list[MapCircle] None List of MapCircle overlays. polylines list[MapPolyline] None List of MapPolyline line paths. polygons list[MapPolygon] None List of MapPolygon filled areas. style MapStyle \\| str None Map style. Options: MapStyle.STANDARD , MapStyle.SATELLITE , MapStyle.HYBRID , MapStyle.IMAGERY . elevation str None Elevation style. Options: \"flat\" , \"realistic\" (3D terrain). shows_traffic bool False Whether to show traffic conditions overlay. shows_compass bool False Whether to show the compass control. shows_scale bool False Whether to show the scale indicator. shows_user_location bool False Whether to show the user's current location. interaction_modes list[MapInteractionMode \\| str] None Allowed interactions. If None , all are enabled. Options: \"pan\" , \"zoom\" , \"rotate\" , \"pitch\" , \"all\" . on_region_change Callable[[float, float, float], None] None Callback when the visible region changes. Receives (latitude, longitude, zoom) . **modifiers Common view modifiers: width , height , corner_radius , padding , etc.","title":"Parameters"},{"location":"reference/views/controls/map/#mutable-properties","text":"Property Type Description latitude float Get or set the center latitude. Triggers a UI update. longitude float Get or set the center longitude. Triggers a UI update. zoom float Get or set the zoom level. Triggers a UI update. markers list[MapMarker] Get or set the markers. Triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/controls/map/#methods","text":"Method Description add_marker(marker) Add a single MapMarker to the map. clear_markers() Remove all markers from the map.","title":"Methods"},{"location":"reference/views/controls/map/#helper-classes","text":"","title":"Helper Classes"},{"location":"reference/views/controls/map/#mapmarker","text":"A pin marker displayed at specific coordinates. nib . MapMarker ( latitude , longitude , title = None , subtitle = None , tint = None , system_image = None , ) Parameter Type Default Description latitude float (required) Latitude coordinate. longitude float (required) Longitude coordinate. title str None Title displayed with the marker. subtitle str None Subtitle displayed below the title. tint Color \\| str None Tint color for the marker. system_image str None SF Symbol name for a custom marker icon.","title":"MapMarker"},{"location":"reference/views/controls/map/#mapannotation","text":"A custom view displayed at specific coordinates. nib . MapAnnotation ( latitude , longitude , content , anchor = \"bottom\" , ) Parameter Type Default Description latitude float (required) Latitude coordinate. longitude float (required) Longitude coordinate. content View (required) The view to display at this location. anchor str \"bottom\" Anchor point. Options: \"center\" , \"bottom\" , \"top\" .","title":"MapAnnotation"},{"location":"reference/views/controls/map/#mapcircle","text":"A circular overlay on the map. nib . MapCircle ( latitude , longitude , radius , fill = None , stroke = None , stroke_width = None , ) Parameter Type Default Description latitude float (required) Center latitude. longitude float (required) Center longitude. radius float (required) Radius in meters. fill Color \\| str None Fill color. stroke Color \\| str None Stroke color. stroke_width float None Stroke width.","title":"MapCircle"},{"location":"reference/views/controls/map/#mappolyline","text":"A line connecting multiple coordinates. nib . MapPolyline ( coordinates , stroke = None , stroke_width = None , ) Parameter Type Default Description coordinates list[tuple[float, float]] (required) List of (latitude, longitude) tuples. stroke Color \\| str None Stroke color. stroke_width float None Line width.","title":"MapPolyline"},{"location":"reference/views/controls/map/#mappolygon","text":"A filled polygon on the map. nib . MapPolygon ( coordinates , fill = None , stroke = None , stroke_width = None , ) Parameter Type Default Description coordinates list[tuple[float, float]] (required) List of (latitude, longitude) tuples defining vertices. fill Color \\| str None Fill color. stroke Color \\| str None Stroke color. stroke_width float None Border width.","title":"MapPolygon"},{"location":"reference/views/controls/map/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/map/#map-with-markers","text":"import nib def main ( app : nib . App ): app . build ( nib . Map ( latitude = 37.7749 , longitude =- 122.4194 , zoom = 0.05 , markers = [ nib . MapMarker ( 37.7749 , - 122.4194 , title = \"San Francisco\" , tint = nib . Color . RED ), nib . MapMarker ( 37.8044 , - 122.2712 , title = \"Oakland\" , tint = nib . Color . BLUE ), ], style = nib . MapStyle . STANDARD , shows_compass = True , width = 400 , height = 300 , corner_radius = 12 , padding = 16 , ) ) nib . run ( main )","title":"Map with markers"},{"location":"reference/views/controls/map/#map-with-custom-annotations","text":"import nib def main ( app : nib . App ): app . build ( nib . Map ( latitude = 48.8566 , longitude = 2.3522 , zoom = 0.02 , annotations = [ nib . MapAnnotation ( latitude = 48.8584 , longitude = 2.2945 , content = nib . VStack ( controls = [ nib . Image ( system_name = \"star.fill\" , foreground_color = nib . Color . YELLOW ), nib . Text ( \"Eiffel Tower\" , font = nib . Font . CAPTION ), ], padding = 4 , background = nib . Color . WHITE , corner_radius = 6 ), ), ], style = nib . MapStyle . HYBRID , width = 400 , height = 300 , corner_radius = 12 , padding = 16 , ) ) nib . run ( main )","title":"Map with custom annotations"},{"location":"reference/views/controls/map/#map-with-overlays","text":"import nib def main ( app : nib . App ): app . build ( nib . Map ( latitude = 37.7749 , longitude =- 122.4194 , zoom = 0.05 , circles = [ nib . MapCircle ( 37.7749 , - 122.4194 , radius = 1000 , fill = \"#0000FF33\" , stroke = nib . Color . BLUE , stroke_width = 2 ), ], polylines = [ nib . MapPolyline ( coordinates = [ ( 37.7749 , - 122.4194 ), ( 37.8044 , - 122.2712 ), ( 37.8716 , - 122.2727 ), ], stroke = nib . Color . RED , stroke_width = 3 , ), ], width = 400 , height = 300 , padding = 16 , ) ) nib . run ( main )","title":"Map with overlays"},{"location":"reference/views/controls/markdown/","text":"A view that renders CommonMark/GitHub Flavored Markdown text natively. Supports headings, bold, italic, strikethrough, inline code, fenced code blocks, links, lists, blockquotes, task lists, tables, and images. The content property is reactive -- changing it triggers an immediate UI update. Constructor \u00b6 nib . Markdown ( content , theme = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description content str (required) The Markdown string to render. theme str None Optional theme name. Options: \"basic\" (default), \"gitHub\" , \"docC\" . **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc. Mutable Properties \u00b6 Property Type Description content str Get or set the Markdown text. Setting triggers a UI update. theme str Get or set the rendering theme. Setting triggers a UI update. Examples \u00b6 Basic markdown rendering \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Markdown ( \"\"\" # Welcome This is **bold** and *italic* text. - Item one - Item two - Item three > A blockquote for emphasis. \"\"\" , padding = 16 , ) ) nib . run ( main ) Markdown with GitHub theme \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Markdown ( \"\"\" # Project README ## Installation ```bash pip install mypackage Usage \u00b6 Feature Status Auth Done API WIP See the docs for more. \"\"\", theme=\"gitHub\", padding=16, width=400, ) ) nib.run(main) ### Reactive markdown content ``` python import nib def main ( app : nib . App ): md = nib . Markdown ( \"# Counter: 0\" , padding = 16 ) count = [ 0 ] def increment (): count [ 0 ] += 1 md . content = f \"# Counter: { count [ 0 ] } \\n\\n Clicked ** { count [ 0 ] } ** times.\" app . build ( nib . VStack ( controls = [ md , nib . Button ( \"Increment\" , action = increment ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Markdown"},{"location":"reference/views/controls/markdown/#constructor","text":"nib . Markdown ( content , theme = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/markdown/#parameters","text":"Parameter Type Default Description content str (required) The Markdown string to render. theme str None Optional theme name. Options: \"basic\" (default), \"gitHub\" , \"docC\" . **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc.","title":"Parameters"},{"location":"reference/views/controls/markdown/#mutable-properties","text":"Property Type Description content str Get or set the Markdown text. Setting triggers a UI update. theme str Get or set the rendering theme. Setting triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/controls/markdown/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/markdown/#basic-markdown-rendering","text":"import nib def main ( app : nib . App ): app . build ( nib . Markdown ( \"\"\" # Welcome This is **bold** and *italic* text. - Item one - Item two - Item three > A blockquote for emphasis. \"\"\" , padding = 16 , ) ) nib . run ( main )","title":"Basic markdown rendering"},{"location":"reference/views/controls/markdown/#markdown-with-github-theme","text":"import nib def main ( app : nib . App ): app . build ( nib . Markdown ( \"\"\" # Project README ## Installation ```bash pip install mypackage","title":"Markdown with GitHub theme"},{"location":"reference/views/controls/markdown/#usage","text":"Feature Status Auth Done API WIP See the docs for more. \"\"\", theme=\"gitHub\", padding=16, width=400, ) ) nib.run(main) ### Reactive markdown content ``` python import nib def main ( app : nib . App ): md = nib . Markdown ( \"# Counter: 0\" , padding = 16 ) count = [ 0 ] def increment (): count [ 0 ] += 1 md . content = f \"# Counter: { count [ 0 ] } \\n\\n Clicked ** { count [ 0 ] } ** times.\" app . build ( nib . VStack ( controls = [ md , nib . Button ( \"Increment\" , action = increment ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Usage"},{"location":"reference/views/controls/picker/","text":"A selection control for choosing one option from a predefined set. The picker supports simple string options or (value, label) tuples for cases where internal values differ from display text. Multiple visual styles are available, including dropdown menus, segmented controls, and wheels. Constructor \u00b6 nib . Picker ( label = \"\" , selection = \"\" , options = None , on_change = None , style = None , disabled = False , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description label str \"\" Descriptive label for the picker. Displayed above or beside the options depending on the style. selection str \"\" Currently selected option value. Must match one of the values in the options list. options list[str] \\| list[tuple[str, str]] None Available options. Can be a list of strings (value equals label) or a list of (value, label) tuples for separate internal values and display text. on_change Callable[[str], None] None Callback called when the selection changes. Receives the newly selected value as a string. style PickerStyle \\| str None Visual style. Options: PickerStyle.automatic , PickerStyle.menu , PickerStyle.segmented , PickerStyle.wheel , PickerStyle.inline . disabled bool False Whether the picker is disabled and non-interactive. **modifiers Common view modifiers: padding , background , foreground_color , opacity , etc. Mutable Properties \u00b6 Property Type Description selection str Get or set the currently selected value. options list Get or set the list of available options. on_change Callable Get or set the selection change callback. Examples \u00b6 Dropdown menu picker \u00b6 import nib def main ( app : nib . App ): result = nib . Text ( \"Selected: Red\" ) app . build ( nib . VStack ( controls = [ nib . Picker ( \"Favorite Color\" , selection = \"Red\" , options = [ \"Red\" , \"Green\" , \"Blue\" , \"Yellow\" ], on_change = lambda v : setattr ( result , \"content\" , f \"Selected: { v } \" ), ), result , ], spacing = 12 , padding = 16 ) ) nib . run ( main ) Segmented control \u00b6 import nib def main ( app : nib . App ): content = nib . Text ( \"Showing Day view\" ) def switch_view ( mode : str ): content . content = f \"Showing { mode } view\" app . build ( nib . VStack ( controls = [ nib . Picker ( \"\" , selection = \"Day\" , options = [ \"Day\" , \"Week\" , \"Month\" ], on_change = switch_view , style = nib . PickerStyle . segmented , ), content , ], spacing = 12 , padding = 16 ) ) nib . run ( main ) Picker with value-label tuples \u00b6 import nib def main ( app : nib . App ): size_label = nib . Text ( \"Size: m\" ) app . build ( nib . VStack ( controls = [ nib . Picker ( \"T-Shirt Size\" , selection = \"m\" , options = [ ( \"xs\" , \"Extra Small\" ), ( \"s\" , \"Small\" ), ( \"m\" , \"Medium\" ), ( \"l\" , \"Large\" ), ( \"xl\" , \"Extra Large\" ), ], on_change = lambda v : setattr ( size_label , \"content\" , f \"Size: { v } \" ), style = nib . PickerStyle . menu , ), size_label , ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Picker"},{"location":"reference/views/controls/picker/#constructor","text":"nib . Picker ( label = \"\" , selection = \"\" , options = None , on_change = None , style = None , disabled = False , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/picker/#parameters","text":"Parameter Type Default Description label str \"\" Descriptive label for the picker. Displayed above or beside the options depending on the style. selection str \"\" Currently selected option value. Must match one of the values in the options list. options list[str] \\| list[tuple[str, str]] None Available options. Can be a list of strings (value equals label) or a list of (value, label) tuples for separate internal values and display text. on_change Callable[[str], None] None Callback called when the selection changes. Receives the newly selected value as a string. style PickerStyle \\| str None Visual style. Options: PickerStyle.automatic , PickerStyle.menu , PickerStyle.segmented , PickerStyle.wheel , PickerStyle.inline . disabled bool False Whether the picker is disabled and non-interactive. **modifiers Common view modifiers: padding , background , foreground_color , opacity , etc.","title":"Parameters"},{"location":"reference/views/controls/picker/#mutable-properties","text":"Property Type Description selection str Get or set the currently selected value. options list Get or set the list of available options. on_change Callable Get or set the selection change callback.","title":"Mutable Properties"},{"location":"reference/views/controls/picker/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/picker/#dropdown-menu-picker","text":"import nib def main ( app : nib . App ): result = nib . Text ( \"Selected: Red\" ) app . build ( nib . VStack ( controls = [ nib . Picker ( \"Favorite Color\" , selection = \"Red\" , options = [ \"Red\" , \"Green\" , \"Blue\" , \"Yellow\" ], on_change = lambda v : setattr ( result , \"content\" , f \"Selected: { v } \" ), ), result , ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Dropdown menu picker"},{"location":"reference/views/controls/picker/#segmented-control","text":"import nib def main ( app : nib . App ): content = nib . Text ( \"Showing Day view\" ) def switch_view ( mode : str ): content . content = f \"Showing { mode } view\" app . build ( nib . VStack ( controls = [ nib . Picker ( \"\" , selection = \"Day\" , options = [ \"Day\" , \"Week\" , \"Month\" ], on_change = switch_view , style = nib . PickerStyle . segmented , ), content , ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Segmented control"},{"location":"reference/views/controls/picker/#picker-with-value-label-tuples","text":"import nib def main ( app : nib . App ): size_label = nib . Text ( \"Size: m\" ) app . build ( nib . VStack ( controls = [ nib . Picker ( \"T-Shirt Size\" , selection = \"m\" , options = [ ( \"xs\" , \"Extra Small\" ), ( \"s\" , \"Small\" ), ( \"m\" , \"Medium\" ), ( \"l\" , \"Large\" ), ( \"xl\" , \"Extra Large\" ), ], on_change = lambda v : setattr ( size_label , \"content\" , f \"Size: { v } \" ), style = nib . PickerStyle . menu , ), size_label , ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Picker with value-label tuples"},{"location":"reference/views/controls/progressview/","text":"A view that shows the progress of an ongoing task. When value is None , an indeterminate spinner is displayed. When value is provided, a determinate progress bar shows the completion percentage as value / total . Constructor \u00b6 nib . ProgressView ( value = None , total = 1.0 , label = \"\" , style = None , tint = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description value float \\| None None Current progress value. When None , displays an indeterminate spinner. When set, shows a progress bar filled to value / total . total float 1.0 Maximum value representing 100% completion. Set to 100 for percentage values or the actual total for counts. label str \"\" Optional text label displayed alongside the progress indicator. style ProgressStyle \\| str None Visual style. Options: ProgressStyle.automatic , ProgressStyle.linear (horizontal bar), ProgressStyle.circular (ring indicator). tint Color \\| str None Tint color for the progress indicator fill. Accepts a Color enum, hex string, or RGB tuple. **modifiers Common view modifiers: padding , background , opacity , width , height , etc. Mutable Properties \u00b6 Property Type Description value float \\| None Get or set the progress value. Set to None for indeterminate mode. Triggers a UI update. progress float \\| None Get or set the progress as a fraction (0.0 to 1.0). Internally converts using total . total float Get or set the total value. Triggers a UI update. label str Get or set the progress label. Triggers a UI update. Examples \u00b6 Indeterminate loading spinner \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . ProgressView (), nib . Text ( \"Loading...\" ), ], spacing = 8 , padding = 16 ) ) nib . run ( main ) Determinate download progress \u00b6 import nib import threading , time def main ( app : nib . App ): progress = nib . ProgressView ( value = 0 , total = 100 , label = \"Downloading...\" , style = nib . ProgressStyle . linear , tint = nib . Color . BLUE , width = 250 , ) def simulate_download (): for i in range ( 101 ): progress . value = i progress . label = f \"Downloading... { i } %\" time . sleep ( 0.05 ) progress . label = \"Complete!\" threading . Thread ( target = simulate_download , daemon = True ) . start () app . build ( nib . VStack ( controls = [ progress ], padding = 20 ) ) nib . run ( main ) Circular progress indicator \u00b6 import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . ProgressView ( value = 3 , total = 10 , style = nib . ProgressStyle . circular , tint = nib . Color . GREEN , ), nib . Text ( \"3 of 10 tasks complete\" ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"ProgressView"},{"location":"reference/views/controls/progressview/#constructor","text":"nib . ProgressView ( value = None , total = 1.0 , label = \"\" , style = None , tint = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/progressview/#parameters","text":"Parameter Type Default Description value float \\| None None Current progress value. When None , displays an indeterminate spinner. When set, shows a progress bar filled to value / total . total float 1.0 Maximum value representing 100% completion. Set to 100 for percentage values or the actual total for counts. label str \"\" Optional text label displayed alongside the progress indicator. style ProgressStyle \\| str None Visual style. Options: ProgressStyle.automatic , ProgressStyle.linear (horizontal bar), ProgressStyle.circular (ring indicator). tint Color \\| str None Tint color for the progress indicator fill. Accepts a Color enum, hex string, or RGB tuple. **modifiers Common view modifiers: padding , background , opacity , width , height , etc.","title":"Parameters"},{"location":"reference/views/controls/progressview/#mutable-properties","text":"Property Type Description value float \\| None Get or set the progress value. Set to None for indeterminate mode. Triggers a UI update. progress float \\| None Get or set the progress as a fraction (0.0 to 1.0). Internally converts using total . total float Get or set the total value. Triggers a UI update. label str Get or set the progress label. Triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/controls/progressview/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/progressview/#indeterminate-loading-spinner","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . ProgressView (), nib . Text ( \"Loading...\" ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Indeterminate loading spinner"},{"location":"reference/views/controls/progressview/#determinate-download-progress","text":"import nib import threading , time def main ( app : nib . App ): progress = nib . ProgressView ( value = 0 , total = 100 , label = \"Downloading...\" , style = nib . ProgressStyle . linear , tint = nib . Color . BLUE , width = 250 , ) def simulate_download (): for i in range ( 101 ): progress . value = i progress . label = f \"Downloading... { i } %\" time . sleep ( 0.05 ) progress . label = \"Complete!\" threading . Thread ( target = simulate_download , daemon = True ) . start () app . build ( nib . VStack ( controls = [ progress ], padding = 20 ) ) nib . run ( main )","title":"Determinate download progress"},{"location":"reference/views/controls/progressview/#circular-progress-indicator","text":"import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . ProgressView ( value = 3 , total = 10 , style = nib . ProgressStyle . circular , tint = nib . Color . GREEN , ), nib . Text ( \"3 of 10 tasks complete\" ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Circular progress indicator"},{"location":"reference/views/controls/securefield/","text":"A single-line text input that masks entered characters, suitable for passwords and other sensitive data. SecureField behaves like TextField but obscures the input so that characters are not visible on screen. Constructor \u00b6 nib . SecureField ( placeholder = \"\" , value = \"\" , on_change = None , on_submit = None , style = None , disabled = False , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description placeholder str \"\" Hint text displayed when the field is empty. value str \"\" Initial text value (masked in the UI). Use the value property for reactive updates. on_change Callable[[str], None] None Callback called when text changes. Receives the new text value as a string argument. on_submit Callable[[str], None] None Callback called when the user presses Return/Enter. Receives the current text value. style TextFieldStyle \\| str None Visual style. Options: TextFieldStyle.automatic , TextFieldStyle.plain , TextFieldStyle.roundedBorder . disabled bool False Whether the secure field is disabled and non-interactive. **modifiers Common view modifiers: padding , background , foreground_color , font , opacity , width , etc. Mutable Properties \u00b6 Property Type Description value str Get or set the current text (masked in the UI). Setting triggers a UI update. Examples \u00b6 Password input \u00b6 import nib def main ( app : nib . App ): password_field = nib . SecureField ( placeholder = \"Password\" , value = \"\" , style = nib . TextFieldStyle . roundedBorder , ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Password:\" ), password_field , ], spacing = 8 , padding = 16 ) ) nib . run ( main ) Login form with submit \u00b6 import nib def main ( app : nib . App ): username = nib . TextField ( placeholder = \"Username\" , value = \"\" , style = nib . TextFieldStyle . roundedBorder , ) password = nib . SecureField ( placeholder = \"Password\" , value = \"\" , style = nib . TextFieldStyle . roundedBorder , ) status = nib . Text ( \"\" ) def login (): if username . value and password . value : status . content = \"Logging in...\" else : status . content = \"Please fill in all fields\" app . build ( nib . VStack ( controls = [ nib . Text ( \"Sign In\" , style = nib . TextStyle . TITLE ), username , password , nib . Button ( \"Log In\" , action = login , style = nib . ButtonStyle . borderedProminent ), status , ], spacing = 12 , padding = 20 , width = 280 ) ) nib . run ( main ) Secure field with validation \u00b6 import nib def main ( app : nib . App ): hint = nib . Text ( \"\" , foreground_color = nib . Color . RED , font = nib . Font . CAPTION ) def validate ( text : str ): if len ( text ) < 8 : hint . content = \"Password must be at least 8 characters\" else : hint . content = \"\" app . build ( nib . VStack ( controls = [ nib . SecureField ( placeholder = \"Enter a strong password\" , value = \"\" , on_change = validate , style = nib . TextFieldStyle . roundedBorder , ), hint , ], spacing = 4 , padding = 16 ) ) nib . run ( main )","title":"SecureField"},{"location":"reference/views/controls/securefield/#constructor","text":"nib . SecureField ( placeholder = \"\" , value = \"\" , on_change = None , on_submit = None , style = None , disabled = False , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/securefield/#parameters","text":"Parameter Type Default Description placeholder str \"\" Hint text displayed when the field is empty. value str \"\" Initial text value (masked in the UI). Use the value property for reactive updates. on_change Callable[[str], None] None Callback called when text changes. Receives the new text value as a string argument. on_submit Callable[[str], None] None Callback called when the user presses Return/Enter. Receives the current text value. style TextFieldStyle \\| str None Visual style. Options: TextFieldStyle.automatic , TextFieldStyle.plain , TextFieldStyle.roundedBorder . disabled bool False Whether the secure field is disabled and non-interactive. **modifiers Common view modifiers: padding , background , foreground_color , font , opacity , width , etc.","title":"Parameters"},{"location":"reference/views/controls/securefield/#mutable-properties","text":"Property Type Description value str Get or set the current text (masked in the UI). Setting triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/controls/securefield/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/securefield/#password-input","text":"import nib def main ( app : nib . App ): password_field = nib . SecureField ( placeholder = \"Password\" , value = \"\" , style = nib . TextFieldStyle . roundedBorder , ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Password:\" ), password_field , ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Password input"},{"location":"reference/views/controls/securefield/#login-form-with-submit","text":"import nib def main ( app : nib . App ): username = nib . TextField ( placeholder = \"Username\" , value = \"\" , style = nib . TextFieldStyle . roundedBorder , ) password = nib . SecureField ( placeholder = \"Password\" , value = \"\" , style = nib . TextFieldStyle . roundedBorder , ) status = nib . Text ( \"\" ) def login (): if username . value and password . value : status . content = \"Logging in...\" else : status . content = \"Please fill in all fields\" app . build ( nib . VStack ( controls = [ nib . Text ( \"Sign In\" , style = nib . TextStyle . TITLE ), username , password , nib . Button ( \"Log In\" , action = login , style = nib . ButtonStyle . borderedProminent ), status , ], spacing = 12 , padding = 20 , width = 280 ) ) nib . run ( main )","title":"Login form with submit"},{"location":"reference/views/controls/securefield/#secure-field-with-validation","text":"import nib def main ( app : nib . App ): hint = nib . Text ( \"\" , foreground_color = nib . Color . RED , font = nib . Font . CAPTION ) def validate ( text : str ): if len ( text ) < 8 : hint . content = \"Password must be at least 8 characters\" else : hint . content = \"\" app . build ( nib . VStack ( controls = [ nib . SecureField ( placeholder = \"Enter a strong password\" , value = \"\" , on_change = validate , style = nib . TextFieldStyle . roundedBorder , ), hint , ], spacing = 4 , padding = 16 ) ) nib . run ( main )","title":"Secure field with validation"},{"location":"reference/views/controls/sharelink/","text":"A button that presents the native macOS share sheet, allowing users to share text, URLs, or files through system sharing services. The share sheet displays available targets such as AirDrop, Mail, Messages, and third-party apps. Constructor \u00b6 nib . ShareLink ( items , content = None , label = None , icon = None , subject = None , message = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description items list[str] (required) Items to share. Can be strings (plain text), URLs, or file paths. content View None Custom view to use as the button label. Overrides label and icon . label str None Button label text. Used when content is not provided. icon str None SF Symbol name for the button icon. Used alongside label when content is not provided. subject str None Subject line for email shares. message str None Pre-filled message body for social shares. **modifiers Common view modifiers: padding , background , foreground_color , opacity , etc. Mutable Properties \u00b6 Property Type Description items list[str] Get or set the items to share. content View Get or set the custom button view. label str Get or set the button label text. icon str Get or set the SF Symbol icon name. Examples \u00b6 Share text with label \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ShareLink ( items = [ \"Check out this cool app!\" ], label = \"Share\" , icon = \"square.and.arrow.up\" , padding = 16 , ) ) nib . run ( main ) Share a URL with custom content \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ShareLink ( items = [ \"https://example.com\" ], content = nib . HStack ( controls = [ nib . Image ( system_name = \"square.and.arrow.up\" ), nib . Text ( \"Share Link\" ), ], spacing = 4 ), subject = \"Check this out\" , padding = 16 , ) ) nib . run ( main ) Share a file \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Export\" , style = nib . TextStyle . TITLE ), nib . ShareLink ( items = [ \"/path/to/report.pdf\" ], label = \"Share Report\" , icon = \"doc.fill\" , ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"ShareLink"},{"location":"reference/views/controls/sharelink/#constructor","text":"nib . ShareLink ( items , content = None , label = None , icon = None , subject = None , message = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/sharelink/#parameters","text":"Parameter Type Default Description items list[str] (required) Items to share. Can be strings (plain text), URLs, or file paths. content View None Custom view to use as the button label. Overrides label and icon . label str None Button label text. Used when content is not provided. icon str None SF Symbol name for the button icon. Used alongside label when content is not provided. subject str None Subject line for email shares. message str None Pre-filled message body for social shares. **modifiers Common view modifiers: padding , background , foreground_color , opacity , etc.","title":"Parameters"},{"location":"reference/views/controls/sharelink/#mutable-properties","text":"Property Type Description items list[str] Get or set the items to share. content View Get or set the custom button view. label str Get or set the button label text. icon str Get or set the SF Symbol icon name.","title":"Mutable Properties"},{"location":"reference/views/controls/sharelink/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/sharelink/#share-text-with-label","text":"import nib def main ( app : nib . App ): app . build ( nib . ShareLink ( items = [ \"Check out this cool app!\" ], label = \"Share\" , icon = \"square.and.arrow.up\" , padding = 16 , ) ) nib . run ( main )","title":"Share text with label"},{"location":"reference/views/controls/sharelink/#share-a-url-with-custom-content","text":"import nib def main ( app : nib . App ): app . build ( nib . ShareLink ( items = [ \"https://example.com\" ], content = nib . HStack ( controls = [ nib . Image ( system_name = \"square.and.arrow.up\" ), nib . Text ( \"Share Link\" ), ], spacing = 4 ), subject = \"Check this out\" , padding = 16 , ) ) nib . run ( main )","title":"Share a URL with custom content"},{"location":"reference/views/controls/sharelink/#share-a-file","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Export\" , style = nib . TextStyle . TITLE ), nib . ShareLink ( items = [ \"/path/to/report.pdf\" ], label = \"Share Report\" , icon = \"doc.fill\" , ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Share a file"},{"location":"reference/views/controls/slider/","text":"A horizontal track with a draggable thumb for selecting a numeric value within a range. The slider supports continuous values or discrete steps when a step increment is specified. Constructor \u00b6 nib . Slider ( value = 0 , min_value = 0 , max_value = 1 , step = None , label = \"\" , on_change = None , tint = None , disabled = False , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description value float 0 Initial value of the slider. Must be between min_value and max_value . min_value float 0 Minimum value of the range. max_value float 1 Maximum value of the range. step float None Step increment for discrete values. When set, the slider snaps to multiples of this value. When None , values are continuous. label str \"\" Optional text label displayed with the slider. on_change Callable[[float], None] None Callback called continuously as the slider value changes. Receives the new float value. tint Color \\| str None Tint color for the filled portion of the slider track. Accepts a Color enum, hex string, or RGB tuple. disabled bool False Whether the slider is disabled and non-interactive. **modifiers Common view modifiers: padding , background , opacity , width , etc. Examples \u00b6 Volume control \u00b6 import nib def main ( app : nib . App ): volume_label = nib . Text ( \"Volume: 50%\" ) def on_volume ( value : float ): volume_label . content = f \"Volume: { int ( value ) } %\" app . build ( nib . VStack ( controls = [ volume_label , nib . Slider ( value = 50 , min_value = 0 , max_value = 100 , on_change = on_volume , tint = nib . Color . BLUE , width = 250 , ), ], spacing = 8 , padding = 16 ) ) nib . run ( main ) Rating slider with discrete steps \u00b6 import nib def main ( app : nib . App ): rating_text = nib . Text ( \"Rating: 3\" ) def on_rating ( value : float ): rating_text . content = f \"Rating: { int ( value ) } \" app . build ( nib . VStack ( controls = [ rating_text , nib . Slider ( value = 3 , min_value = 1 , max_value = 5 , step = 1 , label = \"Rating\" , on_change = on_rating , tint = nib . Color . YELLOW , width = 200 , ), ], spacing = 8 , padding = 16 ) ) nib . run ( main ) Brightness control \u00b6 import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Label ( \"Brightness\" , icon = \"sun.min\" ), nib . Slider ( value = 75 , min_value = 0 , max_value = 100 , step = 5 , on_change = lambda v : print ( f \"Brightness: { int ( v ) } %\" ), tint = nib . Color . ORANGE , ), nib . Label ( \"\" , icon = \"sun.max\" ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Slider"},{"location":"reference/views/controls/slider/#constructor","text":"nib . Slider ( value = 0 , min_value = 0 , max_value = 1 , step = None , label = \"\" , on_change = None , tint = None , disabled = False , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/slider/#parameters","text":"Parameter Type Default Description value float 0 Initial value of the slider. Must be between min_value and max_value . min_value float 0 Minimum value of the range. max_value float 1 Maximum value of the range. step float None Step increment for discrete values. When set, the slider snaps to multiples of this value. When None , values are continuous. label str \"\" Optional text label displayed with the slider. on_change Callable[[float], None] None Callback called continuously as the slider value changes. Receives the new float value. tint Color \\| str None Tint color for the filled portion of the slider track. Accepts a Color enum, hex string, or RGB tuple. disabled bool False Whether the slider is disabled and non-interactive. **modifiers Common view modifiers: padding , background , opacity , width , etc.","title":"Parameters"},{"location":"reference/views/controls/slider/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/slider/#volume-control","text":"import nib def main ( app : nib . App ): volume_label = nib . Text ( \"Volume: 50%\" ) def on_volume ( value : float ): volume_label . content = f \"Volume: { int ( value ) } %\" app . build ( nib . VStack ( controls = [ volume_label , nib . Slider ( value = 50 , min_value = 0 , max_value = 100 , on_change = on_volume , tint = nib . Color . BLUE , width = 250 , ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Volume control"},{"location":"reference/views/controls/slider/#rating-slider-with-discrete-steps","text":"import nib def main ( app : nib . App ): rating_text = nib . Text ( \"Rating: 3\" ) def on_rating ( value : float ): rating_text . content = f \"Rating: { int ( value ) } \" app . build ( nib . VStack ( controls = [ rating_text , nib . Slider ( value = 3 , min_value = 1 , max_value = 5 , step = 1 , label = \"Rating\" , on_change = on_rating , tint = nib . Color . YELLOW , width = 200 , ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Rating slider with discrete steps"},{"location":"reference/views/controls/slider/#brightness-control","text":"import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Label ( \"Brightness\" , icon = \"sun.min\" ), nib . Slider ( value = 75 , min_value = 0 , max_value = 100 , step = 5 , on_change = lambda v : print ( f \"Brightness: { int ( v ) } %\" ), tint = nib . Color . ORANGE , ), nib . Label ( \"\" , icon = \"sun.max\" ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Brightness control"},{"location":"reference/views/controls/table/","text":"A macOS-native table view for displaying structured data in rows and columns. Table supports column definitions with alignment and width constraints, row selection, sorting callbacks, and double-click handling. Constructor \u00b6 nib . Table ( columns , rows , selection = None , on_selection = None , on_sort = None , on_double_click = None , row_id_key = \"id\" , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description columns list[TableColumn] (required) List of TableColumn definitions specifying the table structure. rows list[dict] (required) List of row data dictionaries. Each dict should contain keys matching the column key values and a row identifier. selection str \\| list[str] None Currently selected row ID or list of selected row IDs. on_selection Callable[[list[str]], None] None Callback when selection changes. Receives the list of selected row IDs. on_sort Callable[[str, bool], None] None Callback when sort order changes. Receives (column_id, ascending) . on_double_click Callable[[str], None] None Callback when a row is double-clicked. Receives the row ID. row_id_key str \"id\" Key used to identify rows in the data dictionaries. **modifiers Common view modifiers: width , height , padding , background , etc. TableColumn \u00b6 nib . TableColumn ( id , title , key , width = None , min_width = None , max_width = None , alignment = \"leading\" , ) Parameter Type Default Description id str (required) Unique identifier for the column. title str (required) Column header text. key str (required) Key to extract values from row data dictionaries. width float None Fixed column width in points. min_width float None Minimum column width. max_width float None Maximum column width. alignment str \"leading\" Text alignment. Options: \"leading\" , \"center\" , \"trailing\" . Mutable Properties \u00b6 Property Type Description columns list[TableColumn] Get or set the column definitions. Triggers a UI update. rows list[dict] Get or set the row data. Triggers a UI update. selection str \\| list[str] Get or set the selected row ID(s). Triggers a UI update. Examples \u00b6 File browser table \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Table ( columns = [ nib . TableColumn ( \"name\" , \"Name\" , \"name\" , min_width = 150 ), nib . TableColumn ( \"size\" , \"Size\" , \"size\" , width = 80 , alignment = \"trailing\" ), nib . TableColumn ( \"date\" , \"Modified\" , \"modified\" , width = 100 ), ], rows = [ { \"id\" : \"1\" , \"name\" : \"Document.txt\" , \"size\" : \"4 KB\" , \"modified\" : \"Today\" }, { \"id\" : \"2\" , \"name\" : \"Image.png\" , \"size\" : \"1.2 MB\" , \"modified\" : \"Yesterday\" }, { \"id\" : \"3\" , \"name\" : \"Archive.zip\" , \"size\" : \"45 MB\" , \"modified\" : \"Last week\" }, ], on_selection = lambda ids : print ( f \"Selected: { ids } \" ), width = 400 , height = 200 , padding = 16 , ) ) nib . run ( main ) Table with sorting and double-click \u00b6 import nib def main ( app : nib . App ): rows = [ { \"id\" : \"1\" , \"name\" : \"Alice\" , \"score\" : \"95\" , \"grade\" : \"A\" }, { \"id\" : \"2\" , \"name\" : \"Bob\" , \"score\" : \"87\" , \"grade\" : \"B+\" }, { \"id\" : \"3\" , \"name\" : \"Carol\" , \"score\" : \"92\" , \"grade\" : \"A-\" }, ] table = nib . Table ( columns = [ nib . TableColumn ( \"name\" , \"Student\" , \"name\" , min_width = 120 ), nib . TableColumn ( \"score\" , \"Score\" , \"score\" , width = 60 , alignment = \"center\" ), nib . TableColumn ( \"grade\" , \"Grade\" , \"grade\" , width = 60 , alignment = \"center\" ), ], rows = rows , on_sort = lambda col , asc : print ( f \"Sort by { col } , asc= { asc } \" ), on_double_click = lambda rid : print ( f \"Double-clicked row: { rid } \" ), width = 350 , height = 180 , ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Student Grades\" , style = nib . TextStyle . TITLE ), table , ], spacing = 8 , padding = 16 ) ) nib . run ( main ) Dynamic row updates \u00b6 import nib def main ( app : nib . App ): table = nib . Table ( columns = [ nib . TableColumn ( \"name\" , \"Task\" , \"name\" , min_width = 150 ), nib . TableColumn ( \"status\" , \"Status\" , \"status\" , width = 80 ), ], rows = [ { \"id\" : \"1\" , \"name\" : \"Design\" , \"status\" : \"Done\" }, { \"id\" : \"2\" , \"name\" : \"Develop\" , \"status\" : \"In Progress\" }, ], width = 300 , height = 150 , ) count = [ 3 ] def add_task (): table . rows = table . rows + [ { \"id\" : str ( count [ 0 ]), \"name\" : f \"Task { count [ 0 ] } \" , \"status\" : \"New\" } ] count [ 0 ] += 1 app . build ( nib . VStack ( controls = [ table , nib . Button ( \"Add Task\" , action = add_task ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Table"},{"location":"reference/views/controls/table/#constructor","text":"nib . Table ( columns , rows , selection = None , on_selection = None , on_sort = None , on_double_click = None , row_id_key = \"id\" , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/table/#parameters","text":"Parameter Type Default Description columns list[TableColumn] (required) List of TableColumn definitions specifying the table structure. rows list[dict] (required) List of row data dictionaries. Each dict should contain keys matching the column key values and a row identifier. selection str \\| list[str] None Currently selected row ID or list of selected row IDs. on_selection Callable[[list[str]], None] None Callback when selection changes. Receives the list of selected row IDs. on_sort Callable[[str, bool], None] None Callback when sort order changes. Receives (column_id, ascending) . on_double_click Callable[[str], None] None Callback when a row is double-clicked. Receives the row ID. row_id_key str \"id\" Key used to identify rows in the data dictionaries. **modifiers Common view modifiers: width , height , padding , background , etc.","title":"Parameters"},{"location":"reference/views/controls/table/#tablecolumn","text":"nib . TableColumn ( id , title , key , width = None , min_width = None , max_width = None , alignment = \"leading\" , ) Parameter Type Default Description id str (required) Unique identifier for the column. title str (required) Column header text. key str (required) Key to extract values from row data dictionaries. width float None Fixed column width in points. min_width float None Minimum column width. max_width float None Maximum column width. alignment str \"leading\" Text alignment. Options: \"leading\" , \"center\" , \"trailing\" .","title":"TableColumn"},{"location":"reference/views/controls/table/#mutable-properties","text":"Property Type Description columns list[TableColumn] Get or set the column definitions. Triggers a UI update. rows list[dict] Get or set the row data. Triggers a UI update. selection str \\| list[str] Get or set the selected row ID(s). Triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/controls/table/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/table/#file-browser-table","text":"import nib def main ( app : nib . App ): app . build ( nib . Table ( columns = [ nib . TableColumn ( \"name\" , \"Name\" , \"name\" , min_width = 150 ), nib . TableColumn ( \"size\" , \"Size\" , \"size\" , width = 80 , alignment = \"trailing\" ), nib . TableColumn ( \"date\" , \"Modified\" , \"modified\" , width = 100 ), ], rows = [ { \"id\" : \"1\" , \"name\" : \"Document.txt\" , \"size\" : \"4 KB\" , \"modified\" : \"Today\" }, { \"id\" : \"2\" , \"name\" : \"Image.png\" , \"size\" : \"1.2 MB\" , \"modified\" : \"Yesterday\" }, { \"id\" : \"3\" , \"name\" : \"Archive.zip\" , \"size\" : \"45 MB\" , \"modified\" : \"Last week\" }, ], on_selection = lambda ids : print ( f \"Selected: { ids } \" ), width = 400 , height = 200 , padding = 16 , ) ) nib . run ( main )","title":"File browser table"},{"location":"reference/views/controls/table/#table-with-sorting-and-double-click","text":"import nib def main ( app : nib . App ): rows = [ { \"id\" : \"1\" , \"name\" : \"Alice\" , \"score\" : \"95\" , \"grade\" : \"A\" }, { \"id\" : \"2\" , \"name\" : \"Bob\" , \"score\" : \"87\" , \"grade\" : \"B+\" }, { \"id\" : \"3\" , \"name\" : \"Carol\" , \"score\" : \"92\" , \"grade\" : \"A-\" }, ] table = nib . Table ( columns = [ nib . TableColumn ( \"name\" , \"Student\" , \"name\" , min_width = 120 ), nib . TableColumn ( \"score\" , \"Score\" , \"score\" , width = 60 , alignment = \"center\" ), nib . TableColumn ( \"grade\" , \"Grade\" , \"grade\" , width = 60 , alignment = \"center\" ), ], rows = rows , on_sort = lambda col , asc : print ( f \"Sort by { col } , asc= { asc } \" ), on_double_click = lambda rid : print ( f \"Double-clicked row: { rid } \" ), width = 350 , height = 180 , ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Student Grades\" , style = nib . TextStyle . TITLE ), table , ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Table with sorting and double-click"},{"location":"reference/views/controls/table/#dynamic-row-updates","text":"import nib def main ( app : nib . App ): table = nib . Table ( columns = [ nib . TableColumn ( \"name\" , \"Task\" , \"name\" , min_width = 150 ), nib . TableColumn ( \"status\" , \"Status\" , \"status\" , width = 80 ), ], rows = [ { \"id\" : \"1\" , \"name\" : \"Design\" , \"status\" : \"Done\" }, { \"id\" : \"2\" , \"name\" : \"Develop\" , \"status\" : \"In Progress\" }, ], width = 300 , height = 150 , ) count = [ 3 ] def add_task (): table . rows = table . rows + [ { \"id\" : str ( count [ 0 ]), \"name\" : f \"Task { count [ 0 ] } \" , \"status\" : \"New\" } ] count [ 0 ] += 1 app . build ( nib . VStack ( controls = [ table , nib . Button ( \"Add Task\" , action = add_task ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Dynamic row updates"},{"location":"reference/views/controls/text/","text":"A view that displays one or more lines of read-only text. Text is the fundamental view for presenting strings in the UI. It supports plain text, preset text styles, custom styling via TextStyle , and rich text with AttributedString segments. The content property is reactive -- assigning a new value triggers an immediate UI update. Constructor \u00b6 nib . Text ( content = None , strings = None , style = None , line_limit = None , truncation_mode = None , minimum_scale_factor = None , allows_tightening = False , text_case = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description content str None The text string to display. Provide either content or strings , not both. strings list[AttributedString] None A list of AttributedString objects for rich text with mixed styles. Provide either content or strings , not both. style TextStyle None A TextStyle that configures font, weight, color, and decorations. Can be a preset ( TextStyle.TITLE , TextStyle.BODY ) or a custom TextStyle(...) instance. line_limit int None Maximum number of lines to display. Text beyond this limit is truncated. truncation_mode TruncationMode \\| str None How to truncate overflowing text. Options: TruncationMode.HEAD , TruncationMode.MIDDLE , TruncationMode.TAIL . minimum_scale_factor float None Minimum scale factor for text shrinking (0.0 to 1.0). When set, text shrinks to fit before truncating. allows_tightening bool False Whether to allow tightening inter-character spacing to fit text. text_case TextCase \\| str None Text case transformation. Options: TextCase.UPPERCASE , TextCase.LOWERCASE . **modifiers Common view modifiers: font , foreground_color , padding , background , opacity , width , height , etc. Mutable Properties \u00b6 Property Type Description content str Get or set the displayed text. Setting triggers a UI update. strings list[AttributedString] Get or set the attributed string segments. Setting clears content and triggers a UI update. Examples \u00b6 Basic text display \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Hello, World!\" ), nib . Text ( \"Styled title\" , style = nib . TextStyle . TITLE ), nib . Text ( \"Body text\" , style = nib . TextStyle . BODY ), ], spacing = 8 , padding = 16 ) ) nib . run ( main ) Reactive counter \u00b6 import nib def main ( app : nib . App ): counter = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) app . build ( nib . VStack ( controls = [ counter , nib . Button ( \"Increment\" , action = increment ), ], spacing = 12 , padding = 16 ) ) nib . run ( main ) Rich text with AttributedString \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Text ( strings = [ nib . AttributedString ( \"Error: \" , style = nib . TextStyle ( color = \"red\" , bold = True )), nib . AttributedString ( \"File not found\" , style = nib . TextStyle . BODY ), ], padding = 16 , ) ) nib . run ( main )","title":"Text"},{"location":"reference/views/controls/text/#constructor","text":"nib . Text ( content = None , strings = None , style = None , line_limit = None , truncation_mode = None , minimum_scale_factor = None , allows_tightening = False , text_case = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/text/#parameters","text":"Parameter Type Default Description content str None The text string to display. Provide either content or strings , not both. strings list[AttributedString] None A list of AttributedString objects for rich text with mixed styles. Provide either content or strings , not both. style TextStyle None A TextStyle that configures font, weight, color, and decorations. Can be a preset ( TextStyle.TITLE , TextStyle.BODY ) or a custom TextStyle(...) instance. line_limit int None Maximum number of lines to display. Text beyond this limit is truncated. truncation_mode TruncationMode \\| str None How to truncate overflowing text. Options: TruncationMode.HEAD , TruncationMode.MIDDLE , TruncationMode.TAIL . minimum_scale_factor float None Minimum scale factor for text shrinking (0.0 to 1.0). When set, text shrinks to fit before truncating. allows_tightening bool False Whether to allow tightening inter-character spacing to fit text. text_case TextCase \\| str None Text case transformation. Options: TextCase.UPPERCASE , TextCase.LOWERCASE . **modifiers Common view modifiers: font , foreground_color , padding , background , opacity , width , height , etc.","title":"Parameters"},{"location":"reference/views/controls/text/#mutable-properties","text":"Property Type Description content str Get or set the displayed text. Setting triggers a UI update. strings list[AttributedString] Get or set the attributed string segments. Setting clears content and triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/controls/text/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/text/#basic-text-display","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Hello, World!\" ), nib . Text ( \"Styled title\" , style = nib . TextStyle . TITLE ), nib . Text ( \"Body text\" , style = nib . TextStyle . BODY ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Basic text display"},{"location":"reference/views/controls/text/#reactive-counter","text":"import nib def main ( app : nib . App ): counter = nib . Text ( \"0\" , font = nib . Font . TITLE ) def increment (): counter . content = str ( int ( counter . content ) + 1 ) app . build ( nib . VStack ( controls = [ counter , nib . Button ( \"Increment\" , action = increment ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Reactive counter"},{"location":"reference/views/controls/text/#rich-text-with-attributedstring","text":"import nib def main ( app : nib . App ): app . build ( nib . Text ( strings = [ nib . AttributedString ( \"Error: \" , style = nib . TextStyle ( color = \"red\" , bold = True )), nib . AttributedString ( \"File not found\" , style = nib . TextStyle . BODY ), ], padding = 16 , ) ) nib . run ( main )","title":"Rich text with AttributedString"},{"location":"reference/views/controls/texteditor/","text":"A multi-line text editing view, similar to an HTML <textarea> . TextEditor is suited for editing longer content such as notes, descriptions, or code. The text property is reactive -- assigning a new value triggers an immediate UI update. Constructor \u00b6 nib . TextEditor ( text = \"\" , placeholder = None , on_change = None , style = None , font = None , foreground_color = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description text str \"\" Initial text content. placeholder str None Placeholder text displayed when the editor is empty (macOS 14+). on_change Callable[[str], None] None Callback called when text changes. Receives the new text as a string argument. style TextEditorStyle None Comprehensive style configuration including font, colors, line spacing, alignment, and editor appearance. font Font None Text font. Overridden by style.font if both are provided. foreground_color Color \\| str None Text color. Overridden by style.foreground_color if both are provided. **modifiers Common view modifiers: padding , background , opacity , width , height , etc. Mutable Properties \u00b6 Property Type Description text str Get or set the editor text content. Setting triggers a UI update. placeholder str Get or set the placeholder text. Setting triggers a UI update. style TextEditorStyle Get or set the style configuration. Setting triggers a UI update. Examples \u00b6 Simple note editor \u00b6 import nib def main ( app : nib . App ): editor = nib . TextEditor ( text = \"\" , placeholder = \"Write your notes here...\" , width = 300 , height = 200 , ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Notes\" , style = nib . TextStyle . TITLE ), editor , ], spacing = 8 , padding = 16 ) ) nib . run ( main ) Editor with change tracking \u00b6 import nib def main ( app : nib . App ): char_count = nib . Text ( \"0 characters\" ) def on_text_change ( text : str ): char_count . content = f \" { len ( text ) } characters\" app . build ( nib . VStack ( controls = [ nib . TextEditor ( text = \"\" , placeholder = \"Start typing...\" , on_change = on_text_change , width = 300 , height = 150 , ), char_count , ], spacing = 8 , padding = 16 ) ) nib . run ( main ) Styled code editor \u00b6 import nib def main ( app : nib . App ): app . build ( nib . TextEditor ( text = 'print(\"Hello, World!\")' , style = nib . TextEditorStyle ( font = nib . Font . custom ( \"Menlo\" , size = 13 ), foreground_color = nib . Color . PRIMARY , background_color = nib . Color ( hex = \"#1E1E1E\" ), line_spacing = 6 , editor_style = nib . EditorStyle . PLAIN , ), width = 400 , height = 250 , padding = 16 , ) ) nib . run ( main )","title":"TextEditor"},{"location":"reference/views/controls/texteditor/#constructor","text":"nib . TextEditor ( text = \"\" , placeholder = None , on_change = None , style = None , font = None , foreground_color = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/texteditor/#parameters","text":"Parameter Type Default Description text str \"\" Initial text content. placeholder str None Placeholder text displayed when the editor is empty (macOS 14+). on_change Callable[[str], None] None Callback called when text changes. Receives the new text as a string argument. style TextEditorStyle None Comprehensive style configuration including font, colors, line spacing, alignment, and editor appearance. font Font None Text font. Overridden by style.font if both are provided. foreground_color Color \\| str None Text color. Overridden by style.foreground_color if both are provided. **modifiers Common view modifiers: padding , background , opacity , width , height , etc.","title":"Parameters"},{"location":"reference/views/controls/texteditor/#mutable-properties","text":"Property Type Description text str Get or set the editor text content. Setting triggers a UI update. placeholder str Get or set the placeholder text. Setting triggers a UI update. style TextEditorStyle Get or set the style configuration. Setting triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/controls/texteditor/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/texteditor/#simple-note-editor","text":"import nib def main ( app : nib . App ): editor = nib . TextEditor ( text = \"\" , placeholder = \"Write your notes here...\" , width = 300 , height = 200 , ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Notes\" , style = nib . TextStyle . TITLE ), editor , ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Simple note editor"},{"location":"reference/views/controls/texteditor/#editor-with-change-tracking","text":"import nib def main ( app : nib . App ): char_count = nib . Text ( \"0 characters\" ) def on_text_change ( text : str ): char_count . content = f \" { len ( text ) } characters\" app . build ( nib . VStack ( controls = [ nib . TextEditor ( text = \"\" , placeholder = \"Start typing...\" , on_change = on_text_change , width = 300 , height = 150 , ), char_count , ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Editor with change tracking"},{"location":"reference/views/controls/texteditor/#styled-code-editor","text":"import nib def main ( app : nib . App ): app . build ( nib . TextEditor ( text = 'print(\"Hello, World!\")' , style = nib . TextEditorStyle ( font = nib . Font . custom ( \"Menlo\" , size = 13 ), foreground_color = nib . Color . PRIMARY , background_color = nib . Color ( hex = \"#1E1E1E\" ), line_spacing = 6 , editor_style = nib . EditorStyle . PLAIN , ), width = 400 , height = 250 , padding = 16 , ) ) nib . run ( main )","title":"Styled code editor"},{"location":"reference/views/controls/textfield/","text":"A single-line text input control with placeholder text, change callbacks, and submit handling. The value property is reactive -- reading and writing it directly allows for straightforward state management. Constructor \u00b6 nib . TextField ( placeholder = \"\" , value = \"\" , on_change = None , on_submit = None , style = None , autocapitalization = None , autocorrection = None , keyboard_type = None , submit_label = None , disabled = False , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description placeholder str \"\" Hint text displayed when the field is empty. value str \"\" Initial text value. Use the value property for reactive updates. on_change Callable[[str], None] None Callback called when text changes. Receives the new text as a string argument. on_submit Callable[[str], None] None Callback called when the user presses Return/Enter. Receives the current text value. style TextFieldStyle \\| str None Visual style. Options: TextFieldStyle.automatic , TextFieldStyle.plain , TextFieldStyle.roundedBorder . autocapitalization str None Autocapitalization behavior. Options: \"none\" , \"words\" , \"sentences\" , \"allCharacters\" . autocorrection bool None Whether to enable autocorrection. True to enable, False to disable, None for system default. keyboard_type str None Keyboard type. Options: \"default\" , \"asciiCapable\" , \"numbersAndPunctuation\" , \"URL\" , \"numberPad\" , \"emailAddress\" , \"decimalPad\" . submit_label str None Label for the Return/Enter key (e.g., \"Search\" , \"Go\" ). disabled bool False Whether the text field is disabled and non-interactive. **modifiers Common view modifiers: padding , background , foreground_color , font , opacity , width , etc. Mutable Properties \u00b6 Property Type Description value str Get or set the current text. Setting triggers a UI update. Examples \u00b6 Basic text input with placeholder \u00b6 import nib def main ( app : nib . App ): name_field = nib . TextField ( placeholder = \"Enter your name\" , value = \"\" , style = nib . TextFieldStyle . roundedBorder , ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Name:\" ), name_field , ], spacing = 8 , padding = 16 ) ) nib . run ( main ) Search field with submit \u00b6 import nib def main ( app : nib . App ): results = nib . Text ( \"\" ) def search ( query : str ): results . content = f \"Searching for: { query } \" app . build ( nib . VStack ( controls = [ nib . TextField ( placeholder = \"Search...\" , value = \"\" , on_submit = search , submit_label = \"Search\" , style = nib . TextFieldStyle . roundedBorder , width = 250 , ), results , ], spacing = 12 , padding = 16 ) ) nib . run ( main ) Reactive value updates \u00b6 import nib def main ( app : nib . App ): display = nib . Text ( \"Characters: 0\" ) input_field = nib . TextField ( placeholder = \"Type something...\" , value = \"\" , on_change = lambda text : setattr ( display , \"content\" , f \"Characters: { len ( text ) } \" ), style = nib . TextFieldStyle . roundedBorder , ) app . build ( nib . VStack ( controls = [ input_field , display ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"TextField"},{"location":"reference/views/controls/textfield/#constructor","text":"nib . TextField ( placeholder = \"\" , value = \"\" , on_change = None , on_submit = None , style = None , autocapitalization = None , autocorrection = None , keyboard_type = None , submit_label = None , disabled = False , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/textfield/#parameters","text":"Parameter Type Default Description placeholder str \"\" Hint text displayed when the field is empty. value str \"\" Initial text value. Use the value property for reactive updates. on_change Callable[[str], None] None Callback called when text changes. Receives the new text as a string argument. on_submit Callable[[str], None] None Callback called when the user presses Return/Enter. Receives the current text value. style TextFieldStyle \\| str None Visual style. Options: TextFieldStyle.automatic , TextFieldStyle.plain , TextFieldStyle.roundedBorder . autocapitalization str None Autocapitalization behavior. Options: \"none\" , \"words\" , \"sentences\" , \"allCharacters\" . autocorrection bool None Whether to enable autocorrection. True to enable, False to disable, None for system default. keyboard_type str None Keyboard type. Options: \"default\" , \"asciiCapable\" , \"numbersAndPunctuation\" , \"URL\" , \"numberPad\" , \"emailAddress\" , \"decimalPad\" . submit_label str None Label for the Return/Enter key (e.g., \"Search\" , \"Go\" ). disabled bool False Whether the text field is disabled and non-interactive. **modifiers Common view modifiers: padding , background , foreground_color , font , opacity , width , etc.","title":"Parameters"},{"location":"reference/views/controls/textfield/#mutable-properties","text":"Property Type Description value str Get or set the current text. Setting triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/controls/textfield/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/textfield/#basic-text-input-with-placeholder","text":"import nib def main ( app : nib . App ): name_field = nib . TextField ( placeholder = \"Enter your name\" , value = \"\" , style = nib . TextFieldStyle . roundedBorder , ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Name:\" ), name_field , ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Basic text input with placeholder"},{"location":"reference/views/controls/textfield/#search-field-with-submit","text":"import nib def main ( app : nib . App ): results = nib . Text ( \"\" ) def search ( query : str ): results . content = f \"Searching for: { query } \" app . build ( nib . VStack ( controls = [ nib . TextField ( placeholder = \"Search...\" , value = \"\" , on_submit = search , submit_label = \"Search\" , style = nib . TextFieldStyle . roundedBorder , width = 250 , ), results , ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Search field with submit"},{"location":"reference/views/controls/textfield/#reactive-value-updates","text":"import nib def main ( app : nib . App ): display = nib . Text ( \"Characters: 0\" ) input_field = nib . TextField ( placeholder = \"Type something...\" , value = \"\" , on_change = lambda text : setattr ( display , \"content\" , f \"Characters: { len ( text ) } \" ), style = nib . TextFieldStyle . roundedBorder , ) app . build ( nib . VStack ( controls = [ input_field , display ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Reactive value updates"},{"location":"reference/views/controls/toggle/","text":"A control for switching between on and off states. Toggle provides a binary switch that users can tap to change. It can display a text label or custom content, and triggers a callback when the state changes. Constructor \u00b6 nib . Toggle ( label = None , is_on = False , on_change = None , content = None , style = None , tint = None , disabled = False , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description label str None Text displayed next to the toggle switch. is_on bool False Initial on/off state. True for on, False for off. on_change Callable[[bool], None] None Callback called when the toggle state changes. Receives a boolean indicating the new state. content View None Custom view to display as the toggle label. Alternative to label . style ToggleStyle \\| str None Visual style. Options: ToggleStyle.automatic , ToggleStyle.switch , ToggleStyle.checkbox , ToggleStyle.button . tint Color \\| str None Tint color for the toggle in the \"on\" state. Accepts a Color enum, hex string, or RGB tuple. disabled bool False Whether the toggle is disabled and non-interactive. **modifiers Common view modifiers: padding , background , foreground_color , opacity , etc. Examples \u00b6 Basic toggle switch \u00b6 import nib def main ( app : nib . App ): status = nib . Text ( \"Off\" ) def on_toggle ( is_on : bool ): status . content = \"On\" if is_on else \"Off\" app . build ( nib . VStack ( controls = [ nib . Toggle ( \"Enable notifications\" , is_on = False , on_change = on_toggle , ), status , ], spacing = 12 , padding = 16 ) ) nib . run ( main ) Settings panel with styled toggles \u00b6 import nib def main ( app : nib . App ): def log_change ( name ): return lambda is_on : print ( f \" { name } : { is_on } \" ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Settings\" , style = nib . TextStyle . TITLE ), nib . Toggle ( \"Dark Mode\" , is_on = True , on_change = log_change ( \"Dark Mode\" ), tint = nib . Color . BLUE ), nib . Toggle ( \"Airplane Mode\" , is_on = False , on_change = log_change ( \"Airplane Mode\" ), tint = nib . Color . ORANGE ), nib . Toggle ( \"I agree to terms\" , is_on = False , on_change = log_change ( \"Terms\" ), style = nib . ToggleStyle . checkbox ), ], spacing = 12 , padding = 16 ) ) nib . run ( main ) Toggle with custom content \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Toggle ( content = nib . Label ( \"Wi-Fi\" , icon = \"wifi\" ), is_on = True , on_change = lambda on : print ( f \"Wi-Fi: { on } \" ), tint = nib . Color . GREEN , padding = 16 , ) ) nib . run ( main )","title":"Toggle"},{"location":"reference/views/controls/toggle/#constructor","text":"nib . Toggle ( label = None , is_on = False , on_change = None , content = None , style = None , tint = None , disabled = False , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/toggle/#parameters","text":"Parameter Type Default Description label str None Text displayed next to the toggle switch. is_on bool False Initial on/off state. True for on, False for off. on_change Callable[[bool], None] None Callback called when the toggle state changes. Receives a boolean indicating the new state. content View None Custom view to display as the toggle label. Alternative to label . style ToggleStyle \\| str None Visual style. Options: ToggleStyle.automatic , ToggleStyle.switch , ToggleStyle.checkbox , ToggleStyle.button . tint Color \\| str None Tint color for the toggle in the \"on\" state. Accepts a Color enum, hex string, or RGB tuple. disabled bool False Whether the toggle is disabled and non-interactive. **modifiers Common view modifiers: padding , background , foreground_color , opacity , etc.","title":"Parameters"},{"location":"reference/views/controls/toggle/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/toggle/#basic-toggle-switch","text":"import nib def main ( app : nib . App ): status = nib . Text ( \"Off\" ) def on_toggle ( is_on : bool ): status . content = \"On\" if is_on else \"Off\" app . build ( nib . VStack ( controls = [ nib . Toggle ( \"Enable notifications\" , is_on = False , on_change = on_toggle , ), status , ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Basic toggle switch"},{"location":"reference/views/controls/toggle/#settings-panel-with-styled-toggles","text":"import nib def main ( app : nib . App ): def log_change ( name ): return lambda is_on : print ( f \" { name } : { is_on } \" ) app . build ( nib . VStack ( controls = [ nib . Text ( \"Settings\" , style = nib . TextStyle . TITLE ), nib . Toggle ( \"Dark Mode\" , is_on = True , on_change = log_change ( \"Dark Mode\" ), tint = nib . Color . BLUE ), nib . Toggle ( \"Airplane Mode\" , is_on = False , on_change = log_change ( \"Airplane Mode\" ), tint = nib . Color . ORANGE ), nib . Toggle ( \"I agree to terms\" , is_on = False , on_change = log_change ( \"Terms\" ), style = nib . ToggleStyle . checkbox ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Settings panel with styled toggles"},{"location":"reference/views/controls/toggle/#toggle-with-custom-content","text":"import nib def main ( app : nib . App ): app . build ( nib . Toggle ( content = nib . Label ( \"Wi-Fi\" , icon = \"wifi\" ), is_on = True , on_change = lambda on : print ( f \"Wi-Fi: { on } \" ), tint = nib . Color . GREEN , padding = 16 , ) ) nib . run ( main )","title":"Toggle with custom content"},{"location":"reference/views/controls/video/","text":"A view that displays and plays video content from URLs or local files. Video supports autoplay, looping, audio muting, playback controls, and various scaling modes. All playback properties are reactive. Constructor \u00b6 nib . Video ( src = None , autoplay = False , loop = False , muted = False , controls = True , gravity = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description src str None Video source. Supports remote URLs ( \"https://...\" ), absolute file paths ( \"/path/to/video.mp4\" ), or asset references ( \"intro.mp4\" resolves to assets/intro.mp4 ). autoplay bool False Whether to start playing automatically when the video loads. loop bool False Whether to restart playback automatically when the video ends. muted bool False Whether to mute the audio track. controls bool True Whether to show playback controls (play/pause, scrubber, volume). gravity VideoGravity \\| str None How the video scales within its frame. Options: VideoGravity.RESIZE_ASPECT (fit, may letterbox -- default), VideoGravity.RESIZE_ASPECT_FILL (fill, may crop), VideoGravity.RESIZE (stretch to fill, distorts). **modifiers Common view modifiers: width , height , corner_radius , opacity , padding , etc. Mutable Properties \u00b6 Property Type Description src str Get or set the video source. Setting triggers a UI update and may reset playback position. autoplay bool Get or set autoplay. loop bool Get or set looping. muted bool Get or set muted state. controls bool Get or set controls visibility. Examples \u00b6 Basic video player \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Video ( src = \"https://example.com/tutorial.mp4\" , width = 480 , height = 270 , corner_radius = 8 , padding = 16 , ) ) nib . run ( main ) Autoplay looping background \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Video ( src = \"ambient.mp4\" , autoplay = True , loop = True , muted = True , controls = False , gravity = nib . VideoGravity . RESIZE_ASPECT_FILL , width = 400 , height = 300 , ), nib . Text ( \"Welcome\" , font = nib . Font . LARGE_TITLE , foreground_color = nib . Color . WHITE , ), ]) ) nib . run ( main ) Video with reactive source \u00b6 import nib def main ( app : nib . App ): player = nib . Video ( src = \"https://example.com/video1.mp4\" , autoplay = True , width = 400 , height = 225 , corner_radius = 8 , ) app . build ( nib . VStack ( controls = [ player , nib . HStack ( controls = [ nib . Button ( \"Video 1\" , action = lambda : setattr ( player , \"src\" , \"https://example.com/video1.mp4\" )), nib . Button ( \"Video 2\" , action = lambda : setattr ( player , \"src\" , \"https://example.com/video2.mp4\" )), ], spacing = 8 ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Video"},{"location":"reference/views/controls/video/#constructor","text":"nib . Video ( src = None , autoplay = False , loop = False , muted = False , controls = True , gravity = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/video/#parameters","text":"Parameter Type Default Description src str None Video source. Supports remote URLs ( \"https://...\" ), absolute file paths ( \"/path/to/video.mp4\" ), or asset references ( \"intro.mp4\" resolves to assets/intro.mp4 ). autoplay bool False Whether to start playing automatically when the video loads. loop bool False Whether to restart playback automatically when the video ends. muted bool False Whether to mute the audio track. controls bool True Whether to show playback controls (play/pause, scrubber, volume). gravity VideoGravity \\| str None How the video scales within its frame. Options: VideoGravity.RESIZE_ASPECT (fit, may letterbox -- default), VideoGravity.RESIZE_ASPECT_FILL (fill, may crop), VideoGravity.RESIZE (stretch to fill, distorts). **modifiers Common view modifiers: width , height , corner_radius , opacity , padding , etc.","title":"Parameters"},{"location":"reference/views/controls/video/#mutable-properties","text":"Property Type Description src str Get or set the video source. Setting triggers a UI update and may reset playback position. autoplay bool Get or set autoplay. loop bool Get or set looping. muted bool Get or set muted state. controls bool Get or set controls visibility.","title":"Mutable Properties"},{"location":"reference/views/controls/video/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/video/#basic-video-player","text":"import nib def main ( app : nib . App ): app . build ( nib . Video ( src = \"https://example.com/tutorial.mp4\" , width = 480 , height = 270 , corner_radius = 8 , padding = 16 , ) ) nib . run ( main )","title":"Basic video player"},{"location":"reference/views/controls/video/#autoplay-looping-background","text":"import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Video ( src = \"ambient.mp4\" , autoplay = True , loop = True , muted = True , controls = False , gravity = nib . VideoGravity . RESIZE_ASPECT_FILL , width = 400 , height = 300 , ), nib . Text ( \"Welcome\" , font = nib . Font . LARGE_TITLE , foreground_color = nib . Color . WHITE , ), ]) ) nib . run ( main )","title":"Autoplay looping background"},{"location":"reference/views/controls/video/#video-with-reactive-source","text":"import nib def main ( app : nib . App ): player = nib . Video ( src = \"https://example.com/video1.mp4\" , autoplay = True , width = 400 , height = 225 , corner_radius = 8 , ) app . build ( nib . VStack ( controls = [ player , nib . HStack ( controls = [ nib . Button ( \"Video 1\" , action = lambda : setattr ( player , \"src\" , \"https://example.com/video1.mp4\" )), nib . Button ( \"Video 2\" , action = lambda : setattr ( player , \"src\" , \"https://example.com/video2.mp4\" )), ], spacing = 8 ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Video with reactive source"},{"location":"reference/views/controls/webview/","text":"A view that embeds web content using WKWebView. WebView can load content from URLs or raw HTML strings. It supports navigation callbacks, JavaScript evaluation, and back/forward history. Constructor \u00b6 nib . WebView ( url = None , html = None , base_url = None , on_load = None , on_navigate = None , on_error = None , allows_back_forward = True , allows_magnification = True , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description url str None URL to load. Mutually exclusive with html . html str None Raw HTML content to display. Mutually exclusive with url . base_url str None Base URL for resolving relative links in HTML content. on_load Callable[[], None] None Callback when the page finishes loading. on_navigate Callable[[str], None] None Callback when navigation occurs. Receives the new URL. on_error Callable[[str], None] None Callback when loading fails. Receives the error message. allows_back_forward bool True Whether back/forward navigation is enabled. allows_magnification bool True Whether pinch-to-zoom is enabled. **modifiers Common view modifiers: width , height , corner_radius , opacity , padding , etc. Mutable Properties \u00b6 Property Type Description url str Get or set the URL. Setting clears html and triggers navigation. html str Get or set the HTML content. Setting clears url and triggers a re-render. Methods \u00b6 Method Description load_url(url) Load a new URL. load_html(html, base_url=None) Load HTML content with an optional base URL. reload() Reload the current page. go_back() Navigate back in history. go_forward() Navigate forward in history. evaluate_js(script, callback=None) Execute JavaScript code in the web view. Examples \u00b6 Load a URL \u00b6 import nib def main ( app : nib . App ): app . build ( nib . WebView ( url = \"https://example.com\" , width = 400 , height = 300 , corner_radius = 8 , padding = 16 , ) ) nib . run ( main ) Display custom HTML \u00b6 import nib def main ( app : nib . App ): app . build ( nib . WebView ( html = \"\"\" <html> <body style=\"font-family: -apple-system; padding: 20px; background: #1a1a1a; color: white;\"> <h1>Hello from Nib!</h1> <p>This is rendered HTML content.</p> </body> </html> \"\"\" , width = 400 , height = 250 , corner_radius = 8 , padding = 16 , ) ) nib . run ( main ) Web view with navigation and JavaScript \u00b6 import nib def main ( app : nib . App ): web = nib . WebView ( url = \"https://example.com\" , on_navigate = lambda url : print ( f \"Navigating to: { url } \" ), on_load = lambda : print ( \"Page loaded\" ), width = 400 , height = 300 , ) app . build ( nib . VStack ( controls = [ nib . HStack ( controls = [ nib . Button ( \"Back\" , action = web . go_back ), nib . Button ( \"Forward\" , action = web . go_forward ), nib . Button ( \"Reload\" , action = web . reload ), nib . Button ( \"Run JS\" , action = lambda : web . evaluate_js ( \"document.title\" )), ], spacing = 4 ), web , ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"WebView"},{"location":"reference/views/controls/webview/#constructor","text":"nib . WebView ( url = None , html = None , base_url = None , on_load = None , on_navigate = None , on_error = None , allows_back_forward = True , allows_magnification = True , ** modifiers , )","title":"Constructor"},{"location":"reference/views/controls/webview/#parameters","text":"Parameter Type Default Description url str None URL to load. Mutually exclusive with html . html str None Raw HTML content to display. Mutually exclusive with url . base_url str None Base URL for resolving relative links in HTML content. on_load Callable[[], None] None Callback when the page finishes loading. on_navigate Callable[[str], None] None Callback when navigation occurs. Receives the new URL. on_error Callable[[str], None] None Callback when loading fails. Receives the error message. allows_back_forward bool True Whether back/forward navigation is enabled. allows_magnification bool True Whether pinch-to-zoom is enabled. **modifiers Common view modifiers: width , height , corner_radius , opacity , padding , etc.","title":"Parameters"},{"location":"reference/views/controls/webview/#mutable-properties","text":"Property Type Description url str Get or set the URL. Setting clears html and triggers navigation. html str Get or set the HTML content. Setting clears url and triggers a re-render.","title":"Mutable Properties"},{"location":"reference/views/controls/webview/#methods","text":"Method Description load_url(url) Load a new URL. load_html(html, base_url=None) Load HTML content with an optional base URL. reload() Reload the current page. go_back() Navigate back in history. go_forward() Navigate forward in history. evaluate_js(script, callback=None) Execute JavaScript code in the web view.","title":"Methods"},{"location":"reference/views/controls/webview/#examples","text":"","title":"Examples"},{"location":"reference/views/controls/webview/#load-a-url","text":"import nib def main ( app : nib . App ): app . build ( nib . WebView ( url = \"https://example.com\" , width = 400 , height = 300 , corner_radius = 8 , padding = 16 , ) ) nib . run ( main )","title":"Load a URL"},{"location":"reference/views/controls/webview/#display-custom-html","text":"import nib def main ( app : nib . App ): app . build ( nib . WebView ( html = \"\"\" <html> <body style=\"font-family: -apple-system; padding: 20px; background: #1a1a1a; color: white;\"> <h1>Hello from Nib!</h1> <p>This is rendered HTML content.</p> </body> </html> \"\"\" , width = 400 , height = 250 , corner_radius = 8 , padding = 16 , ) ) nib . run ( main )","title":"Display custom HTML"},{"location":"reference/views/controls/webview/#web-view-with-navigation-and-javascript","text":"import nib def main ( app : nib . App ): web = nib . WebView ( url = \"https://example.com\" , on_navigate = lambda url : print ( f \"Navigating to: { url } \" ), on_load = lambda : print ( \"Page loaded\" ), width = 400 , height = 300 , ) app . build ( nib . VStack ( controls = [ nib . HStack ( controls = [ nib . Button ( \"Back\" , action = web . go_back ), nib . Button ( \"Forward\" , action = web . go_forward ), nib . Button ( \"Reload\" , action = web . reload ), nib . Button ( \"Run JS\" , action = lambda : web . evaluate_js ( \"document.title\" )), ], spacing = 4 ), web , ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Web view with navigation and JavaScript"},{"location":"reference/views/effects/","text":"Effect views apply visual transformations and rendering effects to content. These views leverage macOS system APIs for hardware-accelerated visual effects. View Description VisualEffectBlur Applies a macOS frosted-glass blur (NSVisualEffectView) with configurable material and blending mode. Canvas A Core Graphics drawing surface with gesture support for freeform 2D rendering.","title":"Index"},{"location":"reference/views/effects/blur/","text":"A view that applies a macOS frosted-glass blur effect, wrapping NSVisualEffectView . It creates the translucent blur commonly seen in menu bar apps, sidebars, and other system UI. Can be used as a standalone view or as a background for other views. All properties are reactive -- updating them triggers an immediate UI refresh. Constructor \u00b6 nib . VisualEffectBlur ( material = BlurStyle . POPOVER , blending_mode = BlurBlendingMode . BEHIND_WINDOW , is_emphasized = False , corner_radius = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description material BlurStyle BlurStyle.POPOVER The blur material/style. Controls the visual appearance and vibrancy level. See the BlurStyle table below. blending_mode BlurBlendingMode BlurBlendingMode.BEHIND_WINDOW How the blur blends with content. BEHIND_WINDOW blurs content behind the window; WITHIN_WINDOW blurs content within the same window. is_emphasized bool False Whether to use the emphasized appearance, which increases vibrancy. corner_radius float None Corner radius for a rounded blur region. **modifiers Common view modifiers: width , height , padding , opacity , etc. Mutable Properties \u00b6 Property Type Description material BlurStyle Get or set the blur material. Setting triggers a UI update. blending_mode BlurBlendingMode Get or set the blending mode. is_emphasized bool Get or set the emphasized state. corner_radius float \\| None Get or set the corner radius. BlurStyle \u00b6 The BlurStyle enum maps to NSVisualEffectView.Material values on macOS. Standard materials \u00b6 Value Description HEADER_VIEW Header region style. TOOLTIP Tooltip popup style. MENU Menu background style. POPOVER Popover background style. Default. SIDEBAR Sidebar panel style. FULLSCREEN_UI Full-screen overlay style. HUD Heads-up display style. SHEET Sheet overlay style. WINDOW_BACKGROUND Window background style. CONTENT_BACKGROUND Content area background. UNDER_WINDOW_BACKGROUND Under-window background. UNDER_PAGE_BACKGROUND Under-page background. Vibrancy \u00b6 Value Description TITLEBAR Title bar vibrancy. SELECTION Selection highlight vibrancy. System materials \u00b6 Value Description ULTRA_THIN Ultra-thin blur. Most transparent. THIN Thin blur. REGULAR Regular blur. THICK Thick blur. ULTRA_THICK Ultra-thick blur. Most opaque. BlurBlendingMode \u00b6 Value Description BEHIND_WINDOW Blurs content behind the entire window. WITHIN_WINDOW Blurs content within the same window, behind this view. Examples \u00b6 As a view background \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . VisualEffectBlur ( material = nib . BlurStyle . POPOVER ), nib . VStack ( controls = [ nib . Text ( \"Blurred Background\" , font = nib . Font . TITLE ), nib . Text ( \"Content rendered over frosted glass\" ), ], spacing = 8 , padding = 20 , ), ]) ) nib . run ( main ) Menu-style blur with rounded corners \u00b6 import nib blur = nib . VisualEffectBlur ( material = nib . BlurStyle . MENU , corner_radius = 10 , width = 300 , height = 200 , ) Sidebar style \u00b6 import nib sidebar_blur = nib . VisualEffectBlur ( material = nib . BlurStyle . SIDEBAR , blending_mode = nib . BlurBlendingMode . BEHIND_WINDOW , width = 250 , ) Updating material reactively \u00b6 import nib def main ( app : nib . App ): blur = nib . VisualEffectBlur ( material = nib . BlurStyle . THIN , width = 300 , height = 200 , ) def toggle_thickness (): if blur . material == nib . BlurStyle . THIN : blur . material = nib . BlurStyle . ULTRA_THICK else : blur . material = nib . BlurStyle . THIN app . build ( nib . VStack ( controls = [ blur , nib . Button ( \"Toggle Blur\" , action = toggle_thickness ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"VisualEffectBlur"},{"location":"reference/views/effects/blur/#constructor","text":"nib . VisualEffectBlur ( material = BlurStyle . POPOVER , blending_mode = BlurBlendingMode . BEHIND_WINDOW , is_emphasized = False , corner_radius = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/effects/blur/#parameters","text":"Parameter Type Default Description material BlurStyle BlurStyle.POPOVER The blur material/style. Controls the visual appearance and vibrancy level. See the BlurStyle table below. blending_mode BlurBlendingMode BlurBlendingMode.BEHIND_WINDOW How the blur blends with content. BEHIND_WINDOW blurs content behind the window; WITHIN_WINDOW blurs content within the same window. is_emphasized bool False Whether to use the emphasized appearance, which increases vibrancy. corner_radius float None Corner radius for a rounded blur region. **modifiers Common view modifiers: width , height , padding , opacity , etc.","title":"Parameters"},{"location":"reference/views/effects/blur/#mutable-properties","text":"Property Type Description material BlurStyle Get or set the blur material. Setting triggers a UI update. blending_mode BlurBlendingMode Get or set the blending mode. is_emphasized bool Get or set the emphasized state. corner_radius float \\| None Get or set the corner radius.","title":"Mutable Properties"},{"location":"reference/views/effects/blur/#blurstyle","text":"The BlurStyle enum maps to NSVisualEffectView.Material values on macOS.","title":"BlurStyle"},{"location":"reference/views/effects/blur/#standard-materials","text":"Value Description HEADER_VIEW Header region style. TOOLTIP Tooltip popup style. MENU Menu background style. POPOVER Popover background style. Default. SIDEBAR Sidebar panel style. FULLSCREEN_UI Full-screen overlay style. HUD Heads-up display style. SHEET Sheet overlay style. WINDOW_BACKGROUND Window background style. CONTENT_BACKGROUND Content area background. UNDER_WINDOW_BACKGROUND Under-window background. UNDER_PAGE_BACKGROUND Under-page background.","title":"Standard materials"},{"location":"reference/views/effects/blur/#vibrancy","text":"Value Description TITLEBAR Title bar vibrancy. SELECTION Selection highlight vibrancy.","title":"Vibrancy"},{"location":"reference/views/effects/blur/#system-materials","text":"Value Description ULTRA_THIN Ultra-thin blur. Most transparent. THIN Thin blur. REGULAR Regular blur. THICK Thick blur. ULTRA_THICK Ultra-thick blur. Most opaque.","title":"System materials"},{"location":"reference/views/effects/blur/#blurblendingmode","text":"Value Description BEHIND_WINDOW Blurs content behind the entire window. WITHIN_WINDOW Blurs content within the same window, behind this view.","title":"BlurBlendingMode"},{"location":"reference/views/effects/blur/#examples","text":"","title":"Examples"},{"location":"reference/views/effects/blur/#as-a-view-background","text":"import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . VisualEffectBlur ( material = nib . BlurStyle . POPOVER ), nib . VStack ( controls = [ nib . Text ( \"Blurred Background\" , font = nib . Font . TITLE ), nib . Text ( \"Content rendered over frosted glass\" ), ], spacing = 8 , padding = 20 , ), ]) ) nib . run ( main )","title":"As a view background"},{"location":"reference/views/effects/blur/#menu-style-blur-with-rounded-corners","text":"import nib blur = nib . VisualEffectBlur ( material = nib . BlurStyle . MENU , corner_radius = 10 , width = 300 , height = 200 , )","title":"Menu-style blur with rounded corners"},{"location":"reference/views/effects/blur/#sidebar-style","text":"import nib sidebar_blur = nib . VisualEffectBlur ( material = nib . BlurStyle . SIDEBAR , blending_mode = nib . BlurBlendingMode . BEHIND_WINDOW , width = 250 , )","title":"Sidebar style"},{"location":"reference/views/effects/blur/#updating-material-reactively","text":"import nib def main ( app : nib . App ): blur = nib . VisualEffectBlur ( material = nib . BlurStyle . THIN , width = 300 , height = 200 , ) def toggle_thickness (): if blur . material == nib . BlurStyle . THIN : blur . material = nib . BlurStyle . ULTRA_THICK else : blur . material = nib . BlurStyle . THIN app . build ( nib . VStack ( controls = [ blur , nib . Button ( \"Toggle Blur\" , action = toggle_thickness ), ], spacing = 12 , padding = 16 ) ) nib . run ( main )","title":"Updating material reactively"},{"location":"reference/views/effects/canvas/","text":"A drawing surface for freeform 2D rendering using Core Graphics. Canvas accepts a list of declarative drawing commands (shapes, images, text) and renders them with GPU acceleration on macOS. The canvas is reactive -- calling draw() , append() , or clear() triggers an immediate re-render. Gesture callbacks enable interactive drawing applications such as freehand sketching or annotation tools. For the full list of drawing commands, see the Draw Module Reference . Constructor \u00b6 nib . Canvas ( width = 100 , height = 100 , commands = None , background_color = None , enable_gestures = False , on_pan_start = None , on_pan_update = None , on_pan_end = None , on_hover = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description width float 100 Width of the canvas drawing area in points. height float 100 Height of the canvas drawing area in points. commands list[DrawCommand] None Initial list of drawing commands to render. background_color str None Background color as a hex string (e.g., \"#1a1a1a\" ). None for transparent. enable_gestures bool False Enable pan/hover gesture tracking. Automatically enabled when any gesture callback is set. on_pan_start Callable[[PanEvent], None] None Callback invoked when mouse/pen is pressed down on the canvas. on_pan_update Callable[[PanEvent], None] None Callback invoked when mouse/pen is dragged across the canvas. on_pan_end Callable[[PanEvent], None] None Callback invoked when mouse/pen is released. on_hover Callable[[PanEvent], None] None Callback invoked when the mouse moves over the canvas without pressing. **modifiers Common view modifiers: padding , opacity , corner_radius , etc. Mutable Properties \u00b6 Property Type Description canvas_width float Get or set the drawing area width. Setting triggers a re-render. canvas_height float Get or set the drawing area height. Setting triggers a re-render. background_color str \\| None Get or set the background color. commands list[DrawCommand] Get the current list of drawing commands (read-only). on_pan_start Callable \\| None Get or set the pan start callback. Setting a callback auto-enables gestures. on_pan_update Callable \\| None Get or set the pan update callback. on_pan_end Callable \\| None Get or set the pan end callback. on_hover Callable \\| None Get or set the hover callback. Methods \u00b6 Method Signature Description draw draw(commands: list[DrawCommand]) Replace all drawing commands and re-render. append append(command: DrawCommand) Add a single drawing command and re-render. clear clear() Remove all drawing commands and re-render. PanEvent \u00b6 A dataclass passed to gesture callbacks containing the pointer position. Field Type Description x float X coordinate of the event in canvas coordinates. y float Y coordinate of the event in canvas coordinates. Examples \u00b6 Basic drawing \u00b6 import nib def main ( app : nib . App ): canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#1a1a1a\" ) canvas . draw ([ nib . draw . Rect ( x = 10 , y = 10 , width = 100 , height = 50 , fill = \"#3498db\" ), nib . draw . Circle ( cx = 200 , cy = 100 , radius = 40 , fill = \"#e74c3c\" ), nib . draw . Text ( \"Hello Canvas!\" , x = 10 , y = 280 , fill = \"#ffffff\" ), ]) app . build ( canvas ) nib . run ( main ) Freehand drawing with gestures \u00b6 import nib def main ( app : nib . App ): canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#ffffff\" ) last_pos = None def on_pan_start ( e ): nonlocal last_pos last_pos = ( e . x , e . y ) def on_pan_update ( e ): nonlocal last_pos canvas . append ( nib . draw . Line ( x1 = last_pos [ 0 ], y1 = last_pos [ 1 ], x2 = e . x , y2 = e . y , stroke = \"#000000\" , stroke_width = 3 , )) last_pos = ( e . x , e . y ) canvas . on_pan_start = on_pan_start canvas . on_pan_update = on_pan_update app . build ( nib . VStack ( controls = [ canvas , nib . Button ( \"Clear\" , action = canvas . clear ), ], spacing = 8 , padding = 16 ) ) nib . run ( main ) Drawing with gradients \u00b6 import nib def main ( app : nib . App ): canvas = nib . Canvas ( width = 400 , height = 300 ) canvas . draw ([ nib . draw . Rect ( x = 10 , y = 10 , width = 180 , height = 130 , fill = nib . draw . LinearGradient ( start = ( 10 , 10 ), end = ( 190 , 140 ), colors = [ \"#FF0000\" , \"#0000FF\" ], ), corner_radius = 8 , ), nib . draw . Circle ( cx = 300 , cy = 100 , radius = 60 , fill = nib . draw . RadialGradient ( center = ( 300 , 100 ), radius = 60 , colors = [ \"#FFFF00\" , \"#FF0000\" ], ), ), ]) app . build ( canvas ) nib . run ( main ) Interactive dot painting \u00b6 import nib def main ( app : nib . App ): canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#f5f5f5\" ) def on_pan_update ( e ): canvas . append ( nib . draw . Circle ( cx = e . x , cy = e . y , radius = 5 , fill = \"#3B82F6\" ) ) canvas . on_pan_update = on_pan_update app . build ( canvas ) nib . run ( main )","title":"Canvas"},{"location":"reference/views/effects/canvas/#constructor","text":"nib . Canvas ( width = 100 , height = 100 , commands = None , background_color = None , enable_gestures = False , on_pan_start = None , on_pan_update = None , on_pan_end = None , on_hover = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/effects/canvas/#parameters","text":"Parameter Type Default Description width float 100 Width of the canvas drawing area in points. height float 100 Height of the canvas drawing area in points. commands list[DrawCommand] None Initial list of drawing commands to render. background_color str None Background color as a hex string (e.g., \"#1a1a1a\" ). None for transparent. enable_gestures bool False Enable pan/hover gesture tracking. Automatically enabled when any gesture callback is set. on_pan_start Callable[[PanEvent], None] None Callback invoked when mouse/pen is pressed down on the canvas. on_pan_update Callable[[PanEvent], None] None Callback invoked when mouse/pen is dragged across the canvas. on_pan_end Callable[[PanEvent], None] None Callback invoked when mouse/pen is released. on_hover Callable[[PanEvent], None] None Callback invoked when the mouse moves over the canvas without pressing. **modifiers Common view modifiers: padding , opacity , corner_radius , etc.","title":"Parameters"},{"location":"reference/views/effects/canvas/#mutable-properties","text":"Property Type Description canvas_width float Get or set the drawing area width. Setting triggers a re-render. canvas_height float Get or set the drawing area height. Setting triggers a re-render. background_color str \\| None Get or set the background color. commands list[DrawCommand] Get the current list of drawing commands (read-only). on_pan_start Callable \\| None Get or set the pan start callback. Setting a callback auto-enables gestures. on_pan_update Callable \\| None Get or set the pan update callback. on_pan_end Callable \\| None Get or set the pan end callback. on_hover Callable \\| None Get or set the hover callback.","title":"Mutable Properties"},{"location":"reference/views/effects/canvas/#methods","text":"Method Signature Description draw draw(commands: list[DrawCommand]) Replace all drawing commands and re-render. append append(command: DrawCommand) Add a single drawing command and re-render. clear clear() Remove all drawing commands and re-render.","title":"Methods"},{"location":"reference/views/effects/canvas/#panevent","text":"A dataclass passed to gesture callbacks containing the pointer position. Field Type Description x float X coordinate of the event in canvas coordinates. y float Y coordinate of the event in canvas coordinates.","title":"PanEvent"},{"location":"reference/views/effects/canvas/#examples","text":"","title":"Examples"},{"location":"reference/views/effects/canvas/#basic-drawing","text":"import nib def main ( app : nib . App ): canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#1a1a1a\" ) canvas . draw ([ nib . draw . Rect ( x = 10 , y = 10 , width = 100 , height = 50 , fill = \"#3498db\" ), nib . draw . Circle ( cx = 200 , cy = 100 , radius = 40 , fill = \"#e74c3c\" ), nib . draw . Text ( \"Hello Canvas!\" , x = 10 , y = 280 , fill = \"#ffffff\" ), ]) app . build ( canvas ) nib . run ( main )","title":"Basic drawing"},{"location":"reference/views/effects/canvas/#freehand-drawing-with-gestures","text":"import nib def main ( app : nib . App ): canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#ffffff\" ) last_pos = None def on_pan_start ( e ): nonlocal last_pos last_pos = ( e . x , e . y ) def on_pan_update ( e ): nonlocal last_pos canvas . append ( nib . draw . Line ( x1 = last_pos [ 0 ], y1 = last_pos [ 1 ], x2 = e . x , y2 = e . y , stroke = \"#000000\" , stroke_width = 3 , )) last_pos = ( e . x , e . y ) canvas . on_pan_start = on_pan_start canvas . on_pan_update = on_pan_update app . build ( nib . VStack ( controls = [ canvas , nib . Button ( \"Clear\" , action = canvas . clear ), ], spacing = 8 , padding = 16 ) ) nib . run ( main )","title":"Freehand drawing with gestures"},{"location":"reference/views/effects/canvas/#drawing-with-gradients","text":"import nib def main ( app : nib . App ): canvas = nib . Canvas ( width = 400 , height = 300 ) canvas . draw ([ nib . draw . Rect ( x = 10 , y = 10 , width = 180 , height = 130 , fill = nib . draw . LinearGradient ( start = ( 10 , 10 ), end = ( 190 , 140 ), colors = [ \"#FF0000\" , \"#0000FF\" ], ), corner_radius = 8 , ), nib . draw . Circle ( cx = 300 , cy = 100 , radius = 60 , fill = nib . draw . RadialGradient ( center = ( 300 , 100 ), radius = 60 , colors = [ \"#FFFF00\" , \"#FF0000\" ], ), ), ]) app . build ( canvas ) nib . run ( main )","title":"Drawing with gradients"},{"location":"reference/views/effects/canvas/#interactive-dot-painting","text":"import nib def main ( app : nib . App ): canvas = nib . Canvas ( width = 400 , height = 300 , background_color = \"#f5f5f5\" ) def on_pan_update ( e ): canvas . append ( nib . draw . Circle ( cx = e . x , cy = e . y , radius = 5 , fill = \"#3B82F6\" ) ) canvas . on_pan_update = on_pan_update app . build ( canvas ) nib . run ( main )","title":"Interactive dot painting"},{"location":"reference/views/layout/","text":"Layout views arrange child views in structured compositions. They control positioning, spacing, alignment, scrolling, and navigation. All layout views inherit from View and accept common modifiers such as width , height , padding , background , foreground_color , opacity , corner_radius , font , animation , and more as constructor parameters. Stacks \u00b6 View Description VStack Arranges children vertically from top to bottom with optional spacing and horizontal alignment. HStack Arranges children horizontally from leading to trailing with optional spacing and vertical alignment. ZStack Overlays children on top of each other along the z-axis for layered compositions. Containers \u00b6 View Description ScrollView A scrollable container that supports vertical, horizontal, or bidirectional scrolling. List A scrollable column of rows with native list styling and section support. Section Groups related content with optional header and footer text, typically within a List or Form. Form A container for grouping data-entry controls with automatic two-column layout on macOS. Group A transparent container that groups views without adding visual structure. Spacing \u00b6 View Description Spacer Flexible space that expands to fill available room within a stack layout. Grids \u00b6 View Description Grid & GridRow A fixed grid layout with explicit row and column structure. LazyVGrid & LazyHGrid Lazily loaded grid layouts that grow vertically or horizontally. Navigation \u00b6 View Description NavigationStack & NavigationLink Hierarchical drill-down navigation with a managed view stack. DisclosureGroup A collapsible section that shows or hides content on demand.","title":"Index"},{"location":"reference/views/layout/#stacks","text":"View Description VStack Arranges children vertically from top to bottom with optional spacing and horizontal alignment. HStack Arranges children horizontally from leading to trailing with optional spacing and vertical alignment. ZStack Overlays children on top of each other along the z-axis for layered compositions.","title":"Stacks"},{"location":"reference/views/layout/#containers","text":"View Description ScrollView A scrollable container that supports vertical, horizontal, or bidirectional scrolling. List A scrollable column of rows with native list styling and section support. Section Groups related content with optional header and footer text, typically within a List or Form. Form A container for grouping data-entry controls with automatic two-column layout on macOS. Group A transparent container that groups views without adding visual structure.","title":"Containers"},{"location":"reference/views/layout/#spacing","text":"View Description Spacer Flexible space that expands to fill available room within a stack layout.","title":"Spacing"},{"location":"reference/views/layout/#grids","text":"View Description Grid & GridRow A fixed grid layout with explicit row and column structure. LazyVGrid & LazyHGrid Lazily loaded grid layouts that grow vertically or horizontally.","title":"Grids"},{"location":"reference/views/layout/#navigation","text":"View Description NavigationStack & NavigationLink Hierarchical drill-down navigation with a managed view stack. DisclosureGroup A collapsible section that shows or hides content on demand.","title":"Navigation"},{"location":"reference/views/layout/disclosure-group/","text":"A collapsible container that shows or hides content on demand. DisclosureGroup displays a label with a disclosure indicator (chevron) that users can tap to reveal or hide the contained content. This is useful for organizing optional or advanced settings, creating accordion-style interfaces, or reducing visual clutter by hiding less frequently used options. Constructor \u00b6 nib . DisclosureGroup ( label = None , controls = None , is_expanded = False , on_expand = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description label str required The text label displayed in the header. This text is always visible regardless of the expansion state. controls list[View] None Child views shown when the group is expanded and hidden when collapsed. is_expanded bool False Initial expansion state. True starts expanded with content visible; False starts collapsed. on_expand Callable[[bool], None] None Callback invoked when the expansion state changes. Receives True when expanded, False when collapsed. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc. Examples \u00b6 Advanced options \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Toggle ( \"Basic setting\" , is_on = True ), nib . DisclosureGroup ( \"Advanced Options\" , controls = [ nib . Toggle ( \"Enable logging\" , is_on = False ), nib . Toggle ( \"Developer mode\" , is_on = False ), nib . Slider ( \"Verbosity\" , value = 50 , min_value = 0 , max_value = 100 ), ], ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Initially expanded group \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . DisclosureGroup ( \"Quick Settings\" , controls = [ nib . Toggle ( \"Wi-Fi\" , is_on = True ), nib . Toggle ( \"Bluetooth\" , is_on = True ), nib . Toggle ( \"AirDrop\" , is_on = False ), ], is_expanded = True , ), nib . DisclosureGroup ( \"Network Details\" , controls = [ nib . Text ( \"IP: 192.168.1.100\" ), nib . Text ( \"DNS: 8.8.8.8\" ), ], is_expanded = False , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) With expansion callback \u00b6 Track when users expand or collapse sections. import nib def main ( app : nib . App ): status = nib . Text ( \"Sections collapsed\" ) def on_details_expand ( expanded ): if expanded : status . content = \"Details section opened\" else : status . content = \"Details section closed\" app . build ( nib . VStack ( controls = [ status , nib . DisclosureGroup ( \"Details\" , controls = [ nib . Text ( \"Name: Nib Framework\" ), nib . Text ( \"Version: 1.0.0\" ), nib . Text ( \"Platform: macOS\" ), ], on_expand = on_details_expand , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"DisclosureGroup"},{"location":"reference/views/layout/disclosure-group/#constructor","text":"nib . DisclosureGroup ( label = None , controls = None , is_expanded = False , on_expand = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/layout/disclosure-group/#parameters","text":"Parameter Type Default Description label str required The text label displayed in the header. This text is always visible regardless of the expansion state. controls list[View] None Child views shown when the group is expanded and hidden when collapsed. is_expanded bool False Initial expansion state. True starts expanded with content visible; False starts collapsed. on_expand Callable[[bool], None] None Callback invoked when the expansion state changes. Receives True when expanded, False when collapsed. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc.","title":"Parameters"},{"location":"reference/views/layout/disclosure-group/#examples","text":"","title":"Examples"},{"location":"reference/views/layout/disclosure-group/#advanced-options","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Toggle ( \"Basic setting\" , is_on = True ), nib . DisclosureGroup ( \"Advanced Options\" , controls = [ nib . Toggle ( \"Enable logging\" , is_on = False ), nib . Toggle ( \"Developer mode\" , is_on = False ), nib . Slider ( \"Verbosity\" , value = 50 , min_value = 0 , max_value = 100 ), ], ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Advanced options"},{"location":"reference/views/layout/disclosure-group/#initially-expanded-group","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . DisclosureGroup ( \"Quick Settings\" , controls = [ nib . Toggle ( \"Wi-Fi\" , is_on = True ), nib . Toggle ( \"Bluetooth\" , is_on = True ), nib . Toggle ( \"AirDrop\" , is_on = False ), ], is_expanded = True , ), nib . DisclosureGroup ( \"Network Details\" , controls = [ nib . Text ( \"IP: 192.168.1.100\" ), nib . Text ( \"DNS: 8.8.8.8\" ), ], is_expanded = False , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Initially expanded group"},{"location":"reference/views/layout/disclosure-group/#with-expansion-callback","text":"Track when users expand or collapse sections. import nib def main ( app : nib . App ): status = nib . Text ( \"Sections collapsed\" ) def on_details_expand ( expanded ): if expanded : status . content = \"Details section opened\" else : status . content = \"Details section closed\" app . build ( nib . VStack ( controls = [ status , nib . DisclosureGroup ( \"Details\" , controls = [ nib . Text ( \"Name: Nib Framework\" ), nib . Text ( \"Version: 1.0.0\" ), nib . Text ( \"Platform: macOS\" ), ], on_expand = on_details_expand , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"With expansion callback"},{"location":"reference/views/layout/form/","text":"A container for grouping data-entry controls. On macOS, Form typically displays as a two-column layout with labels on the left and controls on the right, providing a clean and consistent appearance for settings and preferences interfaces. Form supports different visual styles and works well with Section for organizing controls into groups. Constructor \u00b6 nib . Form ( controls = None , style = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description controls list[View] None Child views to display within the form. Typically includes controls like Toggle , Picker , TextField , Slider , and Section for grouping. style FormStyle \\| str None The visual style for the form. Options: FormStyle.AUTOMATIC (platform default), FormStyle.COLUMNS (two-column layout, macOS default), FormStyle.GROUPED (grouped sections with visual separation). **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc. Examples \u00b6 Basic settings form \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Form ( controls = [ nib . Toggle ( \"Enable notifications\" , is_on = True ), nib . Picker ( \"Language\" , selection = \"en\" , options = [ \"en\" , \"es\" , \"fr\" ]), nib . TextField ( value = \"\" , placeholder = \"Username\" ), ], style = nib . FormStyle . COLUMNS , padding = 16 , ) ) nib . run ( main ) Form with grouped sections \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Form ( controls = [ nib . Section ( controls = [ nib . Toggle ( \"Dark Mode\" , is_on = False ), nib . Picker ( \"Accent Color\" , selection = \"blue\" , options = [ \"blue\" , \"purple\" , \"green\" , \"orange\" ], ), ], header = \"Appearance\" , ), nib . Section ( controls = [ nib . Toggle ( \"Push notifications\" , is_on = True ), nib . Toggle ( \"Email notifications\" , is_on = False ), ], header = \"Notifications\" , footer = \"Choose how you want to be notified.\" , ), ], style = nib . FormStyle . GROUPED , ) ) nib . run ( main ) Preferences form with slider \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Form ( controls = [ nib . Toggle ( \"Auto-save\" , is_on = True ), nib . Toggle ( \"Launch at login\" , is_on = False ), nib . Picker ( \"Update frequency\" , selection = \"weekly\" , options = [ \"daily\" , \"weekly\" , \"monthly\" ], ), nib . Slider ( \"Volume\" , value = 0.8 , min_value = 0 , max_value = 1 ), ], style = nib . FormStyle . COLUMNS , padding = 16 , ) ) nib . run ( main )","title":"Form"},{"location":"reference/views/layout/form/#constructor","text":"nib . Form ( controls = None , style = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/layout/form/#parameters","text":"Parameter Type Default Description controls list[View] None Child views to display within the form. Typically includes controls like Toggle , Picker , TextField , Slider , and Section for grouping. style FormStyle \\| str None The visual style for the form. Options: FormStyle.AUTOMATIC (platform default), FormStyle.COLUMNS (two-column layout, macOS default), FormStyle.GROUPED (grouped sections with visual separation). **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc.","title":"Parameters"},{"location":"reference/views/layout/form/#examples","text":"","title":"Examples"},{"location":"reference/views/layout/form/#basic-settings-form","text":"import nib def main ( app : nib . App ): app . build ( nib . Form ( controls = [ nib . Toggle ( \"Enable notifications\" , is_on = True ), nib . Picker ( \"Language\" , selection = \"en\" , options = [ \"en\" , \"es\" , \"fr\" ]), nib . TextField ( value = \"\" , placeholder = \"Username\" ), ], style = nib . FormStyle . COLUMNS , padding = 16 , ) ) nib . run ( main )","title":"Basic settings form"},{"location":"reference/views/layout/form/#form-with-grouped-sections","text":"import nib def main ( app : nib . App ): app . build ( nib . Form ( controls = [ nib . Section ( controls = [ nib . Toggle ( \"Dark Mode\" , is_on = False ), nib . Picker ( \"Accent Color\" , selection = \"blue\" , options = [ \"blue\" , \"purple\" , \"green\" , \"orange\" ], ), ], header = \"Appearance\" , ), nib . Section ( controls = [ nib . Toggle ( \"Push notifications\" , is_on = True ), nib . Toggle ( \"Email notifications\" , is_on = False ), ], header = \"Notifications\" , footer = \"Choose how you want to be notified.\" , ), ], style = nib . FormStyle . GROUPED , ) ) nib . run ( main )","title":"Form with grouped sections"},{"location":"reference/views/layout/form/#preferences-form-with-slider","text":"import nib def main ( app : nib . App ): app . build ( nib . Form ( controls = [ nib . Toggle ( \"Auto-save\" , is_on = True ), nib . Toggle ( \"Launch at login\" , is_on = False ), nib . Picker ( \"Update frequency\" , selection = \"weekly\" , options = [ \"daily\" , \"weekly\" , \"monthly\" ], ), nib . Slider ( \"Volume\" , value = 0.8 , min_value = 0 , max_value = 1 ), ], style = nib . FormStyle . COLUMNS , padding = 16 , ) ) nib . run ( main )","title":"Preferences form with slider"},{"location":"reference/views/layout/grid/","text":"Grid arranges views in a fixed two-dimensional layout with explicit row and column structure. Unlike LazyVGrid and LazyHGrid , Grid sizes all views immediately rather than lazily. Use GridRow to define individual rows within the grid. The number of columns is determined by the row with the most children. Constructor \u00b6 nib . Grid ( controls = None , alignment = None , horizontal_spacing = None , vertical_spacing = None , ** modifiers , ) nib . GridRow ( controls = None , alignment = None , ** modifiers , ) Parameters \u00b6 Grid \u00b6 Parameter Type Default Description controls list[View] None Child views, typically GridRow elements that define the grid structure. alignment str None Default alignment for all cells in the grid. horizontal_spacing float None Spacing in points between columns. vertical_spacing float None Spacing in points between rows. **modifiers Common view modifiers: padding , background , width , height , etc. GridRow \u00b6 Parameter Type Default Description controls list[View] None Views in this row. Each view occupies one column. alignment str None Vertical alignment for this specific row, overriding the grid default. **modifiers Common view modifiers. Mutable Properties \u00b6 Property Type Description controls list[View] Get or set the child views (on both Grid and GridRow). Setting triggers a UI update. Examples \u00b6 Simple 2x2 grid \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Grid ( controls = [ nib . GridRow ( controls = [ nib . Text ( \"A\" , padding = 8 ), nib . Text ( \"B\" , padding = 8 ), ]), nib . GridRow ( controls = [ nib . Text ( \"C\" , padding = 8 ), nib . Text ( \"D\" , padding = 8 ), ]), ], horizontal_spacing = 10 , vertical_spacing = 10 , padding = 16 , ) ) nib . run ( main ) Label-value grid \u00b6 Grid works well for creating aligned label-value pairs. import nib def main ( app : nib . App ): app . build ( nib . Grid ( controls = [ nib . GridRow ( controls = [ nib . Text ( \"Name:\" , foreground_color = nib . Color . SECONDARY ), nib . Text ( \"Nib Framework\" ), ], alignment = \"center\" , ), nib . GridRow ( controls = [ nib . Text ( \"Version:\" , foreground_color = nib . Color . SECONDARY ), nib . Text ( \"1.0.0\" ), ], alignment = \"center\" , ), nib . GridRow ( controls = [ nib . Text ( \"Platform:\" , foreground_color = nib . Color . SECONDARY ), nib . Text ( \"macOS\" ), ], alignment = \"center\" , ), ], horizontal_spacing = 16 , vertical_spacing = 8 , padding = 16 , ) ) nib . run ( main ) Grid with mixed content \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Grid ( controls = [ nib . GridRow ( controls = [ nib . Image ( system_name = \"star.fill\" ), nib . Text ( \"Favorites\" ), nib . Text ( \"12\" ), ]), nib . GridRow ( controls = [ nib . Image ( system_name = \"clock.fill\" ), nib . Text ( \"Recent\" ), nib . Text ( \"5\" ), ]), nib . GridRow ( controls = [ nib . Image ( system_name = \"folder.fill\" ), nib . Text ( \"Documents\" ), nib . Text ( \"34\" ), ]), ], horizontal_spacing = 12 , vertical_spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Grid & GridRow"},{"location":"reference/views/layout/grid/#constructor","text":"nib . Grid ( controls = None , alignment = None , horizontal_spacing = None , vertical_spacing = None , ** modifiers , ) nib . GridRow ( controls = None , alignment = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/layout/grid/#parameters","text":"","title":"Parameters"},{"location":"reference/views/layout/grid/#grid","text":"Parameter Type Default Description controls list[View] None Child views, typically GridRow elements that define the grid structure. alignment str None Default alignment for all cells in the grid. horizontal_spacing float None Spacing in points between columns. vertical_spacing float None Spacing in points between rows. **modifiers Common view modifiers: padding , background , width , height , etc.","title":"Grid"},{"location":"reference/views/layout/grid/#gridrow","text":"Parameter Type Default Description controls list[View] None Views in this row. Each view occupies one column. alignment str None Vertical alignment for this specific row, overriding the grid default. **modifiers Common view modifiers.","title":"GridRow"},{"location":"reference/views/layout/grid/#mutable-properties","text":"Property Type Description controls list[View] Get or set the child views (on both Grid and GridRow). Setting triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/layout/grid/#examples","text":"","title":"Examples"},{"location":"reference/views/layout/grid/#simple-2x2-grid","text":"import nib def main ( app : nib . App ): app . build ( nib . Grid ( controls = [ nib . GridRow ( controls = [ nib . Text ( \"A\" , padding = 8 ), nib . Text ( \"B\" , padding = 8 ), ]), nib . GridRow ( controls = [ nib . Text ( \"C\" , padding = 8 ), nib . Text ( \"D\" , padding = 8 ), ]), ], horizontal_spacing = 10 , vertical_spacing = 10 , padding = 16 , ) ) nib . run ( main )","title":"Simple 2x2 grid"},{"location":"reference/views/layout/grid/#label-value-grid","text":"Grid works well for creating aligned label-value pairs. import nib def main ( app : nib . App ): app . build ( nib . Grid ( controls = [ nib . GridRow ( controls = [ nib . Text ( \"Name:\" , foreground_color = nib . Color . SECONDARY ), nib . Text ( \"Nib Framework\" ), ], alignment = \"center\" , ), nib . GridRow ( controls = [ nib . Text ( \"Version:\" , foreground_color = nib . Color . SECONDARY ), nib . Text ( \"1.0.0\" ), ], alignment = \"center\" , ), nib . GridRow ( controls = [ nib . Text ( \"Platform:\" , foreground_color = nib . Color . SECONDARY ), nib . Text ( \"macOS\" ), ], alignment = \"center\" , ), ], horizontal_spacing = 16 , vertical_spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Label-value grid"},{"location":"reference/views/layout/grid/#grid-with-mixed-content","text":"import nib def main ( app : nib . App ): app . build ( nib . Grid ( controls = [ nib . GridRow ( controls = [ nib . Image ( system_name = \"star.fill\" ), nib . Text ( \"Favorites\" ), nib . Text ( \"12\" ), ]), nib . GridRow ( controls = [ nib . Image ( system_name = \"clock.fill\" ), nib . Text ( \"Recent\" ), nib . Text ( \"5\" ), ]), nib . GridRow ( controls = [ nib . Image ( system_name = \"folder.fill\" ), nib . Text ( \"Documents\" ), nib . Text ( \"34\" ), ]), ], horizontal_spacing = 12 , vertical_spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Grid with mixed content"},{"location":"reference/views/layout/group/","text":"A transparent container that groups multiple views together without adding any visual structure or layout behavior. Group does not impose positioning or spacing on its children, unlike VStack, HStack, or other layout containers. Common use cases include applying modifiers to multiple views at once, returning multiple views from conditional expressions, and organizing code without affecting visual output. Constructor \u00b6 nib . Group ( controls = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description controls list[View] None Child views to group together. The views are rendered without any additional layout structure imposed by the group itself. **modifiers Common view modifiers applied to the group as a whole, affecting all children: padding , background , foreground_color , opacity , font , etc. Examples \u00b6 Shared styling \u00b6 Apply a single modifier to multiple views at once by wrapping them in a Group. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Group ( controls = [ nib . Text ( \"Important\" ), nib . Text ( \"Information\" ), ], foreground_color = nib . Color . RED , ), nib . Text ( \"Normal text\" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Conditional content \u00b6 Use Group to return multiple views from a conditional branch where a single parent is required. import nib def main ( app : nib . App ): show_details = True if show_details : content = nib . Group ( controls = [ nib . Text ( \"Title\" , font = nib . Font . HEADLINE ), nib . Text ( \"Subtitle\" ), nib . Text ( \"Description\" ), ], ) else : content = nib . Text ( \"Title only\" ) app . build ( nib . VStack ( controls = [ content ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Shared opacity \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Group ( controls = [ nib . Image ( system_name = \"star.fill\" ), nib . Text ( \"Favorite\" ), ], opacity = 0.5 , ), nib . Text ( \"Full opacity text\" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Group"},{"location":"reference/views/layout/group/#constructor","text":"nib . Group ( controls = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/layout/group/#parameters","text":"Parameter Type Default Description controls list[View] None Child views to group together. The views are rendered without any additional layout structure imposed by the group itself. **modifiers Common view modifiers applied to the group as a whole, affecting all children: padding , background , foreground_color , opacity , font , etc.","title":"Parameters"},{"location":"reference/views/layout/group/#examples","text":"","title":"Examples"},{"location":"reference/views/layout/group/#shared-styling","text":"Apply a single modifier to multiple views at once by wrapping them in a Group. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Group ( controls = [ nib . Text ( \"Important\" ), nib . Text ( \"Information\" ), ], foreground_color = nib . Color . RED , ), nib . Text ( \"Normal text\" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Shared styling"},{"location":"reference/views/layout/group/#conditional-content","text":"Use Group to return multiple views from a conditional branch where a single parent is required. import nib def main ( app : nib . App ): show_details = True if show_details : content = nib . Group ( controls = [ nib . Text ( \"Title\" , font = nib . Font . HEADLINE ), nib . Text ( \"Subtitle\" ), nib . Text ( \"Description\" ), ], ) else : content = nib . Text ( \"Title only\" ) app . build ( nib . VStack ( controls = [ content ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Conditional content"},{"location":"reference/views/layout/group/#shared-opacity","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Group ( controls = [ nib . Image ( system_name = \"star.fill\" ), nib . Text ( \"Favorite\" ), ], opacity = 0.5 , ), nib . Text ( \"Full opacity text\" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Shared opacity"},{"location":"reference/views/layout/hstack/","text":"A horizontal stack layout that arranges its child views from leading to trailing (left to right in left-to-right locales). HStack is one of the primary layout containers in Nib, commonly used for toolbars, icon-label pairs, and side-by-side content. Children are rendered in the order they appear in the controls list, with optional spacing between them and configurable vertical alignment. Constructor \u00b6 nib . HStack ( controls = None , spacing = None , alignment = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description controls list[View] None Child views to arrange horizontally, rendered from leading to trailing. spacing float None Distance in points between adjacent child views. When None , the system default spacing is used. alignment VerticalAlignment \\| str None Vertical alignment of children within the stack. Options: VerticalAlignment.TOP , VerticalAlignment.CENTER , VerticalAlignment.BOTTOM . Defaults to center. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , on_drop , on_hover , on_click , etc. Mutable Properties \u00b6 Property Type Description controls list[View] Get or set the child views. Setting triggers a UI update. Examples \u00b6 Icon with label \u00b6 import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Image ( system_name = \"star.fill\" ), nib . Text ( \"Favorites\" ), ], spacing = 8 , alignment = nib . VerticalAlignment . CENTER , padding = 12 , ) ) nib . run ( main ) Toolbar with spacers \u00b6 Use Spacer to push elements to opposite edges. Multiple spacers divide available space equally. import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Button ( \"Back\" , action = lambda : print ( \"back\" )), nib . Spacer (), nib . Text ( \"Title\" , font = nib . Font . HEADLINE ), nib . Spacer (), nib . Button ( \"Done\" , action = lambda : print ( \"done\" )), ], spacing = 8 , padding = { \"horizontal\" : 16 , \"vertical\" : 8 }, ) ) nib . run ( main ) Nested stacks \u00b6 Combine HStack and VStack to create more complex layouts. import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Image ( system_name = \"person.fill\" , width = 40 , height = 40 ), nib . VStack ( controls = [ nib . Text ( \"Username\" , font = nib . Font . HEADLINE ), nib . Text ( \"Online\" , foreground_color = nib . Color . SECONDARY ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), ], spacing = 12 , alignment = nib . VerticalAlignment . CENTER , padding = 16 , ) ) nib . run ( main )","title":"HStack"},{"location":"reference/views/layout/hstack/#constructor","text":"nib . HStack ( controls = None , spacing = None , alignment = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/layout/hstack/#parameters","text":"Parameter Type Default Description controls list[View] None Child views to arrange horizontally, rendered from leading to trailing. spacing float None Distance in points between adjacent child views. When None , the system default spacing is used. alignment VerticalAlignment \\| str None Vertical alignment of children within the stack. Options: VerticalAlignment.TOP , VerticalAlignment.CENTER , VerticalAlignment.BOTTOM . Defaults to center. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , on_drop , on_hover , on_click , etc.","title":"Parameters"},{"location":"reference/views/layout/hstack/#mutable-properties","text":"Property Type Description controls list[View] Get or set the child views. Setting triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/layout/hstack/#examples","text":"","title":"Examples"},{"location":"reference/views/layout/hstack/#icon-with-label","text":"import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Image ( system_name = \"star.fill\" ), nib . Text ( \"Favorites\" ), ], spacing = 8 , alignment = nib . VerticalAlignment . CENTER , padding = 12 , ) ) nib . run ( main )","title":"Icon with label"},{"location":"reference/views/layout/hstack/#toolbar-with-spacers","text":"Use Spacer to push elements to opposite edges. Multiple spacers divide available space equally. import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Button ( \"Back\" , action = lambda : print ( \"back\" )), nib . Spacer (), nib . Text ( \"Title\" , font = nib . Font . HEADLINE ), nib . Spacer (), nib . Button ( \"Done\" , action = lambda : print ( \"done\" )), ], spacing = 8 , padding = { \"horizontal\" : 16 , \"vertical\" : 8 }, ) ) nib . run ( main )","title":"Toolbar with spacers"},{"location":"reference/views/layout/hstack/#nested-stacks","text":"Combine HStack and VStack to create more complex layouts. import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Image ( system_name = \"person.fill\" , width = 40 , height = 40 ), nib . VStack ( controls = [ nib . Text ( \"Username\" , font = nib . Font . HEADLINE ), nib . Text ( \"Online\" , foreground_color = nib . Color . SECONDARY ), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 2 , ), ], spacing = 12 , alignment = nib . VerticalAlignment . CENTER , padding = 16 , ) ) nib . run ( main )","title":"Nested stacks"},{"location":"reference/views/layout/lazy-grid/","text":"Lazily loaded grid layouts that grow in one direction. LazyVGrid creates a grid that grows vertically with columns defined by GridItem specifications. LazyHGrid creates a grid that grows horizontally with rows defined by GridItem specifications. Views are loaded lazily as they become visible. Constructor \u00b6 nib . LazyVGrid ( columns = None , controls = None , spacing = None , alignment = None , pinned_views = None , ** modifiers , ) nib . LazyHGrid ( rows = None , controls = None , spacing = None , alignment = None , pinned_views = None , ** modifiers , ) Parameters \u00b6 LazyVGrid \u00b6 Parameter Type Default Description columns list[GridItem] required Column specifications that define the grid layout. controls list[View] None Child views to arrange in the grid. spacing float None Vertical spacing in points between rows. alignment str None Horizontal alignment of grid content. pinned_views list[str] None Views to pin to top/bottom. Options: \"header\" , \"footer\" . **modifiers Common view modifiers: padding , background , width , height , etc. LazyHGrid \u00b6 Parameter Type Default Description rows list[GridItem] required Row specifications that define the grid layout. controls list[View] None Child views to arrange in the grid. spacing float None Horizontal spacing in points between columns. alignment str None Vertical alignment of grid content. pinned_views list[str] None Views to pin to leading/trailing. Options: \"header\" , \"footer\" . **modifiers Common view modifiers: padding , background , width , height , etc. GridItem \u00b6 GridItem defines the sizing strategy for a column (in LazyVGrid) or row (in LazyHGrid). nib . GridItem ( size = GridItemSize . FLEXIBLE , value = None , maximum = None , spacing = None , alignment = None , ) Parameter Type Default Description size GridItemSize FLEXIBLE Sizing strategy: FIXED , FLEXIBLE , or ADAPTIVE . value float None Size value whose meaning depends on the sizing strategy (see below). maximum float None Maximum size for flexible items. spacing float None Spacing after this column or row. alignment str None Alignment within this column or row. Sizing Strategies \u00b6 Strategy Behavior value meaning GridItemSize.FIXED Exact size, does not grow or shrink. Exact size in points. GridItemSize.FLEXIBLE Expands to fill available space. Minimum size in points. GridItemSize.ADAPTIVE Fits as many items as possible. Minimum item size in points. Convenience Constructors \u00b6 from nib import fixed , flexible , adaptive fixed ( size , spacing = None ) # Fixed-size column/row flexible ( minimum = 10 , maximum = None , spacing = None ) # Flexible column/row adaptive ( minimum , maximum = None , spacing = None ) # Adaptive column/row Mutable Properties \u00b6 Property Type Description controls list[View] Get or set the child views. Setting triggers a UI update. columns list[GridItem] (LazyVGrid) Get or set column specifications. Setting triggers a UI update. rows list[GridItem] (LazyHGrid) Get or set row specifications. Setting triggers a UI update. Examples \u00b6 Three-column grid \u00b6 import nib def main ( app : nib . App ): app . build ( nib . LazyVGrid ( columns = [ nib . GridItem ( nib . GridItemSize . FLEXIBLE ), nib . GridItem ( nib . GridItemSize . FLEXIBLE ), nib . GridItem ( nib . GridItemSize . FLEXIBLE ), ], controls = [ nib . Rectangle ( corner_radius = 8 , fill = f \"# { i * 30 + 40 : 02x }{ i * 20 + 60 : 02x } FF\" , height = 80 , ) for i in range ( 9 ) ], spacing = 10 , padding = 16 , ) ) nib . run ( main ) Adaptive grid \u00b6 The grid automatically fits as many columns as possible, each at least 100 points wide. import nib def main ( app : nib . App ): items = [ f \"Item { i } \" for i in range ( 12 )] app . build ( nib . LazyVGrid ( columns = [ nib . adaptive ( 100 )], controls = [ nib . Text ( item , padding = 12 , background = \"#2a2a2a\" , corner_radius = 8 , ) for item in items ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Horizontal grid with fixed rows \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ScrollView ( controls = [ nib . LazyHGrid ( rows = [ nib . GridItem ( nib . GridItemSize . FIXED , 50 ), nib . GridItem ( nib . GridItemSize . FIXED , 50 ), ], controls = [ nib . Text ( f \"Cell { i } \" , padding = 8 , background = \"#333333\" , corner_radius = 4 ) for i in range ( 20 ) ], spacing = 10 , ), ], axes = \"horizontal\" , padding = 16 , ) ) nib . run ( main )","title":"LazyVGrid & LazyHGrid"},{"location":"reference/views/layout/lazy-grid/#constructor","text":"nib . LazyVGrid ( columns = None , controls = None , spacing = None , alignment = None , pinned_views = None , ** modifiers , ) nib . LazyHGrid ( rows = None , controls = None , spacing = None , alignment = None , pinned_views = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/layout/lazy-grid/#parameters","text":"","title":"Parameters"},{"location":"reference/views/layout/lazy-grid/#lazyvgrid","text":"Parameter Type Default Description columns list[GridItem] required Column specifications that define the grid layout. controls list[View] None Child views to arrange in the grid. spacing float None Vertical spacing in points between rows. alignment str None Horizontal alignment of grid content. pinned_views list[str] None Views to pin to top/bottom. Options: \"header\" , \"footer\" . **modifiers Common view modifiers: padding , background , width , height , etc.","title":"LazyVGrid"},{"location":"reference/views/layout/lazy-grid/#lazyhgrid","text":"Parameter Type Default Description rows list[GridItem] required Row specifications that define the grid layout. controls list[View] None Child views to arrange in the grid. spacing float None Horizontal spacing in points between columns. alignment str None Vertical alignment of grid content. pinned_views list[str] None Views to pin to leading/trailing. Options: \"header\" , \"footer\" . **modifiers Common view modifiers: padding , background , width , height , etc.","title":"LazyHGrid"},{"location":"reference/views/layout/lazy-grid/#griditem","text":"GridItem defines the sizing strategy for a column (in LazyVGrid) or row (in LazyHGrid). nib . GridItem ( size = GridItemSize . FLEXIBLE , value = None , maximum = None , spacing = None , alignment = None , ) Parameter Type Default Description size GridItemSize FLEXIBLE Sizing strategy: FIXED , FLEXIBLE , or ADAPTIVE . value float None Size value whose meaning depends on the sizing strategy (see below). maximum float None Maximum size for flexible items. spacing float None Spacing after this column or row. alignment str None Alignment within this column or row.","title":"GridItem"},{"location":"reference/views/layout/lazy-grid/#sizing-strategies","text":"Strategy Behavior value meaning GridItemSize.FIXED Exact size, does not grow or shrink. Exact size in points. GridItemSize.FLEXIBLE Expands to fill available space. Minimum size in points. GridItemSize.ADAPTIVE Fits as many items as possible. Minimum item size in points.","title":"Sizing Strategies"},{"location":"reference/views/layout/lazy-grid/#convenience-constructors","text":"from nib import fixed , flexible , adaptive fixed ( size , spacing = None ) # Fixed-size column/row flexible ( minimum = 10 , maximum = None , spacing = None ) # Flexible column/row adaptive ( minimum , maximum = None , spacing = None ) # Adaptive column/row","title":"Convenience Constructors"},{"location":"reference/views/layout/lazy-grid/#mutable-properties","text":"Property Type Description controls list[View] Get or set the child views. Setting triggers a UI update. columns list[GridItem] (LazyVGrid) Get or set column specifications. Setting triggers a UI update. rows list[GridItem] (LazyHGrid) Get or set row specifications. Setting triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/layout/lazy-grid/#examples","text":"","title":"Examples"},{"location":"reference/views/layout/lazy-grid/#three-column-grid","text":"import nib def main ( app : nib . App ): app . build ( nib . LazyVGrid ( columns = [ nib . GridItem ( nib . GridItemSize . FLEXIBLE ), nib . GridItem ( nib . GridItemSize . FLEXIBLE ), nib . GridItem ( nib . GridItemSize . FLEXIBLE ), ], controls = [ nib . Rectangle ( corner_radius = 8 , fill = f \"# { i * 30 + 40 : 02x }{ i * 20 + 60 : 02x } FF\" , height = 80 , ) for i in range ( 9 ) ], spacing = 10 , padding = 16 , ) ) nib . run ( main )","title":"Three-column grid"},{"location":"reference/views/layout/lazy-grid/#adaptive-grid","text":"The grid automatically fits as many columns as possible, each at least 100 points wide. import nib def main ( app : nib . App ): items = [ f \"Item { i } \" for i in range ( 12 )] app . build ( nib . LazyVGrid ( columns = [ nib . adaptive ( 100 )], controls = [ nib . Text ( item , padding = 12 , background = \"#2a2a2a\" , corner_radius = 8 , ) for item in items ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Adaptive grid"},{"location":"reference/views/layout/lazy-grid/#horizontal-grid-with-fixed-rows","text":"import nib def main ( app : nib . App ): app . build ( nib . ScrollView ( controls = [ nib . LazyHGrid ( rows = [ nib . GridItem ( nib . GridItemSize . FIXED , 50 ), nib . GridItem ( nib . GridItemSize . FIXED , 50 ), ], controls = [ nib . Text ( f \"Cell { i } \" , padding = 8 , background = \"#333333\" , corner_radius = 4 ) for i in range ( 20 ) ], spacing = 10 , ), ], axes = \"horizontal\" , padding = 16 , ) ) nib . run ( main )","title":"Horizontal grid with fixed rows"},{"location":"reference/views/layout/list/","text":"A container that displays rows of data in a single scrollable column. List provides native list styling including row separators and is optimized for displaying collections of items. Unlike a VStack inside a ScrollView, List offers a more native appearance suited for settings screens, menus, and data tables. It is commonly used together with Section for grouped content. Constructor \u00b6 nib . List ( controls = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description controls list[View] None Child views displayed as rows. Can contain individual views or Section views for grouped content with headers and footers. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc. Examples \u00b6 Simple item list \u00b6 import nib def main ( app : nib . App ): app . build ( nib . List ( controls = [ nib . Text ( \"Apple\" ), nib . Text ( \"Banana\" ), nib . Text ( \"Cherry\" ), nib . Text ( \"Date\" ), ], height = 300 , ) ) nib . run ( main ) List with sections \u00b6 Group related items with Section to add headers and footers. import nib def main ( app : nib . App ): app . build ( nib . List ( controls = [ nib . Section ( controls = [ nib . Text ( \"Apple\" ), nib . Text ( \"Banana\" )], header = \"Fruits\" , ), nib . Section ( controls = [ nib . Text ( \"Carrot\" ), nib . Text ( \"Broccoli\" )], header = \"Vegetables\" , ), ], height = 400 , ) ) nib . run ( main ) Settings-style list \u00b6 Combine List, Section, and input controls to build a settings interface. import nib def main ( app : nib . App ): app . build ( nib . List ( controls = [ nib . Section ( controls = [ nib . Toggle ( \"Notifications\" , is_on = True ), nib . Toggle ( \"Sound\" , is_on = False ), ], header = \"Preferences\" , footer = \"Manage your notification settings.\" , ), nib . Section ( controls = [ nib . NavigationLink ( \"About\" , destination = [ nib . Text ( \"About this app\" ), ]), nib . NavigationLink ( \"Help\" , destination = [ nib . Text ( \"Help page\" ), ]), ], header = \"Information\" , ), ], height = 400 , ) ) nib . run ( main )","title":"List"},{"location":"reference/views/layout/list/#constructor","text":"nib . List ( controls = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/layout/list/#parameters","text":"Parameter Type Default Description controls list[View] None Child views displayed as rows. Can contain individual views or Section views for grouped content with headers and footers. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc.","title":"Parameters"},{"location":"reference/views/layout/list/#examples","text":"","title":"Examples"},{"location":"reference/views/layout/list/#simple-item-list","text":"import nib def main ( app : nib . App ): app . build ( nib . List ( controls = [ nib . Text ( \"Apple\" ), nib . Text ( \"Banana\" ), nib . Text ( \"Cherry\" ), nib . Text ( \"Date\" ), ], height = 300 , ) ) nib . run ( main )","title":"Simple item list"},{"location":"reference/views/layout/list/#list-with-sections","text":"Group related items with Section to add headers and footers. import nib def main ( app : nib . App ): app . build ( nib . List ( controls = [ nib . Section ( controls = [ nib . Text ( \"Apple\" ), nib . Text ( \"Banana\" )], header = \"Fruits\" , ), nib . Section ( controls = [ nib . Text ( \"Carrot\" ), nib . Text ( \"Broccoli\" )], header = \"Vegetables\" , ), ], height = 400 , ) ) nib . run ( main )","title":"List with sections"},{"location":"reference/views/layout/list/#settings-style-list","text":"Combine List, Section, and input controls to build a settings interface. import nib def main ( app : nib . App ): app . build ( nib . List ( controls = [ nib . Section ( controls = [ nib . Toggle ( \"Notifications\" , is_on = True ), nib . Toggle ( \"Sound\" , is_on = False ), ], header = \"Preferences\" , footer = \"Manage your notification settings.\" , ), nib . Section ( controls = [ nib . NavigationLink ( \"About\" , destination = [ nib . Text ( \"About this app\" ), ]), nib . NavigationLink ( \"Help\" , destination = [ nib . Text ( \"Help page\" ), ]), ], header = \"Information\" , ), ], height = 400 , ) ) nib . run ( main )","title":"Settings-style list"},{"location":"reference/views/layout/navigation/","text":"NavigationStack and NavigationLink work together to create hierarchical drill-down navigation interfaces. NavigationStack manages a stack of views, and NavigationLink creates tappable elements that push destination views onto the stack. The stack maintains navigation history, allowing users to return to previous views. The root content is always at the bottom of the stack, with destination views pushed on top as the user navigates. Constructor \u00b6 nib . NavigationStack ( controls = None , ** modifiers , ) nib . NavigationLink ( label = None , destination = None , ** modifiers , ) Parameters \u00b6 NavigationStack \u00b6 Parameter Type Default Description controls list[View] None Root content views displayed initially. These form the base of the navigation stack and are shown when no navigation has occurred or when the user navigates back to the root. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc. NavigationLink \u00b6 Parameter Type Default Description label str required The text label displayed for the navigation link. This text is shown as the tappable element. destination list[View] None Views to display when the link is tapped. These views are pushed onto the NavigationStack. **modifiers Common view modifiers: padding , background , foreground_color , opacity , etc. Examples \u00b6 Basic navigation \u00b6 import nib def main ( app : nib . App ): app . build ( nib . NavigationStack ( controls = [ nib . List ( controls = [ nib . NavigationLink ( \"Settings\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Settings\" , font = nib . Font . TITLE ), nib . Toggle ( \"Dark Mode\" , is_on = False ), nib . Toggle ( \"Notifications\" , is_on = True ), ], spacing = 12 , padding = 16 , ), ]), nib . NavigationLink ( \"About\" , destination = [ nib . Text ( \"About this app\" , padding = 16 ), ]), ], ), ], height = 400 , ) ) nib . run ( main ) Settings navigation with sections \u00b6 import nib def main ( app : nib . App ): app . build ( nib . NavigationStack ( controls = [ nib . List ( controls = [ nib . Section ( controls = [ nib . NavigationLink ( \"Profile\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Profile Settings\" , font = nib . Font . TITLE ), nib . TextField ( value = \"\" , placeholder = \"Display Name\" ), ], spacing = 12 , padding = 16 , ), ]), nib . NavigationLink ( \"Notifications\" , destination = [ nib . Form ( controls = [ nib . Toggle ( \"Push\" , is_on = True ), nib . Toggle ( \"Email\" , is_on = False ), ]), ]), ], header = \"Account\" , ), nib . Section ( controls = [ nib . NavigationLink ( \"Privacy\" , destination = [ nib . Text ( \"Privacy settings\" ), ]), nib . NavigationLink ( \"Help\" , destination = [ nib . Text ( \"Help content\" ), ]), ], header = \"General\" , ), ], ), ], height = 500 , ) ) nib . run ( main ) Dynamic navigation links \u00b6 Generate navigation links from a data source. import nib def main ( app : nib . App ): pages = [ { \"title\" : \"Dashboard\" , \"content\" : \"Dashboard overview\" }, { \"title\" : \"Analytics\" , \"content\" : \"Analytics data\" }, { \"title\" : \"Reports\" , \"content\" : \"Generated reports\" }, ] app . build ( nib . NavigationStack ( controls = [ nib . List ( controls = [ nib . NavigationLink ( page [ \"title\" ], destination = [ nib . VStack ( controls = [ nib . Text ( page [ \"title\" ], font = nib . Font . TITLE ), nib . Text ( page [ \"content\" ]), ], spacing = 8 , padding = 16 , ), ], ) for page in pages ], ), ], height = 400 , ) ) nib . run ( main )","title":"NavigationStack & NavigationLink"},{"location":"reference/views/layout/navigation/#constructor","text":"nib . NavigationStack ( controls = None , ** modifiers , ) nib . NavigationLink ( label = None , destination = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/layout/navigation/#parameters","text":"","title":"Parameters"},{"location":"reference/views/layout/navigation/#navigationstack","text":"Parameter Type Default Description controls list[View] None Root content views displayed initially. These form the base of the navigation stack and are shown when no navigation has occurred or when the user navigates back to the root. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc.","title":"NavigationStack"},{"location":"reference/views/layout/navigation/#navigationlink","text":"Parameter Type Default Description label str required The text label displayed for the navigation link. This text is shown as the tappable element. destination list[View] None Views to display when the link is tapped. These views are pushed onto the NavigationStack. **modifiers Common view modifiers: padding , background , foreground_color , opacity , etc.","title":"NavigationLink"},{"location":"reference/views/layout/navigation/#examples","text":"","title":"Examples"},{"location":"reference/views/layout/navigation/#basic-navigation","text":"import nib def main ( app : nib . App ): app . build ( nib . NavigationStack ( controls = [ nib . List ( controls = [ nib . NavigationLink ( \"Settings\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Settings\" , font = nib . Font . TITLE ), nib . Toggle ( \"Dark Mode\" , is_on = False ), nib . Toggle ( \"Notifications\" , is_on = True ), ], spacing = 12 , padding = 16 , ), ]), nib . NavigationLink ( \"About\" , destination = [ nib . Text ( \"About this app\" , padding = 16 ), ]), ], ), ], height = 400 , ) ) nib . run ( main )","title":"Basic navigation"},{"location":"reference/views/layout/navigation/#settings-navigation-with-sections","text":"import nib def main ( app : nib . App ): app . build ( nib . NavigationStack ( controls = [ nib . List ( controls = [ nib . Section ( controls = [ nib . NavigationLink ( \"Profile\" , destination = [ nib . VStack ( controls = [ nib . Text ( \"Profile Settings\" , font = nib . Font . TITLE ), nib . TextField ( value = \"\" , placeholder = \"Display Name\" ), ], spacing = 12 , padding = 16 , ), ]), nib . NavigationLink ( \"Notifications\" , destination = [ nib . Form ( controls = [ nib . Toggle ( \"Push\" , is_on = True ), nib . Toggle ( \"Email\" , is_on = False ), ]), ]), ], header = \"Account\" , ), nib . Section ( controls = [ nib . NavigationLink ( \"Privacy\" , destination = [ nib . Text ( \"Privacy settings\" ), ]), nib . NavigationLink ( \"Help\" , destination = [ nib . Text ( \"Help content\" ), ]), ], header = \"General\" , ), ], ), ], height = 500 , ) ) nib . run ( main )","title":"Settings navigation with sections"},{"location":"reference/views/layout/navigation/#dynamic-navigation-links","text":"Generate navigation links from a data source. import nib def main ( app : nib . App ): pages = [ { \"title\" : \"Dashboard\" , \"content\" : \"Dashboard overview\" }, { \"title\" : \"Analytics\" , \"content\" : \"Analytics data\" }, { \"title\" : \"Reports\" , \"content\" : \"Generated reports\" }, ] app . build ( nib . NavigationStack ( controls = [ nib . List ( controls = [ nib . NavigationLink ( page [ \"title\" ], destination = [ nib . VStack ( controls = [ nib . Text ( page [ \"title\" ], font = nib . Font . TITLE ), nib . Text ( page [ \"content\" ]), ], spacing = 8 , padding = 16 , ), ], ) for page in pages ], ), ], height = 400 , ) ) nib . run ( main )","title":"Dynamic navigation links"},{"location":"reference/views/layout/scrollview/","text":"A scrollable container that allows content to exceed the visible bounds. ScrollView supports vertical, horizontal, or bidirectional scrolling with optional scroll indicators. The scroll view automatically determines the content size based on its children and enables scrolling when the content exceeds the available space. Constructor \u00b6 nib . ScrollView ( controls = None , axes = \"vertical\" , shows_indicators = True , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description controls list[View] None Child views to display in the scrollable region. The content size is determined by the combined size of all children. axes str \"vertical\" The scroll direction. Options: \"vertical\" (up/down), \"horizontal\" (left/right), \"both\" (bidirectional). shows_indicators bool True Whether to display scroll indicators (scrollbars). Set to False for a cleaner appearance when indicators are not needed. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc. Examples \u00b6 Vertical scrollable list \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ScrollView ( controls = [ nib . VStack ( controls = [ nib . Text ( f \"Item { i } \" ) for i in range ( 50 )], spacing = 4 , ), ], height = 300 , padding = 8 , ) ) nib . run ( main ) Horizontal scrolling gallery \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ScrollView ( controls = [ nib . HStack ( controls = [ nib . Rectangle ( corner_radius = 8 , fill = color , width = 100 , height = 100 , ) for color in [ \"#FF6B6B\" , \"#4ECDC4\" , \"#45B7D1\" , \"#96CEB4\" , \"#FFEAA7\" ] ], spacing = 8 , ), ], axes = \"horizontal\" , shows_indicators = False , padding = 16 , ) ) nib . run ( main ) Scrollable form \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ScrollView ( controls = [ nib . VStack ( controls = [ nib . TextField ( value = \"\" , placeholder = \"Name\" ), nib . TextField ( value = \"\" , placeholder = \"Email\" ), nib . TextField ( value = \"\" , placeholder = \"Subject\" ), nib . TextEditor ( value = \"\" , placeholder = \"Message\" ), nib . Button ( \"Submit\" , action = lambda : print ( \"submitted\" )), ], spacing = 12 , padding = 16 , ), ], axes = \"vertical\" , shows_indicators = True , height = 400 , ) ) nib . run ( main )","title":"ScrollView"},{"location":"reference/views/layout/scrollview/#constructor","text":"nib . ScrollView ( controls = None , axes = \"vertical\" , shows_indicators = True , ** modifiers , )","title":"Constructor"},{"location":"reference/views/layout/scrollview/#parameters","text":"Parameter Type Default Description controls list[View] None Child views to display in the scrollable region. The content size is determined by the combined size of all children. axes str \"vertical\" The scroll direction. Options: \"vertical\" (up/down), \"horizontal\" (left/right), \"both\" (bidirectional). shows_indicators bool True Whether to display scroll indicators (scrollbars). Set to False for a cleaner appearance when indicators are not needed. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc.","title":"Parameters"},{"location":"reference/views/layout/scrollview/#examples","text":"","title":"Examples"},{"location":"reference/views/layout/scrollview/#vertical-scrollable-list","text":"import nib def main ( app : nib . App ): app . build ( nib . ScrollView ( controls = [ nib . VStack ( controls = [ nib . Text ( f \"Item { i } \" ) for i in range ( 50 )], spacing = 4 , ), ], height = 300 , padding = 8 , ) ) nib . run ( main )","title":"Vertical scrollable list"},{"location":"reference/views/layout/scrollview/#horizontal-scrolling-gallery","text":"import nib def main ( app : nib . App ): app . build ( nib . ScrollView ( controls = [ nib . HStack ( controls = [ nib . Rectangle ( corner_radius = 8 , fill = color , width = 100 , height = 100 , ) for color in [ \"#FF6B6B\" , \"#4ECDC4\" , \"#45B7D1\" , \"#96CEB4\" , \"#FFEAA7\" ] ], spacing = 8 , ), ], axes = \"horizontal\" , shows_indicators = False , padding = 16 , ) ) nib . run ( main )","title":"Horizontal scrolling gallery"},{"location":"reference/views/layout/scrollview/#scrollable-form","text":"import nib def main ( app : nib . App ): app . build ( nib . ScrollView ( controls = [ nib . VStack ( controls = [ nib . TextField ( value = \"\" , placeholder = \"Name\" ), nib . TextField ( value = \"\" , placeholder = \"Email\" ), nib . TextField ( value = \"\" , placeholder = \"Subject\" ), nib . TextEditor ( value = \"\" , placeholder = \"Message\" ), nib . Button ( \"Submit\" , action = lambda : print ( \"submitted\" )), ], spacing = 12 , padding = 16 , ), ], axes = \"vertical\" , shows_indicators = True , height = 400 , ) ) nib . run ( main )","title":"Scrollable form"},{"location":"reference/views/layout/section/","text":"A container for grouping related content with optional header and footer text. Section is designed to be used within a List or Form to organize content into logical groups. The header typically describes the section's purpose, while the footer provides additional context, explanations, or disclaimers. Constructor \u00b6 nib . Section ( controls = None , header = None , footer = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description controls list[View] None Child views to display within the section, rendered between the header and footer. header str None Text displayed above the section content. Rendered in a secondary text style. footer str None Text displayed below the section content. Rendered in a smaller, secondary text style. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc. Examples \u00b6 Section with header \u00b6 import nib def main ( app : nib . App ): app . build ( nib . List ( controls = [ nib . Section ( controls = [ nib . Text ( \"Item 1\" ), nib . Text ( \"Item 2\" ), nib . Text ( \"Item 3\" ), ], header = \"My Section\" , ), ], height = 300 , ) ) nib . run ( main ) Section with header and footer \u00b6 import nib def main ( app : nib . App ): app . build ( nib . List ( controls = [ nib . Section ( controls = [ nib . Toggle ( \"Dark Mode\" , is_on = False ), nib . Toggle ( \"Auto-brightness\" , is_on = True ), ], header = \"Display\" , footer = \"Adjust display settings for comfortable viewing.\" , ), ], height = 300 , ) ) nib . run ( main ) Multiple sections in a form \u00b6 import nib def main ( app : nib . App ): app . build ( nib . Form ( controls = [ nib . Section ( controls = [ nib . TextField ( value = \"\" , placeholder = \"Username\" ), nib . SecureField ( value = \"\" , placeholder = \"Password\" ), ], header = \"Account\" , ), nib . Section ( controls = [ nib . Toggle ( \"Push notifications\" , is_on = True ), nib . Toggle ( \"Email notifications\" , is_on = False ), ], header = \"Notifications\" , footer = \"Choose how you want to be notified.\" , ), ], padding = 16 , ) ) nib . run ( main )","title":"Section"},{"location":"reference/views/layout/section/#constructor","text":"nib . Section ( controls = None , header = None , footer = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/layout/section/#parameters","text":"Parameter Type Default Description controls list[View] None Child views to display within the section, rendered between the header and footer. header str None Text displayed above the section content. Rendered in a secondary text style. footer str None Text displayed below the section content. Rendered in a smaller, secondary text style. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , etc.","title":"Parameters"},{"location":"reference/views/layout/section/#examples","text":"","title":"Examples"},{"location":"reference/views/layout/section/#section-with-header","text":"import nib def main ( app : nib . App ): app . build ( nib . List ( controls = [ nib . Section ( controls = [ nib . Text ( \"Item 1\" ), nib . Text ( \"Item 2\" ), nib . Text ( \"Item 3\" ), ], header = \"My Section\" , ), ], height = 300 , ) ) nib . run ( main )","title":"Section with header"},{"location":"reference/views/layout/section/#section-with-header-and-footer","text":"import nib def main ( app : nib . App ): app . build ( nib . List ( controls = [ nib . Section ( controls = [ nib . Toggle ( \"Dark Mode\" , is_on = False ), nib . Toggle ( \"Auto-brightness\" , is_on = True ), ], header = \"Display\" , footer = \"Adjust display settings for comfortable viewing.\" , ), ], height = 300 , ) ) nib . run ( main )","title":"Section with header and footer"},{"location":"reference/views/layout/section/#multiple-sections-in-a-form","text":"import nib def main ( app : nib . App ): app . build ( nib . Form ( controls = [ nib . Section ( controls = [ nib . TextField ( value = \"\" , placeholder = \"Username\" ), nib . SecureField ( value = \"\" , placeholder = \"Password\" ), ], header = \"Account\" , ), nib . Section ( controls = [ nib . Toggle ( \"Push notifications\" , is_on = True ), nib . Toggle ( \"Email notifications\" , is_on = False ), ], header = \"Notifications\" , footer = \"Choose how you want to be notified.\" , ), ], padding = 16 , ) ) nib . run ( main )","title":"Multiple sections in a form"},{"location":"reference/views/layout/spacer/","text":"A flexible space that expands to fill available room within a stack layout. Spacer is a layout primitive that takes up as much space as available in its parent HStack or VStack. In an HStack, Spacer expands horizontally. In a VStack, it expands vertically. When multiple spacers are present, they divide the available space equally. This makes Spacer essential for creating flexible layouts where elements need to be pushed apart or distributed evenly. Constructor \u00b6 nib . Spacer ( min_length = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description min_length float None Minimum length in points that the spacer must occupy, even when space is limited. Useful for ensuring minimum gaps between elements. **modifiers Common view modifiers. While spacers typically do not need visual styling, frame constraints can still be applied. Examples \u00b6 Push content to edges \u00b6 Use a Spacer to push elements to opposite sides of a horizontal stack. import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Text ( \"Left\" ), nib . Spacer (), nib . Text ( \"Right\" ), ], padding = 16 , ) ) nib . run ( main ) Centered title toolbar \u00b6 Two spacers create equal space on both sides of the title, centering it while pushing the buttons to the edges. import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Button ( \"Back\" , action = lambda : print ( \"back\" )), nib . Spacer (), nib . Text ( \"Title\" , font = nib . Font . HEADLINE ), nib . Spacer (), nib . Button ( \"Done\" , action = lambda : print ( \"done\" )), ], padding = { \"horizontal\" : 16 , \"vertical\" : 8 }, ) ) nib . run ( main ) Bottom-aligned footer \u00b6 In a VStack, Spacer pushes subsequent content to the bottom of the container. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Header\" , font = nib . Font . TITLE ), nib . Text ( \"Main content goes here\" ), nib . Spacer ( min_length = 20 ), nib . Text ( \"Footer\" , foreground_color = nib . Color . SECONDARY , font = nib . Font . CAPTION , ), ], height = 400 , padding = 16 , ) ) nib . run ( main )","title":"Spacer"},{"location":"reference/views/layout/spacer/#constructor","text":"nib . Spacer ( min_length = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/layout/spacer/#parameters","text":"Parameter Type Default Description min_length float None Minimum length in points that the spacer must occupy, even when space is limited. Useful for ensuring minimum gaps between elements. **modifiers Common view modifiers. While spacers typically do not need visual styling, frame constraints can still be applied.","title":"Parameters"},{"location":"reference/views/layout/spacer/#examples","text":"","title":"Examples"},{"location":"reference/views/layout/spacer/#push-content-to-edges","text":"Use a Spacer to push elements to opposite sides of a horizontal stack. import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Text ( \"Left\" ), nib . Spacer (), nib . Text ( \"Right\" ), ], padding = 16 , ) ) nib . run ( main )","title":"Push content to edges"},{"location":"reference/views/layout/spacer/#centered-title-toolbar","text":"Two spacers create equal space on both sides of the title, centering it while pushing the buttons to the edges. import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Button ( \"Back\" , action = lambda : print ( \"back\" )), nib . Spacer (), nib . Text ( \"Title\" , font = nib . Font . HEADLINE ), nib . Spacer (), nib . Button ( \"Done\" , action = lambda : print ( \"done\" )), ], padding = { \"horizontal\" : 16 , \"vertical\" : 8 }, ) ) nib . run ( main )","title":"Centered title toolbar"},{"location":"reference/views/layout/spacer/#bottom-aligned-footer","text":"In a VStack, Spacer pushes subsequent content to the bottom of the container. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Header\" , font = nib . Font . TITLE ), nib . Text ( \"Main content goes here\" ), nib . Spacer ( min_length = 20 ), nib . Text ( \"Footer\" , foreground_color = nib . Color . SECONDARY , font = nib . Font . CAPTION , ), ], height = 400 , padding = 16 , ) ) nib . run ( main )","title":"Bottom-aligned footer"},{"location":"reference/views/layout/vstack/","text":"A vertical stack layout that arranges its child views from top to bottom. VStack is one of the primary layout containers in Nib and is used to build most vertical interfaces. Children are rendered in the order they appear in the controls list, with optional spacing between them and configurable horizontal alignment. Constructor \u00b6 nib . VStack ( controls = None , spacing = None , alignment = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description controls list[View] None Child views to arrange vertically, rendered from top to bottom. spacing float None Distance in points between adjacent child views. When None , the system default spacing is used. alignment HorizontalAlignment \\| str None Horizontal alignment of children within the stack. Options: HorizontalAlignment.LEADING , HorizontalAlignment.CENTER , HorizontalAlignment.TRAILING . Defaults to center. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , on_drop , on_hover , on_click , etc. Mutable Properties \u00b6 Property Type Description controls list[View] Get or set the child views. Setting triggers a UI update. Examples \u00b6 Basic vertical layout \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"First\" ), nib . Text ( \"Second\" ), nib . Text ( \"Third\" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Left-aligned stack with styling \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Title\" , font = nib . Font . TITLE ), nib . Text ( \"Subtitle\" , foreground_color = nib . Color . SECONDARY ), nib . Button ( \"Action\" , action = lambda : print ( \"tapped\" )), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 12 , padding = 16 , background = nib . Rectangle ( corner_radius = 8 , fill = \"#333333\" , ), ) ) nib . run ( main ) Drag and drop \u00b6 VStack supports file drag-and-drop through the on_drop modifier. The callback receives a list of file paths. import nib def main ( app : nib . App ): status = nib . Text ( \"Drop files here\" ) def handle_drop ( paths ): status . content = f \"Received { len ( paths ) } file(s)\" app . build ( nib . VStack ( controls = [ status ], spacing = 8 , padding = 24 , on_drop = handle_drop , background = \"#1a1a1a\" , corner_radius = 12 , ) ) nib . run ( main )","title":"VStack"},{"location":"reference/views/layout/vstack/#constructor","text":"nib . VStack ( controls = None , spacing = None , alignment = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/layout/vstack/#parameters","text":"Parameter Type Default Description controls list[View] None Child views to arrange vertically, rendered from top to bottom. spacing float None Distance in points between adjacent child views. When None , the system default spacing is used. alignment HorizontalAlignment \\| str None Horizontal alignment of children within the stack. Options: HorizontalAlignment.LEADING , HorizontalAlignment.CENTER , HorizontalAlignment.TRAILING . Defaults to center. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , on_drop , on_hover , on_click , etc.","title":"Parameters"},{"location":"reference/views/layout/vstack/#mutable-properties","text":"Property Type Description controls list[View] Get or set the child views. Setting triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/layout/vstack/#examples","text":"","title":"Examples"},{"location":"reference/views/layout/vstack/#basic-vertical-layout","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"First\" ), nib . Text ( \"Second\" ), nib . Text ( \"Third\" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Basic vertical layout"},{"location":"reference/views/layout/vstack/#left-aligned-stack-with-styling","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Title\" , font = nib . Font . TITLE ), nib . Text ( \"Subtitle\" , foreground_color = nib . Color . SECONDARY ), nib . Button ( \"Action\" , action = lambda : print ( \"tapped\" )), ], alignment = nib . HorizontalAlignment . LEADING , spacing = 12 , padding = 16 , background = nib . Rectangle ( corner_radius = 8 , fill = \"#333333\" , ), ) ) nib . run ( main )","title":"Left-aligned stack with styling"},{"location":"reference/views/layout/vstack/#drag-and-drop","text":"VStack supports file drag-and-drop through the on_drop modifier. The callback receives a list of file paths. import nib def main ( app : nib . App ): status = nib . Text ( \"Drop files here\" ) def handle_drop ( paths ): status . content = f \"Received { len ( paths ) } file(s)\" app . build ( nib . VStack ( controls = [ status ], spacing = 8 , padding = 24 , on_drop = handle_drop , background = \"#1a1a1a\" , corner_radius = 12 , ) ) nib . run ( main )","title":"Drag and drop"},{"location":"reference/views/layout/zstack/","text":"A layered stack layout that overlays its child views on top of each other along the z-axis. The first child in the controls list is rendered at the back (bottom layer), and each subsequent child is layered on top. Unlike VStack and HStack which arrange children sequentially, ZStack allows children to occupy the same space. This is useful for creating backgrounds, overlays, badges, and complex layered UI elements. Constructor \u00b6 nib . ZStack ( controls = None , alignment = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description controls list[View] None Child views to layer on top of each other. The first view is at the back, subsequent views are layered on top. alignment Alignment \\| str None Two-dimensional alignment of children within the stack. Options: Alignment.CENTER , Alignment.TOP , Alignment.BOTTOM , Alignment.LEADING , Alignment.TRAILING , Alignment.TOP_LEADING , Alignment.TOP_TRAILING , Alignment.BOTTOM_LEADING , Alignment.BOTTOM_TRAILING . Defaults to center. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , on_hover , on_click , etc. Mutable Properties \u00b6 Property Type Description controls list[View] Get or set the child views. Setting triggers a UI update. Examples \u00b6 Card with background \u00b6 import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Rectangle ( corner_radius = 12 , fill = \"#1a1a1a\" ), nib . VStack ( controls = [ nib . Text ( \"Card Title\" , font = nib . Font . HEADLINE ), nib . Text ( \"Card content goes here\" ), ], spacing = 8 , padding = 16 , ), ], ) ) nib . run ( main ) Badge overlay \u00b6 Position a notification badge in the top-trailing corner of an icon. import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Image ( system_name = \"bell.fill\" , width = 32 , height = 32 ), nib . Circle ( fill = nib . Color . RED , width = 12 , height = 12 ), ], alignment = nib . Alignment . TOP_TRAILING , padding = 16 , ) ) nib . run ( main ) Image with gradient overlay \u00b6 Layer a semi-transparent overlay and text caption on top of an image. import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Image ( url = \"https://example.com/photo.jpg\" , width = 300 , height = 200 ), nib . Rectangle ( fill = nib . Color . BLACK , opacity = 0.3 ), nib . Text ( \"Photo Caption\" , foreground_color = nib . Color . WHITE , font = nib . Font . HEADLINE , ), ], alignment = nib . Alignment . BOTTOM , ) ) nib . run ( main )","title":"ZStack"},{"location":"reference/views/layout/zstack/#constructor","text":"nib . ZStack ( controls = None , alignment = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/layout/zstack/#parameters","text":"Parameter Type Default Description controls list[View] None Child views to layer on top of each other. The first view is at the back, subsequent views are layered on top. alignment Alignment \\| str None Two-dimensional alignment of children within the stack. Options: Alignment.CENTER , Alignment.TOP , Alignment.BOTTOM , Alignment.LEADING , Alignment.TRAILING , Alignment.TOP_LEADING , Alignment.TOP_TRAILING , Alignment.BOTTOM_LEADING , Alignment.BOTTOM_TRAILING . Defaults to center. **modifiers Common view modifiers: padding , background , foreground_color , opacity , width , height , on_hover , on_click , etc.","title":"Parameters"},{"location":"reference/views/layout/zstack/#mutable-properties","text":"Property Type Description controls list[View] Get or set the child views. Setting triggers a UI update.","title":"Mutable Properties"},{"location":"reference/views/layout/zstack/#examples","text":"","title":"Examples"},{"location":"reference/views/layout/zstack/#card-with-background","text":"import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Rectangle ( corner_radius = 12 , fill = \"#1a1a1a\" ), nib . VStack ( controls = [ nib . Text ( \"Card Title\" , font = nib . Font . HEADLINE ), nib . Text ( \"Card content goes here\" ), ], spacing = 8 , padding = 16 , ), ], ) ) nib . run ( main )","title":"Card with background"},{"location":"reference/views/layout/zstack/#badge-overlay","text":"Position a notification badge in the top-trailing corner of an icon. import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Image ( system_name = \"bell.fill\" , width = 32 , height = 32 ), nib . Circle ( fill = nib . Color . RED , width = 12 , height = 12 ), ], alignment = nib . Alignment . TOP_TRAILING , padding = 16 , ) ) nib . run ( main )","title":"Badge overlay"},{"location":"reference/views/layout/zstack/#image-with-gradient-overlay","text":"Layer a semi-transparent overlay and text caption on top of an image. import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Image ( url = \"https://example.com/photo.jpg\" , width = 300 , height = 200 ), nib . Rectangle ( fill = nib . Color . BLACK , opacity = 0.3 ), nib . Text ( \"Photo Caption\" , foreground_color = nib . Color . WHITE , font = nib . Font . HEADLINE , ), ], alignment = nib . Alignment . BOTTOM , ) ) nib . run ( main )","title":"Image with gradient overlay"},{"location":"reference/views/shapes/","text":"Shape views draw geometric forms that can be used as standalone content, backgrounds, overlays, or clip masks. All shapes inherit from View and accept common modifiers such as width , height , padding , background , foreground_color , opacity , corner_radius , font , animation , and more as constructor parameters. Built-in Shapes \u00b6 View Description Rectangle A rectangular shape with optional corner rounding, including per-corner radius control. Circle A circular shape that maintains a 1:1 aspect ratio, with optional trim for progress rings. Ellipse An oval shape that stretches to fill its frame with independent width and height. Capsule A pill-shaped rectangle where the shorter dimension is completely rounded. Custom Shapes \u00b6 View Description Path & Shape Build custom shapes using path operations: lines, curves, arcs, and geometric primitives. Gradients \u00b6 View Description Gradients Color gradients including linear, radial, angular, and elliptical variations. Common Shape Parameters \u00b6 All built-in shapes accept these parameters: Parameter Type Description fill str \\| Color Fill color for the shape interior. Accepts hex strings ( \"#FF5733\" ), named colors ( \"red\" ), or Color instances. stroke_color str \\| Color Stroke color for the shape border. stroke_width float Width of the stroke in points. Shapes are commonly used in three patterns: Standalone -- as visible UI elements with explicit dimensions Background -- passed to the background modifier of another view Clip shape -- passed to the clip_shape modifier to mask content","title":"Index"},{"location":"reference/views/shapes/#built-in-shapes","text":"View Description Rectangle A rectangular shape with optional corner rounding, including per-corner radius control. Circle A circular shape that maintains a 1:1 aspect ratio, with optional trim for progress rings. Ellipse An oval shape that stretches to fill its frame with independent width and height. Capsule A pill-shaped rectangle where the shorter dimension is completely rounded.","title":"Built-in Shapes"},{"location":"reference/views/shapes/#custom-shapes","text":"View Description Path & Shape Build custom shapes using path operations: lines, curves, arcs, and geometric primitives.","title":"Custom Shapes"},{"location":"reference/views/shapes/#gradients","text":"View Description Gradients Color gradients including linear, radial, angular, and elliptical variations.","title":"Gradients"},{"location":"reference/views/shapes/#common-shape-parameters","text":"All built-in shapes accept these parameters: Parameter Type Description fill str \\| Color Fill color for the shape interior. Accepts hex strings ( \"#FF5733\" ), named colors ( \"red\" ), or Color instances. stroke_color str \\| Color Stroke color for the shape border. stroke_width float Width of the stroke in points. Shapes are commonly used in three patterns: Standalone -- as visible UI elements with explicit dimensions Background -- passed to the background modifier of another view Clip shape -- passed to the clip_shape modifier to mask content","title":"Common Shape Parameters"},{"location":"reference/views/shapes/capsule/","text":"A pill-shaped rectangle where the shorter dimension is completely rounded. Capsules are commonly used for buttons, tags, badges, and other UI elements that need a smooth, rounded appearance. For horizontal capsules (width > height), the ends are semicircles with radius equal to half the height. For vertical capsules (height > width), the ends are semicircles with radius equal to half the width. This differs from Rectangle with corner_radius , which uses a fixed corner radius regardless of dimensions. Constructor \u00b6 nib . Capsule ( fill = None , stroke_color = None , stroke_width = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description fill str \\| Color None Fill color for the capsule interior. Accepts hex strings, named colors, or Color instances. stroke_color str \\| Color None Stroke color for the capsule border. stroke_width float None Width of the stroke in points. **modifiers Common view modifiers: width , height , padding , opacity , animation , etc. Examples \u00b6 Basic capsule shapes \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ # Horizontal capsule nib . Capsule ( fill = nib . Color . BLUE , width = 150 , height = 50 ), # Vertical capsule nib . Capsule ( fill = nib . Color . GREEN , width = 40 , height = 120 ), # Capsule with stroke nib . Capsule ( fill = nib . Color . PURPLE , stroke_color = nib . Color . WHITE , stroke_width = 2 , width = 120 , height = 40 , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Tag / badge with capsule background \u00b6 Use a Capsule as the background for text to create pill-shaped labels. import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Text ( \"NEW\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE , padding = { \"horizontal\" : 10 , \"vertical\" : 4 }, background = nib . Capsule ( fill = nib . Color . RED ), ), nib . Text ( \"SALE\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE , padding = { \"horizontal\" : 10 , \"vertical\" : 4 }, background = nib . Capsule ( fill = nib . Color . GREEN ), ), nib . Text ( \"HOT\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE , padding = { \"horizontal\" : 10 , \"vertical\" : 4 }, background = nib . Capsule ( fill = nib . Color . ORANGE ), ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main ) Capsule as clip shape \u00b6 Clip an image into a capsule shape for a banner-style appearance. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Image ( url = \"https://example.com/banner.jpg\" , width = 200 , height = 60 , clip_shape = nib . Capsule (), ), nib . Text ( \"Clipped to capsule shape\" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Capsule"},{"location":"reference/views/shapes/capsule/#constructor","text":"nib . Capsule ( fill = None , stroke_color = None , stroke_width = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/shapes/capsule/#parameters","text":"Parameter Type Default Description fill str \\| Color None Fill color for the capsule interior. Accepts hex strings, named colors, or Color instances. stroke_color str \\| Color None Stroke color for the capsule border. stroke_width float None Width of the stroke in points. **modifiers Common view modifiers: width , height , padding , opacity , animation , etc.","title":"Parameters"},{"location":"reference/views/shapes/capsule/#examples","text":"","title":"Examples"},{"location":"reference/views/shapes/capsule/#basic-capsule-shapes","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ # Horizontal capsule nib . Capsule ( fill = nib . Color . BLUE , width = 150 , height = 50 ), # Vertical capsule nib . Capsule ( fill = nib . Color . GREEN , width = 40 , height = 120 ), # Capsule with stroke nib . Capsule ( fill = nib . Color . PURPLE , stroke_color = nib . Color . WHITE , stroke_width = 2 , width = 120 , height = 40 , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Basic capsule shapes"},{"location":"reference/views/shapes/capsule/#tag-badge-with-capsule-background","text":"Use a Capsule as the background for text to create pill-shaped labels. import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ nib . Text ( \"NEW\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE , padding = { \"horizontal\" : 10 , \"vertical\" : 4 }, background = nib . Capsule ( fill = nib . Color . RED ), ), nib . Text ( \"SALE\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE , padding = { \"horizontal\" : 10 , \"vertical\" : 4 }, background = nib . Capsule ( fill = nib . Color . GREEN ), ), nib . Text ( \"HOT\" , font = nib . Font . CAPTION , foreground_color = nib . Color . WHITE , padding = { \"horizontal\" : 10 , \"vertical\" : 4 }, background = nib . Capsule ( fill = nib . Color . ORANGE ), ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Tag / badge with capsule background"},{"location":"reference/views/shapes/capsule/#capsule-as-clip-shape","text":"Clip an image into a capsule shape for a banner-style appearance. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Image ( url = \"https://example.com/banner.jpg\" , width = 200 , height = 60 , clip_shape = nib . Capsule (), ), nib . Text ( \"Clipped to capsule shape\" ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Capsule as clip shape"},{"location":"reference/views/shapes/circle/","text":"A circular shape centered in its frame. Circle always maintains a 1:1 aspect ratio, filling the smaller dimension of its frame. Circle supports trim properties for drawing partial arcs, making it useful for progress rings and arc indicators. Values for trim_from and trim_to range from 0.0 to 1.0, where 0.0 is the 3 o'clock position and 1.0 is a full circle. Use rotation to change the starting position (for example, -90 to start from the top). Constructor \u00b6 nib . Circle ( fill = None , stroke_color = None , stroke_width = None , trim_from = None , trim_to = None , rotation = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description fill str \\| Color None Fill color for the circle interior. Accepts hex strings, named colors, or Color instances. stroke_color str \\| Color None Stroke color for the circle border. stroke_width float None Width of the stroke in points. trim_from float None Fractional starting point (0.0 to 1.0) for partial circle arcs. trim_to float None Fractional ending point (0.0 to 1.0) for partial circle arcs. rotation float None Rotation angle in degrees. Use -90 to start trimmed circles from the top instead of the right. **modifiers Common view modifiers: width , height , padding , opacity , animation , etc. Examples \u00b6 Basic circles \u00b6 import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ # Filled circle nib . Circle ( fill = nib . Color . BLUE , width = 60 , height = 60 ), # Circle with stroke nib . Circle ( fill = nib . Color . RED , stroke_color = nib . Color . WHITE , stroke_width = 2 , width = 60 , height = 60 , ), # Stroke-only circle nib . Circle ( stroke_color = nib . Color . GREEN , stroke_width = 3 , width = 60 , height = 60 , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Progress ring \u00b6 Use trim_from and trim_to to create a progress indicator. Set rotation=-90 to start from the top. import nib def main ( app : nib . App ): progress = 0.75 app . build ( nib . ZStack ( controls = [ # Background track nib . Circle ( stroke_color = \"#333333\" , stroke_width = 8 , width = 100 , height = 100 , ), # Progress arc nib . Circle ( stroke_color = nib . Color . BLUE , stroke_width = 8 , trim_from = 0.0 , trim_to = progress , rotation =- 90 , width = 100 , height = 100 , ), # Label nib . Text ( f \" { int ( progress * 100 ) } %\" , font = nib . Font . HEADLINE ), ], padding = 16 , ) ) nib . run ( main ) Circle as clip shape \u00b6 Clip an image into a circular shape. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Image ( url = \"https://example.com/avatar.jpg\" , width = 80 , height = 80 , clip_shape = nib . Circle (), ), nib . Text ( \"Username\" , font = nib . Font . HEADLINE ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Circle"},{"location":"reference/views/shapes/circle/#constructor","text":"nib . Circle ( fill = None , stroke_color = None , stroke_width = None , trim_from = None , trim_to = None , rotation = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/shapes/circle/#parameters","text":"Parameter Type Default Description fill str \\| Color None Fill color for the circle interior. Accepts hex strings, named colors, or Color instances. stroke_color str \\| Color None Stroke color for the circle border. stroke_width float None Width of the stroke in points. trim_from float None Fractional starting point (0.0 to 1.0) for partial circle arcs. trim_to float None Fractional ending point (0.0 to 1.0) for partial circle arcs. rotation float None Rotation angle in degrees. Use -90 to start trimmed circles from the top instead of the right. **modifiers Common view modifiers: width , height , padding , opacity , animation , etc.","title":"Parameters"},{"location":"reference/views/shapes/circle/#examples","text":"","title":"Examples"},{"location":"reference/views/shapes/circle/#basic-circles","text":"import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ # Filled circle nib . Circle ( fill = nib . Color . BLUE , width = 60 , height = 60 ), # Circle with stroke nib . Circle ( fill = nib . Color . RED , stroke_color = nib . Color . WHITE , stroke_width = 2 , width = 60 , height = 60 , ), # Stroke-only circle nib . Circle ( stroke_color = nib . Color . GREEN , stroke_width = 3 , width = 60 , height = 60 , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Basic circles"},{"location":"reference/views/shapes/circle/#progress-ring","text":"Use trim_from and trim_to to create a progress indicator. Set rotation=-90 to start from the top. import nib def main ( app : nib . App ): progress = 0.75 app . build ( nib . ZStack ( controls = [ # Background track nib . Circle ( stroke_color = \"#333333\" , stroke_width = 8 , width = 100 , height = 100 , ), # Progress arc nib . Circle ( stroke_color = nib . Color . BLUE , stroke_width = 8 , trim_from = 0.0 , trim_to = progress , rotation =- 90 , width = 100 , height = 100 , ), # Label nib . Text ( f \" { int ( progress * 100 ) } %\" , font = nib . Font . HEADLINE ), ], padding = 16 , ) ) nib . run ( main )","title":"Progress ring"},{"location":"reference/views/shapes/circle/#circle-as-clip-shape","text":"Clip an image into a circular shape. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Image ( url = \"https://example.com/avatar.jpg\" , width = 80 , height = 80 , clip_shape = nib . Circle (), ), nib . Text ( \"Username\" , font = nib . Font . HEADLINE ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Circle as clip shape"},{"location":"reference/views/shapes/ellipse/","text":"An oval shape that stretches to fill its frame with independent width and height dimensions. Unlike Circle which maintains a 1:1 aspect ratio, Ellipse can have different width and height values, creating an oval shape. When width equals height, an Ellipse appears identical to a Circle. Constructor \u00b6 nib . Ellipse ( fill = None , stroke_color = None , stroke_width = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description fill str \\| Color None Fill color for the ellipse interior. Accepts hex strings, named colors, or Color instances. stroke_color str \\| Color None Stroke color for the ellipse border. stroke_width float None Width of the stroke in points. **modifiers Common view modifiers: width , height , padding , opacity , animation , etc. Examples \u00b6 Basic ellipses \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ # Wide ellipse nib . Ellipse ( fill = nib . Color . BLUE , width = 150 , height = 80 ), # Tall ellipse nib . Ellipse ( fill = nib . Color . PURPLE , width = 80 , height = 150 ), # Ellipse with stroke nib . Ellipse ( fill = nib . Color . ORANGE , stroke_color = nib . Color . WHITE , stroke_width = 2 , width = 120 , height = 60 , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Ellipse as background \u00b6 Use an Ellipse as a decorative background for text badges. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Badge\" , foreground_color = nib . Color . WHITE , font = nib . Font . CAPTION , padding = { \"horizontal\" : 16 , \"vertical\" : 8 }, background = nib . Ellipse ( fill = nib . Color . RED ), ), ], padding = 16 , ) ) nib . run ( main ) Decorative oval ring \u00b6 Create a stroke-only ellipse for decorative purposes. import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Ellipse ( stroke_color = \"#4ECDC4\" , stroke_width = 3 , width = 200 , height = 120 , opacity = 0.5 , ), nib . Ellipse ( stroke_color = \"#FF6B6B\" , stroke_width = 3 , width = 160 , height = 90 , opacity = 0.5 , ), nib . Text ( \"Centered\" , font = nib . Font . HEADLINE ), ], padding = 16 , ) ) nib . run ( main )","title":"Ellipse"},{"location":"reference/views/shapes/ellipse/#constructor","text":"nib . Ellipse ( fill = None , stroke_color = None , stroke_width = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/shapes/ellipse/#parameters","text":"Parameter Type Default Description fill str \\| Color None Fill color for the ellipse interior. Accepts hex strings, named colors, or Color instances. stroke_color str \\| Color None Stroke color for the ellipse border. stroke_width float None Width of the stroke in points. **modifiers Common view modifiers: width , height , padding , opacity , animation , etc.","title":"Parameters"},{"location":"reference/views/shapes/ellipse/#examples","text":"","title":"Examples"},{"location":"reference/views/shapes/ellipse/#basic-ellipses","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ # Wide ellipse nib . Ellipse ( fill = nib . Color . BLUE , width = 150 , height = 80 ), # Tall ellipse nib . Ellipse ( fill = nib . Color . PURPLE , width = 80 , height = 150 ), # Ellipse with stroke nib . Ellipse ( fill = nib . Color . ORANGE , stroke_color = nib . Color . WHITE , stroke_width = 2 , width = 120 , height = 60 , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Basic ellipses"},{"location":"reference/views/shapes/ellipse/#ellipse-as-background","text":"Use an Ellipse as a decorative background for text badges. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Badge\" , foreground_color = nib . Color . WHITE , font = nib . Font . CAPTION , padding = { \"horizontal\" : 16 , \"vertical\" : 8 }, background = nib . Ellipse ( fill = nib . Color . RED ), ), ], padding = 16 , ) ) nib . run ( main )","title":"Ellipse as background"},{"location":"reference/views/shapes/ellipse/#decorative-oval-ring","text":"Create a stroke-only ellipse for decorative purposes. import nib def main ( app : nib . App ): app . build ( nib . ZStack ( controls = [ nib . Ellipse ( stroke_color = \"#4ECDC4\" , stroke_width = 3 , width = 200 , height = 120 , opacity = 0.5 , ), nib . Ellipse ( stroke_color = \"#FF6B6B\" , stroke_width = 3 , width = 160 , height = 90 , opacity = 0.5 , ), nib . Text ( \"Centered\" , font = nib . Font . HEADLINE ), ], padding = 16 , ) ) nib . run ( main )","title":"Decorative oval ring"},{"location":"reference/views/shapes/gradients/","text":"Gradient views create smooth color transitions that can be used as standalone views, backgrounds, or fills for custom shapes. Nib provides four gradient types: LinearGradient , RadialGradient , AngularGradient , and EllipticalGradient . All gradients accept either a colors list (evenly distributed) or a stops list (explicit position control). Use one or the other, not both. LinearGradient \u00b6 Colors transition along a straight line from a start point to an end point. Points are specified in unit coordinates where (0, 0) is top-left and (1, 1) is bottom-right. Constructor \u00b6 nib . LinearGradient ( colors = None , stops = None , start = ( 0.5 , 0 ), end = ( 0.5 , 1 ), ** modifiers , ) Parameters \u00b6 Parameter Type Default Description colors list[str \\| Color] None Colors for the gradient, evenly distributed. Use this or stops , not both. stops list[tuple[float, str]] None List of (position, color) tuples for explicit control. Positions are 0.0 to 1.0. start tuple[float, float] (0.5, 0) Start point in unit coordinates. Default is top-center. end tuple[float, float] (0.5, 1) End point in unit coordinates. Default is bottom-center. **modifiers Common view modifiers: width , height , padding , opacity , etc. RadialGradient \u00b6 Colors radiate outward from a center point in a circular pattern. Constructor \u00b6 nib . RadialGradient ( colors = None , stops = None , center = ( 0.5 , 0.5 ), start_radius = 0 , end_radius = 100 , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description colors list[str \\| Color] None Colors for the gradient, evenly distributed. stops list[tuple[float, str]] None List of (position, color) tuples for explicit control. center tuple[float, float] (0.5, 0.5) Center point in unit coordinates. start_radius float 0 Inner radius where the gradient begins, in points. end_radius float 100 Outer radius where the gradient ends, in points. **modifiers Common view modifiers. AngularGradient \u00b6 Colors rotate around a center point, creating a color wheel or conic gradient effect. Constructor \u00b6 nib . AngularGradient ( colors = None , stops = None , center = ( 0.5 , 0.5 ), start_angle = 0 , end_angle = 360 , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description colors list[str \\| Color] None Colors for the gradient, evenly distributed. stops list[tuple[float, str]] None List of (position, color) tuples for explicit control. center tuple[float, float] (0.5, 0.5) Center point in unit coordinates. start_angle float 0 Starting angle in degrees. end_angle float 360 Ending angle in degrees. **modifiers Common view modifiers. EllipticalGradient \u00b6 Colors radiate outward in an elliptical pattern that stretches to fill the view's frame, creating an elliptical pattern rather than circular. Constructor \u00b6 nib . EllipticalGradient ( colors = None , stops = None , center = ( 0.5 , 0.5 ), start_radius_fraction = 0 , end_radius_fraction = 0.5 , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description colors list[str \\| Color] None Colors for the gradient, evenly distributed. stops list[tuple[float, str]] None List of (position, color) tuples for explicit control. center tuple[float, float] (0.5, 0.5) Center point in unit coordinates. start_radius_fraction float 0 Fraction of the view size where the gradient starts. end_radius_fraction float 0.5 Fraction of the view size where the gradient ends. **modifiers Common view modifiers. Examples \u00b6 Linear gradient background \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Gradient Background\" , font = nib . Font . TITLE , foreground_color = nib . Color . WHITE ), ], padding = 32 , background = nib . LinearGradient ( colors = [ \"#667eea\" , \"#764ba2\" ], start = ( 0 , 0 ), end = ( 1 , 1 ), ), ) ) nib . run ( main ) Gradient with explicit stops \u00b6 Control exactly where each color appears using stops. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ # Linear with stops nib . LinearGradient ( stops = [ ( 0.0 , \"#FF0000\" ), ( 0.3 , \"#FFFF00\" ), ( 0.7 , \"#00FF00\" ), ( 1.0 , \"#0000FF\" ), ], start = ( 0 , 0.5 ), end = ( 1 , 0.5 ), height = 60 , corner_radius = 8 , ), # Radial gradient nib . RadialGradient ( colors = [ \"#FFFFFF\" , \"#000000\" ], center = ( 0.5 , 0.5 ), start_radius = 0 , end_radius = 120 , width = 200 , height = 200 , corner_radius = 8 , ), ], spacing = 16 , padding = 16 , ) ) nib . run ( main ) Angular color wheel \u00b6 import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . AngularGradient ( colors = [ \"#FF0000\" , \"#FF8000\" , \"#FFFF00\" , \"#00FF00\" , \"#00FFFF\" , \"#0000FF\" , \"#8000FF\" , \"#FF0080\" , \"#FF0000\" , ], center = ( 0.5 , 0.5 ), width = 200 , height = 200 , clip_shape = nib . Circle (), ), nib . Text ( \"Color Wheel\" , font = nib . Font . CAPTION ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Gradients"},{"location":"reference/views/shapes/gradients/#lineargradient","text":"Colors transition along a straight line from a start point to an end point. Points are specified in unit coordinates where (0, 0) is top-left and (1, 1) is bottom-right.","title":"LinearGradient"},{"location":"reference/views/shapes/gradients/#constructor","text":"nib . LinearGradient ( colors = None , stops = None , start = ( 0.5 , 0 ), end = ( 0.5 , 1 ), ** modifiers , )","title":"Constructor"},{"location":"reference/views/shapes/gradients/#parameters","text":"Parameter Type Default Description colors list[str \\| Color] None Colors for the gradient, evenly distributed. Use this or stops , not both. stops list[tuple[float, str]] None List of (position, color) tuples for explicit control. Positions are 0.0 to 1.0. start tuple[float, float] (0.5, 0) Start point in unit coordinates. Default is top-center. end tuple[float, float] (0.5, 1) End point in unit coordinates. Default is bottom-center. **modifiers Common view modifiers: width , height , padding , opacity , etc.","title":"Parameters"},{"location":"reference/views/shapes/gradients/#radialgradient","text":"Colors radiate outward from a center point in a circular pattern.","title":"RadialGradient"},{"location":"reference/views/shapes/gradients/#constructor_1","text":"nib . RadialGradient ( colors = None , stops = None , center = ( 0.5 , 0.5 ), start_radius = 0 , end_radius = 100 , ** modifiers , )","title":"Constructor"},{"location":"reference/views/shapes/gradients/#parameters_1","text":"Parameter Type Default Description colors list[str \\| Color] None Colors for the gradient, evenly distributed. stops list[tuple[float, str]] None List of (position, color) tuples for explicit control. center tuple[float, float] (0.5, 0.5) Center point in unit coordinates. start_radius float 0 Inner radius where the gradient begins, in points. end_radius float 100 Outer radius where the gradient ends, in points. **modifiers Common view modifiers.","title":"Parameters"},{"location":"reference/views/shapes/gradients/#angulargradient","text":"Colors rotate around a center point, creating a color wheel or conic gradient effect.","title":"AngularGradient"},{"location":"reference/views/shapes/gradients/#constructor_2","text":"nib . AngularGradient ( colors = None , stops = None , center = ( 0.5 , 0.5 ), start_angle = 0 , end_angle = 360 , ** modifiers , )","title":"Constructor"},{"location":"reference/views/shapes/gradients/#parameters_2","text":"Parameter Type Default Description colors list[str \\| Color] None Colors for the gradient, evenly distributed. stops list[tuple[float, str]] None List of (position, color) tuples for explicit control. center tuple[float, float] (0.5, 0.5) Center point in unit coordinates. start_angle float 0 Starting angle in degrees. end_angle float 360 Ending angle in degrees. **modifiers Common view modifiers.","title":"Parameters"},{"location":"reference/views/shapes/gradients/#ellipticalgradient","text":"Colors radiate outward in an elliptical pattern that stretches to fill the view's frame, creating an elliptical pattern rather than circular.","title":"EllipticalGradient"},{"location":"reference/views/shapes/gradients/#constructor_3","text":"nib . EllipticalGradient ( colors = None , stops = None , center = ( 0.5 , 0.5 ), start_radius_fraction = 0 , end_radius_fraction = 0.5 , ** modifiers , )","title":"Constructor"},{"location":"reference/views/shapes/gradients/#parameters_3","text":"Parameter Type Default Description colors list[str \\| Color] None Colors for the gradient, evenly distributed. stops list[tuple[float, str]] None List of (position, color) tuples for explicit control. center tuple[float, float] (0.5, 0.5) Center point in unit coordinates. start_radius_fraction float 0 Fraction of the view size where the gradient starts. end_radius_fraction float 0.5 Fraction of the view size where the gradient ends. **modifiers Common view modifiers.","title":"Parameters"},{"location":"reference/views/shapes/gradients/#examples","text":"","title":"Examples"},{"location":"reference/views/shapes/gradients/#linear-gradient-background","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Gradient Background\" , font = nib . Font . TITLE , foreground_color = nib . Color . WHITE ), ], padding = 32 , background = nib . LinearGradient ( colors = [ \"#667eea\" , \"#764ba2\" ], start = ( 0 , 0 ), end = ( 1 , 1 ), ), ) ) nib . run ( main )","title":"Linear gradient background"},{"location":"reference/views/shapes/gradients/#gradient-with-explicit-stops","text":"Control exactly where each color appears using stops. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ # Linear with stops nib . LinearGradient ( stops = [ ( 0.0 , \"#FF0000\" ), ( 0.3 , \"#FFFF00\" ), ( 0.7 , \"#00FF00\" ), ( 1.0 , \"#0000FF\" ), ], start = ( 0 , 0.5 ), end = ( 1 , 0.5 ), height = 60 , corner_radius = 8 , ), # Radial gradient nib . RadialGradient ( colors = [ \"#FFFFFF\" , \"#000000\" ], center = ( 0.5 , 0.5 ), start_radius = 0 , end_radius = 120 , width = 200 , height = 200 , corner_radius = 8 , ), ], spacing = 16 , padding = 16 , ) ) nib . run ( main )","title":"Gradient with explicit stops"},{"location":"reference/views/shapes/gradients/#angular-color-wheel","text":"import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . AngularGradient ( colors = [ \"#FF0000\" , \"#FF8000\" , \"#FFFF00\" , \"#00FF00\" , \"#00FFFF\" , \"#0000FF\" , \"#8000FF\" , \"#FF0080\" , \"#FF0000\" , ], center = ( 0.5 , 0.5 ), width = 200 , height = 200 , clip_shape = nib . Circle (), ), nib . Text ( \"Color Wheel\" , font = nib . Font . CAPTION ), ], spacing = 8 , padding = 16 , ) ) nib . run ( main )","title":"Angular color wheel"},{"location":"reference/views/shapes/path/","text":"Path provides a fluent builder API for constructing custom shapes using lines, bezier curves, arcs, and geometric primitives. Shape is a View that renders a Path on screen, with support for fill colors, strokes, and gradient fills. You can define custom shapes either inline by passing a Path to the Shape constructor, or by subclassing Shape and overriding build_path() for reusable shapes. Constructor \u00b6 nib . Path () nib . Shape ( path = None , view_box = None , fill = None , stroke = None , stroke_width = None , ** modifiers , ) Parameters \u00b6 Shape \u00b6 Parameter Type Default Description path Path None A Path object with path operations. If not provided, build_path() is called to generate the path. view_box tuple[float, float] None Coordinate system as (width, height) . When set, the path is scaled to fit the view bounds while preserving aspect ratio. Overrides the class-level view_box if provided. fill str \\| Gradient None Fill color as a hex string, color name, or a gradient ( LinearGradient , RadialGradient , etc.). stroke str None Stroke color as a hex string or color name. stroke_width float None Width of the stroke in points. **modifiers Common view modifiers: width , height , padding , opacity , etc. Path Methods \u00b6 All Path methods return self for method chaining. Method Description move_to(x, y) Move to a point without drawing. Starts a new subpath. line_to(x, y) Draw a straight line to a point. curve_to(x, y, control1, control2) Draw a cubic bezier curve. control1 and control2 are (x, y) tuples. quad_curve_to(x, y, control) Draw a quadratic bezier curve. control is an (x, y) tuple. arc(center, radius, start_angle, end_angle, clockwise=True) Draw an arc. center is an (x, y) tuple. Angles are in radians. close() Close the current subpath by drawing a line back to the starting point. add_rect(x, y, width, height) Add a rectangle subpath. add_rounded_rect(x, y, width, height, corner_radius) Add a rounded rectangle subpath. add_ellipse(x, y, width, height) Add an ellipse subpath within the bounding rectangle. add_circle(center_x, center_y, radius) Add a circle subpath. Examples \u00b6 Triangle with inline path \u00b6 import nib def main ( app : nib . App ): triangle = nib . Path () triangle . move_to ( 50 , 0 ) triangle . line_to ( 100 , 100 ) triangle . line_to ( 0 , 100 ) triangle . close () app . build ( nib . Shape ( path = triangle , view_box = ( 100 , 100 ), fill = \"#3B82F6\" , width = 200 , height = 200 , ) ) nib . run ( main ) Reusable shape via subclass \u00b6 Subclass Shape and override build_path() for reusable custom shapes. Set view_box as a class attribute to define the coordinate system. import nib import math class Star ( nib . Shape ): view_box = ( 100 , 100 ) def build_path ( self , path ): cx , cy , outer , inner = 50 , 50 , 50 , 20 for i in range ( 10 ): angle = math . pi / 2 + i * math . pi / 5 r = outer if i % 2 == 0 else inner x = cx + r * math . cos ( angle ) y = cy - r * math . sin ( angle ) if i == 0 : path . move_to ( x , y ) else : path . line_to ( x , y ) return path . close () def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ Star ( fill = \"#FFD700\" , width = 64 , height = 64 ), Star ( fill = \"#FF6B6B\" , width = 48 , height = 48 ), Star ( fill = \"#4ECDC4\" , stroke = \"#FFFFFF\" , stroke_width = 2 , width = 64 , height = 64 , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Shape with gradient fill \u00b6 import nib def main ( app : nib . App ): path = ( nib . Path () . move_to ( 50 , 0 ) . line_to ( 100 , 38 ) . line_to ( 81 , 100 ) . line_to ( 19 , 100 ) . line_to ( 0 , 38 ) . close ()) app . build ( nib . Shape ( path = path , view_box = ( 100 , 100 ), fill = nib . LinearGradient ( colors = [ \"#FF6B6B\" , \"#4ECDC4\" ], start = ( 0 , 0 ), end = ( 1 , 1 ), ), width = 200 , height = 200 , padding = 16 , ) ) nib . run ( main )","title":"Path & Shape"},{"location":"reference/views/shapes/path/#constructor","text":"nib . Path () nib . Shape ( path = None , view_box = None , fill = None , stroke = None , stroke_width = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/shapes/path/#parameters","text":"","title":"Parameters"},{"location":"reference/views/shapes/path/#shape","text":"Parameter Type Default Description path Path None A Path object with path operations. If not provided, build_path() is called to generate the path. view_box tuple[float, float] None Coordinate system as (width, height) . When set, the path is scaled to fit the view bounds while preserving aspect ratio. Overrides the class-level view_box if provided. fill str \\| Gradient None Fill color as a hex string, color name, or a gradient ( LinearGradient , RadialGradient , etc.). stroke str None Stroke color as a hex string or color name. stroke_width float None Width of the stroke in points. **modifiers Common view modifiers: width , height , padding , opacity , etc.","title":"Shape"},{"location":"reference/views/shapes/path/#path-methods","text":"All Path methods return self for method chaining. Method Description move_to(x, y) Move to a point without drawing. Starts a new subpath. line_to(x, y) Draw a straight line to a point. curve_to(x, y, control1, control2) Draw a cubic bezier curve. control1 and control2 are (x, y) tuples. quad_curve_to(x, y, control) Draw a quadratic bezier curve. control is an (x, y) tuple. arc(center, radius, start_angle, end_angle, clockwise=True) Draw an arc. center is an (x, y) tuple. Angles are in radians. close() Close the current subpath by drawing a line back to the starting point. add_rect(x, y, width, height) Add a rectangle subpath. add_rounded_rect(x, y, width, height, corner_radius) Add a rounded rectangle subpath. add_ellipse(x, y, width, height) Add an ellipse subpath within the bounding rectangle. add_circle(center_x, center_y, radius) Add a circle subpath.","title":"Path Methods"},{"location":"reference/views/shapes/path/#examples","text":"","title":"Examples"},{"location":"reference/views/shapes/path/#triangle-with-inline-path","text":"import nib def main ( app : nib . App ): triangle = nib . Path () triangle . move_to ( 50 , 0 ) triangle . line_to ( 100 , 100 ) triangle . line_to ( 0 , 100 ) triangle . close () app . build ( nib . Shape ( path = triangle , view_box = ( 100 , 100 ), fill = \"#3B82F6\" , width = 200 , height = 200 , ) ) nib . run ( main )","title":"Triangle with inline path"},{"location":"reference/views/shapes/path/#reusable-shape-via-subclass","text":"Subclass Shape and override build_path() for reusable custom shapes. Set view_box as a class attribute to define the coordinate system. import nib import math class Star ( nib . Shape ): view_box = ( 100 , 100 ) def build_path ( self , path ): cx , cy , outer , inner = 50 , 50 , 50 , 20 for i in range ( 10 ): angle = math . pi / 2 + i * math . pi / 5 r = outer if i % 2 == 0 else inner x = cx + r * math . cos ( angle ) y = cy - r * math . sin ( angle ) if i == 0 : path . move_to ( x , y ) else : path . line_to ( x , y ) return path . close () def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ Star ( fill = \"#FFD700\" , width = 64 , height = 64 ), Star ( fill = \"#FF6B6B\" , width = 48 , height = 48 ), Star ( fill = \"#4ECDC4\" , stroke = \"#FFFFFF\" , stroke_width = 2 , width = 64 , height = 64 , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Reusable shape via subclass"},{"location":"reference/views/shapes/path/#shape-with-gradient-fill","text":"import nib def main ( app : nib . App ): path = ( nib . Path () . move_to ( 50 , 0 ) . line_to ( 100 , 38 ) . line_to ( 81 , 100 ) . line_to ( 19 , 100 ) . line_to ( 0 , 38 ) . close ()) app . build ( nib . Shape ( path = path , view_box = ( 100 , 100 ), fill = nib . LinearGradient ( colors = [ \"#FF6B6B\" , \"#4ECDC4\" ], start = ( 0 , 0 ), end = ( 1 , 1 ), ), width = 200 , height = 200 , padding = 16 , ) ) nib . run ( main )","title":"Shape with gradient fill"},{"location":"reference/views/shapes/rectangle/","text":"A rectangular shape with configurable corner radii. Rectangle can have sharp corners (default), uniform rounded corners via a single float, or per-corner control using CornerRadius . When corner_radius is provided, Rectangle behaves as a rounded rectangle. For full per-corner control, pass a CornerRadius instance. Constructor \u00b6 nib . Rectangle ( fill = None , corner_radius = None , stroke_color = None , stroke_width = None , ** modifiers , ) Parameters \u00b6 Parameter Type Default Description fill str \\| Color None Fill color for the rectangle interior. Accepts hex strings ( \"#FF5733\" ), named colors ( \"red\" ), or Color instances. corner_radius float \\| CornerRadius None Corner rounding. A float applies a uniform radius to all corners. A CornerRadius instance provides per-corner control. None produces sharp corners. stroke_color str \\| Color None Stroke color for the rectangle border. stroke_width float None Width of the stroke in points. **modifiers Common view modifiers: width , height , padding , opacity , animation , etc. CornerRadius \u00b6 For per-corner control, use nib.CornerRadius : nib . CornerRadius ( top_left = 0 , top_right = 0 , bottom_left = 0 , bottom_right = 0 , ) Factory methods: Method Description CornerRadius.all(radius) Uniform radius for all corners. CornerRadius.vertical(top, bottom) Same radius for top corners and bottom corners. CornerRadius.only(**corners) Set only specific corners, others default to 0. Examples \u00b6 Basic shapes \u00b6 import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ # Sharp corners nib . Rectangle ( fill = nib . Color . BLUE , width = 80 , height = 80 ), # Rounded corners nib . Rectangle ( fill = nib . Color . GREEN , corner_radius = 12 , width = 80 , height = 80 , ), # With stroke nib . Rectangle ( fill = nib . Color . GRAY , corner_radius = 8 , stroke_color = nib . Color . WHITE , stroke_width = 2 , width = 80 , height = 80 , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main ) Per-corner radius \u00b6 Round only the top corners to create a card header shape. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Rectangle ( fill = \"#3B82F6\" , corner_radius = nib . CornerRadius ( top_left = 16 , top_right = 16 , bottom_left = 0 , bottom_right = 0 , ), width = 200 , height = 60 , ), nib . Rectangle ( fill = \"#1E293B\" , corner_radius = nib . CornerRadius . vertical ( top = 0 , bottom = 16 ), width = 200 , height = 100 , ), ], spacing = 0 , ) ) nib . run ( main ) Rectangle as background \u00b6 Pass a Rectangle (with or without rounded corners) as the background modifier for any view. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Card content\" , font = nib . Font . HEADLINE ), nib . Text ( \"Some details here\" , foreground_color = nib . Color . SECONDARY ), ], spacing = 8 , padding = 16 , background = nib . Rectangle ( fill = \"#262626\" , corner_radius = 12 , stroke_color = \"#383837\" , stroke_width = 1 , ), ) ) nib . run ( main )","title":"Rectangle"},{"location":"reference/views/shapes/rectangle/#constructor","text":"nib . Rectangle ( fill = None , corner_radius = None , stroke_color = None , stroke_width = None , ** modifiers , )","title":"Constructor"},{"location":"reference/views/shapes/rectangle/#parameters","text":"Parameter Type Default Description fill str \\| Color None Fill color for the rectangle interior. Accepts hex strings ( \"#FF5733\" ), named colors ( \"red\" ), or Color instances. corner_radius float \\| CornerRadius None Corner rounding. A float applies a uniform radius to all corners. A CornerRadius instance provides per-corner control. None produces sharp corners. stroke_color str \\| Color None Stroke color for the rectangle border. stroke_width float None Width of the stroke in points. **modifiers Common view modifiers: width , height , padding , opacity , animation , etc.","title":"Parameters"},{"location":"reference/views/shapes/rectangle/#cornerradius","text":"For per-corner control, use nib.CornerRadius : nib . CornerRadius ( top_left = 0 , top_right = 0 , bottom_left = 0 , bottom_right = 0 , ) Factory methods: Method Description CornerRadius.all(radius) Uniform radius for all corners. CornerRadius.vertical(top, bottom) Same radius for top corners and bottom corners. CornerRadius.only(**corners) Set only specific corners, others default to 0.","title":"CornerRadius"},{"location":"reference/views/shapes/rectangle/#examples","text":"","title":"Examples"},{"location":"reference/views/shapes/rectangle/#basic-shapes","text":"import nib def main ( app : nib . App ): app . build ( nib . HStack ( controls = [ # Sharp corners nib . Rectangle ( fill = nib . Color . BLUE , width = 80 , height = 80 ), # Rounded corners nib . Rectangle ( fill = nib . Color . GREEN , corner_radius = 12 , width = 80 , height = 80 , ), # With stroke nib . Rectangle ( fill = nib . Color . GRAY , corner_radius = 8 , stroke_color = nib . Color . WHITE , stroke_width = 2 , width = 80 , height = 80 , ), ], spacing = 12 , padding = 16 , ) ) nib . run ( main )","title":"Basic shapes"},{"location":"reference/views/shapes/rectangle/#per-corner-radius","text":"Round only the top corners to create a card header shape. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Rectangle ( fill = \"#3B82F6\" , corner_radius = nib . CornerRadius ( top_left = 16 , top_right = 16 , bottom_left = 0 , bottom_right = 0 , ), width = 200 , height = 60 , ), nib . Rectangle ( fill = \"#1E293B\" , corner_radius = nib . CornerRadius . vertical ( top = 0 , bottom = 16 ), width = 200 , height = 100 , ), ], spacing = 0 , ) ) nib . run ( main )","title":"Per-corner radius"},{"location":"reference/views/shapes/rectangle/#rectangle-as-background","text":"Pass a Rectangle (with or without rounded corners) as the background modifier for any view. import nib def main ( app : nib . App ): app . build ( nib . VStack ( controls = [ nib . Text ( \"Card content\" , font = nib . Font . HEADLINE ), nib . Text ( \"Some details here\" , foreground_color = nib . Color . SECONDARY ), ], spacing = 8 , padding = 16 , background = nib . Rectangle ( fill = \"#262626\" , corner_radius = 12 , stroke_color = \"#383837\" , stroke_width = 1 , ), ) ) nib . run ( main )","title":"Rectangle as background"}]}